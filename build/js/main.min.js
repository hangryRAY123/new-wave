(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

var _iosVhFix = require("./utils/ios-vh-fix");
var _burger = require("./modules/burger-menu/burger");
var _scrollTo = require("./modules/burger-menu/scroll-to");
var _stickyHeader = require("./modules/sticky-header/sticky-header");
var _index = require("./modules/animation/index");
var _index2 = require("./modules/exhibitions/index");
var _preloader = require("./modules/preloader");
var _map = require("./modules/map/map");
var _stickyBlock = require("./modules/sticky-block/sticky-block");
var _observers = require("./utils/observers");
// import {initPalm} from './modules/animation/flying-pictures';

window.addEventListener('DOMContentLoaded', function () {
  (0, _iosVhFix.iosVhFix)();
  var preloader = new _preloader.Preloader();
  preloader.init();
  window.addEventListener('load', function () {
    (0, _index2.initExhibitionsScripts)();
    (0, _index.initAnimationModules)();
    (0, _map.createMap)();
    _observers.resizeObserver.subscribe(_stickyBlock.initStickyScroll);
    // resizeObserver.subscribe(initPalm);
    (0, _scrollTo.initScrollTo)();
    _burger.burger.init();
    var stickyHeader = new _stickyHeader.StickyHeader();
    stickyHeader.init();
  });
});

},{"./modules/animation/index":7,"./modules/burger-menu/burger":9,"./modules/burger-menu/scroll-to":10,"./modules/exhibitions/index":12,"./modules/map/map":16,"./modules/preloader":17,"./modules/sticky-block/sticky-block":19,"./modules/sticky-header/sticky-header":20,"./utils/ios-vh-fix":22,"./utils/observers":23}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initArt = void 0;
var _gsapMin = require("../../vendor/gsap/gsap.min.js");
var _scrollTriggerMin = require("../../vendor/gsap/scroll-trigger.min.js");
var initArt = function initArt() {
  var imgTimeline = _gsapMin.gsap.timeline({
    paused: true
  });
  imgTimeline.fromTo('[data-animate-img="parallax"] img', {
    yPercent: 10,
    scale: 1.2,
    duration: 2,
    ease: 'Power1.easeInOut'
  }, {
    yPercent: -10,
    scale: 1.3,
    duration: 2,
    ease: 'Power1.easeInOut'
  });
  _scrollTriggerMin.ScrollTrigger.create({
    animation: imgTimeline,
    scrub: 1,
    trigger: '[data-animate-img="parallax"] img',
    start: 'top bottom',
    end: 'bottom top'
  });
};
exports.initArt = initArt;

},{"../../vendor/gsap/gsap.min.js":25,"../../vendor/gsap/scroll-trigger.min.js":27}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initFeelArt = void 0;
var _gsapMin = require("../../vendor/gsap/gsap.min.js");
var initFeelArt = function initFeelArt() {
  var parallaxItem = document.querySelector('[data-parallax-mouse]');
  var parallaxArt = document.querySelector('[data-parallax-art]');
  if (!parallaxArt) {
    return;
  }
  var mouseCords = {
    x: 0,
    y: 0
  };
  var handleMouseMove = function handleMouseMove(e) {
    mouseCords.x = e.clientX - window.innerWidth / 2;
    mouseCords.y = e.clientY - window.innerHeight / 2;
  };
  var handleMouseOut = function handleMouseOut() {
    mouseCords.x = 0;
    mouseCords.y = 0;
  };
  parallaxArt.addEventListener('mousemove', handleMouseMove);
  parallaxArt.addEventListener('mouseout', handleMouseOut);
  var updateParallax = function updateParallax() {
    var movement = parallaxItem.dataset.movement ? parallaxItem.dataset.movement : 1;
    _gsapMin.gsap.to(parallaxItem, {
      x: mouseCords.x / movement,
      y: mouseCords.y / movement,
      duration: parallaxItem.dataset.duration ? parallaxItem.dataset.duration : 0.5,
      ease: 'power3.out'
    });
  };
  _gsapMin.gsap.ticker.add(updateParallax);
};
exports.initFeelArt = initFeelArt;

},{"../../vendor/gsap/gsap.min.js":25}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initFlyingPictures = void 0;
var _gsapMin = require("../../vendor/gsap/gsap.min.js");
var _scrollTriggerMin = require("../../vendor/gsap/scroll-trigger.min.js");
var initFlyingPictures = function initFlyingPictures() {
  var section = document.querySelector('[data-section-animation="flying-pictures"]');
  if (section !== null) {
    var tween = _gsapMin.gsap.timeline({
      defaults: {
        ease: 'sine.inOut'
      },
      paused: true
    });
    tween.to('[data-animation="palm"]', {
      yPercent: 220
    }).to('[data-animation="bust"]', {
      yPercent: -100
    }, '<');
    _scrollTriggerMin.ScrollTrigger.create({
      trigger: '[data-section-animation="flying-pictures"]',
      start: 'clamp(top bottom)',
      end: 'clamp(bottom top)',
      scrub: true,
      animation: tween
    });
  }
};
exports.initFlyingPictures = initFlyingPictures;

},{"../../vendor/gsap/gsap.min.js":25,"../../vendor/gsap/scroll-trigger.min.js":27}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateTimeline = void 0;
var _gsapMin = require("../../vendor/gsap/gsap.min.js");
var _scrollTriggerMin = require("../../vendor/gsap/scroll-trigger.min.js");
var _pageScroller = require("../../utils/page-scroller");
var getMaxWidth = function getMaxWidth(blocks) {
  var maxWidth = 0;
  blocks.forEach(function (block) {
    maxWidth += block.offsetWidth;
  });
  return maxWidth;
};
var getObjectFromString = function getObjectFromString(str) {
  if (str.indexOf('clipPath') !== -1) {
    var arr = str.split(':');
    return {
      clipPath: arr[1]
    };
  }
  return str.split(',').map(function (keyVal) {
    return keyVal.split(':').map(function (_) {
      return _.trim();
    });
  }).reduce(function (accumulator, currentValue) {
    accumulator[currentValue[0]] = isNaN(Number(currentValue[1])) ? currentValue[1] : Number(currentValue[1]);
    return accumulator;
  }, {});
};
var getAnimationObject = function getAnimationObject(el) {
  var obj = {};
  obj.element = el;
  obj.direction = el.dataset.animationDirection;
  obj.duration = +el.dataset.animationDuration || 1;
  obj.delay = +el.dataset.animationDelay || 0;
  obj.position = el.dataset.position;
  obj.animation = getObjectFromString(el.dataset.animation.toString());
  return obj;
};
var generateTimeline = function generateTimeline() {
  var sections = document.querySelectorAll('[data-section-animation]');
  sections.forEach(function (section) {
    var blocks = _gsapMin.gsap.utils.toArray(section.querySelectorAll('[data-animation]')).sort(function (a, b) {
      var aIndex = +a.dataset.index || 1;
      var bIndex = +b.dataset.index || 1;
      return aIndex - bIndex;
    });
    var tl = window.gsap.timeline({
      scrollTrigger: {
        scroller: (0, _pageScroller.pageScroller)(),
        trigger: section,
        start: section.dataset.start,
        end: section.hasAttribute('data-end') ? section.dataset.end : function () {
          return "+=".concat(getMaxWidth(blocks));
        },
        scrub: section.dataset.scrub ? Number(section.dataset.scrub) : 1.5,
        pin: section.hasAttribute('data-pin') ? true : false,
        pinSpacing: section.hasAttribute('data-pin-spacing') ? true : false
      }
    });
    blocks.forEach(function (block) {
      var obj = getAnimationObject(block);
      var direction = obj.direction || 'to';
      if (obj.position) {
        tl[direction](obj.element, Object.assign({
          duration: obj.duration,
          delay: obj.delay
        }, obj.animation), obj.position);
      } else {
        tl[direction](obj.element, Object.assign({
          duration: obj.duration,
          delay: obj.delay
        }, obj.animation));
      }
    });
    _scrollTriggerMin.ScrollTrigger.refresh();
  });
};
exports.generateTimeline = generateTimeline;

},{"../../utils/page-scroller":24,"../../vendor/gsap/gsap.min.js":25,"../../vendor/gsap/scroll-trigger.min.js":27}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _splittingMin = _interopRequireDefault(require("../../vendor/splitting.min.js"));
var _scrollTriggerMin = require("../../vendor/gsap/scroll-trigger.min.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var ImageCard = /*#__PURE__*/function () {
  function ImageCard(container) {
    _classCallCheck(this, ImageCard);
    if (!container) {
      return;
    }
    this.container = container;
    this.text = this.container.querySelector('[data-image-card="text"]');
    this.splitting = null;
    this.scrollTrigger = null;
  }
  _createClass(ImageCard, [{
    key: "create",
    value: function create() {
      var _this = this;
      this.splitting = new _splittingMin.default({
        target: this.text
      });
      this.scrollTrigger = _scrollTriggerMin.ScrollTrigger.create({
        trigger: this.container,
        start: 'top bottom',
        end: 'bottom top',
        scrub: true,
        onToggle: function onToggle(self) {
          _this.text.classList[self.isActive ? 'add' : 'remove']('image-card__text--splitting');
        }
      });
    }
  }, {
    key: "init",
    value: function init() {
      if (!this.container) {
        return;
      }
      this.create();
    }
  }]);
  return ImageCard;
}();
exports.default = ImageCard;

},{"../../vendor/gsap/scroll-trigger.min.js":27,"../../vendor/splitting.min.js":28}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initAnimationModules = void 0;
var _generateTimeline = require("./generate-timeline");
var _slider = require("./slider");
var _art = require("./art");
var _feelArt = require("./feel-art");
var _flyingPictures = require("./flying-pictures");
var _imageCard = _interopRequireDefault(require("./image-card"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var imageCardContainer = document.querySelector('[data-image-card]');
var initAnimationModules = function initAnimationModules() {
  var slider = new _slider.Slider();
  slider.init();
  (0, _art.initArt)();
  (0, _feelArt.initFeelArt)();
  (0, _flyingPictures.initFlyingPictures)();
  (0, _generateTimeline.generateTimeline)();
  var imageCard = new _imageCard.default(imageCardContainer);
  imageCard.init();
};
exports.initAnimationModules = initAnimationModules;

},{"./art":2,"./feel-art":3,"./flying-pictures":4,"./generate-timeline":5,"./image-card":6,"./slider":8}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Slider = void 0;
var _swiper = _interopRequireDefault(require("../../vendor/swiper"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var Slider = /*#__PURE__*/function () {
  function Slider() {
    _classCallCheck(this, Slider);
    this.slider = null;
  }
  _createClass(Slider, [{
    key: "init",
    value: function init() {
      this.slider = new _swiper.default('.mySwiper', {
        speed: 800,
        loop: true,
        autoplay: {
          delay: 4000,
          disableOnInteraction: false
        },
        pagination: {
          el: '.swiper-pagination',
          dynamicBullets: true,
          clickable: true
        }
      });
    }
  }]);
  return Slider;
}();
exports.Slider = Slider;

},{"../../vendor/swiper":29}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.burger = exports.Burger = void 0;
var _scrollLock = require("../scroll-lock");
var _focusLock = require("../focus-lock");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var Burger = /*#__PURE__*/function () {
  function Burger() {
    _classCallCheck(this, Burger);
    this._header = document.querySelector('[data-header]');
    this._burger = document.querySelector('[data-burger]');
    this._scrollLock = new _scrollLock.ScrollLock();
    this._focusLock = new _focusLock.FocusLock();
    this._isMenuOpen = false;
    this._onBurgerClick = this._onBurgerClick.bind(this);
    this._onDocumentKeydown = this._onDocumentKeydown.bind(this);
    this._onDocumentClick = this._onDocumentClick.bind(this);
    this._onLinkClick = this._onLinkClick.bind(this);
  }
  _createClass(Burger, [{
    key: "init",
    value: function init() {
      if (!this._burger) {
        return;
      }
      this._burger.addEventListener('click', this._onBurgerClick);
      this._resize();
    }
  }, {
    key: "_openMenu",
    value: function _openMenu() {
      this._isMenuOpen = true;
      this._header.classList.add('is-open');
      this._scrollLock.disableScrolling();
      document.addEventListener('keydown', this._onDocumentKeydown);
      document.addEventListener('click', this._onDocumentClick);
      document.addEventListener('click', this._onLinkClick);
      this._focusLock.lock('[data-header]');
      if (window.ls) {
        window.ls.stop();
      }
    }
  }, {
    key: "_closeMenu",
    value: function _closeMenu() {
      this._isMenuOpen = false;
      this._header.classList.remove('is-open');
      this._scrollLock.enableScrolling();
      this._focusLock.unlock('[data-header]');
      document.removeEventListener('keydown', this._onDocumentKeydown);
      document.removeEventListener('click', this._onDocumentClick);
      document.removeEventListener('click', this._onLinkClick);
      if (window.ls) {
        window.ls.start();
      }
    }
  }, {
    key: "_onBurgerClick",
    value: function _onBurgerClick() {
      if (this._isMenuOpen) {
        this._closeMenu();
      } else {
        this._openMenu();
      }
    }
  }, {
    key: "_onDocumentKeydown",
    value: function _onDocumentKeydown(evt) {
      if (evt.key === 'Escape') {
        this._closeMenu();
      }
    }
  }, {
    key: "_onDocumentClick",
    value: function _onDocumentClick(evt) {
      if (evt.target.hasAttribute('data-close-menu')) {
        this._closeMenu();
      }
    }
  }, {
    key: "_onLinkClick",
    value: function _onLinkClick(evt) {
      var isMobile = window.matchMedia('(max-width: 1024px)').matches;
      var isButton = evt.target.hasAttribute('data-move-to');
      if (isMobile && isButton) {
        this._closeMenu();
      }
    }
  }, {
    key: "_resize",
    value: function _resize() {
      var _this = this;
      window.addEventListener('resize', function () {
        if (window.innerWidth >= 1023) {
          _this._closeMenu();
        }
      });
    }
  }]);
  return Burger;
}();
exports.Burger = Burger;
var burger = new Burger();
exports.burger = burger;

},{"../focus-lock":14,"../scroll-lock":18}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scrollToHandler = exports.initScrollTo = void 0;
var _gsapMin = require("../../vendor/gsap/gsap.min.js");
var _scrollTo = require("../../vendor/gsap/scroll-to.min");
var header = document.querySelector('.header');
var setOffset = function setOffset(offset) {
  var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  if (offset === 'header') {
    if (!header) {
      return 0;
    }
    return header.getBoundingClientRect().height - padding;
  }
  return offset;
};
var scrollToHandler = function scrollToHandler(e) {
  e.preventDefault();
  var btn = e.target.closest('[data-move-to]');
  var mainElement = document.querySelector(btn.dataset.moveTo);
  var target = mainElement.closest('section.page-section');
  var styleOfTarget = window.getComputedStyle(target);
  var paddingTopOfTarget = styleOfTarget.paddingTop;
  var offset = setOffset(btn.dataset.offset, parseFloat(paddingTopOfTarget));
  var options = {
    duration: 1,
    offset: btn.dataset.offset ? offset : 0
  };
  _gsapMin.gsap.to(window, options.duration, {
    scrollTo: {
      y: target,
      offsetY: options.offset,
      autoKill: true
    },
    ease: 'power4.out'
  });
};
exports.scrollToHandler = scrollToHandler;
var initScrollTo = function initScrollTo() {
  _gsapMin.gsap.registerPlugin(_scrollTo.ScrollToPlugin);
  var scrollToButtons = document.querySelectorAll('[data-move-to]');
  scrollToButtons.forEach(function (btn) {
    btn.addEventListener('click', scrollToHandler);
  });
};
exports.initScrollTo = initScrollTo;

},{"../../vendor/gsap/gsap.min.js":25,"../../vendor/gsap/scroll-to.min":26}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _gsapMin = require("../../vendor/gsap/gsap.min.js");
var _scrollTriggerMin = require("../../vendor/gsap/scroll-trigger.min.js");
var _observers = require("../../utils/observers.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var HorizontalScroll = /*#__PURE__*/function () {
  function HorizontalScroll(container) {
    _classCallCheck(this, HorizontalScroll);
    if (!container) {
      return;
    }
    this.container = container;
    this.section = this.container.querySelector('[data-section="horizontal"]');
    this.sticky = this.container.querySelector('[data-section="sticky"]');
    this.content = this.container.querySelector('[data-section="content"]');
    this.tween = null;
    this.scrollTrigger = null;
    this.set = this.set.bind(this);
  }
  _createClass(HorizontalScroll, [{
    key: "toggle",
    value: function toggle() {
      this.section.classList.toggle('horizontal-scroll');
      this.sticky.classList.toggle('horizontal-scroll__sticky');
      this.content.classList.toggle('horizontal-scroll__content');
    }
  }, {
    key: "create",
    value: function create() {
      var _this = this;
      if (this.tween || this.scrollTrigger) {
        return;
      }
      this.toggle();
      var contentRect = this.content.getBoundingClientRect();
      this.section.style.minHeight = contentRect.width + 'px';
      this.tween = _gsapMin.gsap.timeline({
        paused: true
      });
      this.tween.to(this.content, {
        x: function x() {
          return -contentRect.width + (_this.section.dataset.hiddenEnd ? 0 : window.innerWidth);
        },
        ease: 'none'
      });
      this.scrollTrigger = _scrollTriggerMin.ScrollTrigger.create({
        trigger: this.container,
        start: this.section.dataset.start ? this.section.dataset.start : 'top top',
        end: this.section.dataset.end ? this.section.dataset.end : 'bottom bottom',
        scrub: 1,
        animation: this.tween
      });
    }
  }, {
    key: "remove",
    value: function remove() {
      if (!this.tween || !this.scrollTrigger) {
        return;
      }
      this.toggle();
      this.section.style.minHeight = 'auto';
      this.tween.seek(0).kill();
      this.tween = null;
      this.scrollTrigger.kill();
      this.scrollTrigger = null;
    }
  }, {
    key: "set",
    value: function set() {
      var isDesktop = window.matchMedia('(min-width:1024px)').matches;
      if (isDesktop) {
        this.remove();
        this.create();
      } else {
        this.remove();
      }
    }
  }, {
    key: "init",
    value: function init() {
      if (!this.container) {
        return;
      }
      this.set();
      _observers.resizeObserver.subscribe(this.set);
    }
  }]);
  return HorizontalScroll;
}();
exports.default = HorizontalScroll;

},{"../../utils/observers.js":23,"../../vendor/gsap/gsap.min.js":25,"../../vendor/gsap/scroll-trigger.min.js":27}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initExhibitionsScripts = void 0;
var _innerSwiper = _interopRequireDefault(require("./inner-swiper"));
var _horizontalScroll = _interopRequireDefault(require("./horizontal-scroll"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var swiperContainer = document.querySelector('[data-swiper="swiper"]');
var scrollContainer = document.querySelector('[data-section="exhibitions"]');
var initExhibitionsScripts = function initExhibitionsScripts() {
  var innerSwiper = new _innerSwiper.default(swiperContainer);
  innerSwiper.init();
  var horizontalScroll = new _horizontalScroll.default(scrollContainer);
  horizontalScroll.init();
};
exports.initExhibitionsScripts = initExhibitionsScripts;

},{"./horizontal-scroll":11,"./inner-swiper":13}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _swiper = _interopRequireDefault(require("../../vendor/swiper"));
var _observers = require("../../utils/observers.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var InnerSwiper = /*#__PURE__*/function () {
  function InnerSwiper(container) {
    _classCallCheck(this, InnerSwiper);
    if (!container) {
      return;
    }
    this.container = container;
    this.wrapper = this.container.querySelector('[data-swiper="wrapper"]');
    this.slides = this.container.querySelectorAll('[data-swiper="slide"]');
    this.swiper = null;
    this.set = this.set.bind(this);
  }
  _createClass(InnerSwiper, [{
    key: "toggle",
    value: function toggle() {
      this.container.classList.toggle('swiper');
      this.wrapper.classList.toggle('swiper-wrapper');
      this.slides.forEach(function (item) {
        item.classList.toggle('swiper-slide');
      });
    }
  }, {
    key: "create",
    value: function create() {
      if (this.swiper) {
        return;
      }
      this.toggle();
      this.swiper = new _swiper.default(this.container, {
        autoHeight: true,
        loop: false,
        navigation: {
          nextEl: '.inner-slider__toggle--next',
          prevEl: '.inner-slider__toggle--previous',
          disabledClass: 'inner-slider__toggle--disabled'
        }
      });
    }
  }, {
    key: "remove",
    value: function remove() {
      if (!this.swiper) {
        return;
      }
      this.toggle();
      this.swiper.destroy();
      this.swiper = null;
    }
  }, {
    key: "set",
    value: function set() {
      var isDesktop = window.matchMedia('(min-width:1024px)').matches;
      if (!isDesktop) {
        this.create();
      } else {
        this.remove();
      }
    }
  }, {
    key: "init",
    value: function init() {
      if (!this.container) {
        return;
      }
      this.set();
      _observers.resizeObserver.subscribe(this.set);
    }
  }]);
  return InnerSwiper;
}();
exports.default = InnerSwiper;

},{"../../utils/observers.js":23,"../../vendor/swiper":29}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FocusLock = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var SELECTORS = ['a[href]', 'area[href]', 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', 'select:not([disabled]):not([aria-hidden])', 'textarea:not([disabled]):not([aria-hidden])', 'button:not([disabled]):not([aria-hidden])', 'iframe', 'object', 'embed', '[contenteditable]', '[tabindex]:not([tabindex^="-"])'];
var FocusLock = /*#__PURE__*/function () {
  function FocusLock() {
    _classCallCheck(this, FocusLock);
    this._lockedSelector = null;
    this._focusableElements = null;
    this._endElement = null;
    this._selectors = SELECTORS;
    this._documentKeydownHandler = this._documentKeydownHandler.bind(this);
  }
  _createClass(FocusLock, [{
    key: "_documentKeydownHandler",
    value: function _documentKeydownHandler(evt) {
      var activeElement = document.activeElement;
      if (evt.key === 'Tab') {
        if (!this._focusableElements.length) {
          evt.preventDefault();
          activeElement.blur();
          return;
        }
        if (this._focusableElements.length === 1) {
          evt.preventDefault();
          this._focusableElements[0].focus();
          return;
        }
        if (this._focusableElements.length > 1 && !activeElement.closest(this._lockedSelector)) {
          evt.preventDefault();
          this._focusableElements[0].focus();
          return;
        }
      }
      if (evt.key === 'Tab' && !evt.shiftKey && activeElement === this._focusableElements[this._focusableElements.length - 1]) {
        evt.preventDefault();
        this._focusableElements[0].focus();
      }
      if (evt.key === 'Tab' && evt.shiftKey && activeElement === this._focusableElements[0]) {
        evt.preventDefault();
        this._focusableElements[this._focusableElements.length - 1].focus();
      }
    }
  }, {
    key: "lock",
    value: function lock(lockedSelector) {
      var startFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.unlock();
      this._lockedSelector = lockedSelector;
      var lockedElement = document.querySelector(this._lockedSelector);
      if (!lockedElement) {
        return;
      }
      this._focusableElements = lockedElement.querySelectorAll(this._selectors);
      this._endElement = document.activeElement;
      var startElement = lockedElement.querySelector('[data-focus]') || this._focusableElements[0];
      if (this._endElement) {
        this._endElement.blur();
      }
      if (startElement && startFocus) {
        startElement.focus();
      }
      document.addEventListener('keydown', this._documentKeydownHandler);
    }
  }, {
    key: "unlock",
    value: function unlock() {
      var returnFocus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (this._endElement && returnFocus) {
        this._endElement.focus();
      }
      this._lockedSelector = null;
      this._focusableElements = null;
      this._endElement = null;
      document.removeEventListener('keydown', this._documentKeydownHandler);
    }
  }]);
  return FocusLock;
}();
exports.FocusLock = FocusLock;
window.focusLock = new FocusLock();

},{}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.iosChecker = void 0;
var iosChecker = function iosChecker() {
  return ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(navigator.platform) || navigator.userAgent.includes('Mac') && 'ontouchend' in document;
};
exports.iosChecker = iosChecker;

},{}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMap = void 0;
var pinTemplate = "<div class=\"map__pin\">\n    <svg width=\"45\" height=\"45\" aria-hidden=\"true\">\n      <use xlink:href=\"img/stack.svg#pin\"></use>\n    </svg>\n  </div>";
var changePinColor = function changePinColor() {
  var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'black';
  document.querySelector('.map__pin').style.color = color;
};
var createMap = function createMap() {
  window.ymaps.ready(function () {
    var myMap = new window.ymaps.Map('map', {
      center: [60.158310, 24.936963],
      zoom: 11,
      controls: [],
      behaviors: ['drag', 'multiTouch']
    }, {
      autoFitToViewport: 'always',
      suppressMapOpenBlock: true
    });
    myMap.controls.add('zoomControl', {
      size: 'auto',
      position: 'bottom'
    });
    var placemarkLayout = window.ymaps.templateLayoutFactory.createClass(pinTemplate);
    var placemark = new window.ymaps.Placemark([60.158310, 24.936963], null, {
      placemarkType: 'mainPin',
      iconLayout: 'default#imageWithContent',
      iconImageHref: '',
      iconContentSize: [45, 45],
      iconContentOffset: [-19, -44],
      iconContentLayout: placemarkLayout,
      zIndex: 100
    });
    myMap.geoObjects.add(placemark);
    placemark.events.add(['mouseenter', 'mouseup'], function () {
      return changePinColor('#7c0d59');
    }).add('mouseleave', function () {
      return changePinColor('#b91a87');
    }).add('mousedown', function () {
      return changePinColor('#5b1144');
    });
  });
};
exports.createMap = createMap;

},{}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Preloader = void 0;
var _gsapMin = require("../vendor/gsap/gsap.min.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var Preloader = /*#__PURE__*/function () {
  function Preloader() {
    _classCallCheck(this, Preloader);
    this.body = document.querySelector('body');
    this.container = document.querySelector('[data-preloader]');
    this.animationElement = document.querySelector('[data-preloader="preloader-icon"] svg');
    this.event = new Event('loaderOff');
    this.pageLoaded = false;
    this.off = this.off.bind(this);
  }
  _createClass(Preloader, [{
    key: "on",
    value: function on() {
      var _this = this;
      this.body.classList.add('scroll-lock');
      if (this.container) {
        this.setAnimation();
        window.addEventListener('load', function () {
          _this.pageLoaded = true;
        });
      } else {
        this.body.classList.remove('scroll-lock');
        window.addEventListener('load', this.off());
      }
    }
  }, {
    key: "off",
    value: function off() {
      window.dispatchEvent(this.event);
      this.pageLoaded = true;
    }
  }, {
    key: "init",
    value: function init() {
      window.scrollTo(0, 0);
      this.on();
      window.addEventListener('load', this.off());
    }
  }, {
    key: "setAnimation",
    value: function setAnimation() {
      var _this2 = this;
      this.timeline = _gsapMin.gsap.timeline({
        repeat: -1,
        onRepeat: function onRepeat() {
          _this2.hide();
        }
      });
      this.timeline.addLabel('start');
      this.timeline.to(this.animationElement, {
        scaleX: 1.5,
        duration: 2
      }, 'start');
      this.timeline.to(this.animationElement, {
        scaleX: 1,
        duration: 2
      });
      this.timeline.addLabel('loaderBackToRegularSize');
      this.timeline.to(this.animationElement, {
        rotate: -180,
        duration: 2
      }, 'loaderBackToRegularSize');
    }
  }, {
    key: "hide",
    value: function hide() {
      var _this3 = this;
      if (!this.pageLoaded) {
        return;
      }
      this.timeline.pause();
      var timeline = _gsapMin.gsap.timeline();
      timeline.then(function () {
        return _this3.container.classList.add('is-hidden');
      }).then(function () {
        return _this3.body.classList.remove('scroll-lock');
      }).then(function () {
        return _this3.off();
      });
    }
  }]);
  return Preloader;
}();
exports.Preloader = Preloader;

},{"../vendor/gsap/gsap.min.js":25}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScrollLock = void 0;
var _iosChecker = require("./ios-checker");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var ScrollLock = /*#__PURE__*/function () {
  function ScrollLock() {
    _classCallCheck(this, ScrollLock);
    this._iosChecker = _iosChecker.iosChecker;
    this._lockClass = this._iosChecker() ? 'scroll-lock-ios' : 'scroll-lock';
    this._scrollTop = null;
    this._fixedBlockElements = document.querySelectorAll('[data-fix-block]');
  }
  _createClass(ScrollLock, [{
    key: "_getScrollbarWidth",
    value: function _getScrollbarWidth() {
      return window.innerWidth - document.documentElement.clientWidth;
    }
  }, {
    key: "_getBodyScrollTop",
    value: function _getBodyScrollTop() {
      return self.pageYOffset || document.documentElement && document.documentElement.ScrollTop || document.body && document.body.scrollTop;
    }
  }, {
    key: "disableScrolling",
    value: function disableScrolling() {
      var _this = this;
      this._scrollTop = document.body.dataset.scroll = document.body.dataset.scroll ? document.body.dataset.scroll : this._getBodyScrollTop();
      if (this._getScrollbarWidth()) {
        document.body.style.paddingRight = "".concat(this._getScrollbarWidth(), "px");
        this._fixedBlockElements.forEach(function (block) {
          block.style.paddingRight = "".concat(_this._getScrollbarWidth(), "px");
        });
      }
      document.body.style.top = "-".concat(this._scrollTop, "px");
      document.body.classList.add(this._lockClass);
    }
  }, {
    key: "enableScrolling",
    value: function enableScrolling() {
      document.body.classList.remove(this._lockClass);
      window.scrollTo(0, +document.body.dataset.scroll);
      document.body.style.paddingRight = null;
      document.body.style.top = null;
      this._fixedBlockElements.forEach(function (block) {
        block.style.paddingRight = null;
      });
      document.body.removeAttribute('data-scroll');
      this._scrollTop = null;
    }
  }]);
  return ScrollLock;
}();
exports.ScrollLock = ScrollLock;
window.scrollLock = new ScrollLock();

},{"./ios-checker":15}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initStickyScroll = void 0;
var _gsapMin = require("../../vendor/gsap/gsap.min.js");
var _scrollTriggerMin = require("../../vendor/gsap/scroll-trigger.min.js");
var initStickyScroll = function initStickyScroll() {
  var stickySections = document.querySelectorAll('[data-section-animation="sticky-section"]');
  stickySections.forEach(function (stickySection) {
    var stickyImg = stickySection.querySelector('[data-block-inner="sticky-inner"]');
    var header = document.querySelector('[data-header="sticky"]');
    var headerHeight = header.offsetHeight;
    var stickyTopFixed = headerHeight * 1.12;
    _gsapMin.gsap.to(stickyImg, {
      top: stickyTopFixed
    });
    _scrollTriggerMin.ScrollTrigger.create({
      trigger: stickySection,
      start: 'top top',
      end: 'top top',
      scrub: true
    });
  });
};
exports.initStickyScroll = initStickyScroll;

},{"../../vendor/gsap/gsap.min.js":25,"../../vendor/gsap/scroll-trigger.min.js":27}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StickyHeader = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var StickyHeader = /*#__PURE__*/function () {
  function StickyHeader() {
    _classCallCheck(this, StickyHeader);
    this._stickyHeader = document.querySelector('[data-header="sticky"]');
    this._headerHeight = this._stickyHeader ? this._stickyHeader.offsetHeight : '';
    this._hidePoint = this._stickyHeader ? +this._stickyHeader.dataset.hidePoint : 0;
    this._hidePoint = this._hidePoint ? this._hidePoint : 0;
    this._themeItems = document.querySelectorAll('[data-header-theme-class]');
    this._activeTheme = null;
    this._scrollY = null;
    this._prevScrollY = null;
    this._isHidden = false;
    this._isDisableScrolling = false;
    this._onWindowScroll = this._onWindowScroll.bind(this);
    this._onLocomotiveScroll = this._onLocomotiveScroll.bind(this);
  }
  _createClass(StickyHeader, [{
    key: "init",
    value: function init() {
      if (!this._stickyHeader) {
        return;
      }
      window.addEventListener('scroll', this._onWindowScroll);
    }
  }, {
    key: "_hideHeader",
    value: function _hideHeader() {
      if (!this._isHidden) {
        this._isHidden = true;
        this._stickyHeader.classList.add('is-hidden');
      }
    }
  }, {
    key: "_showHeader",
    value: function _showHeader() {
      if (this._isHidden) {
        this._isHidden = false;
        this._stickyHeader.classList.remove('is-hidden');
      }
    }
  }, {
    key: "_checkScrollDirection",
    value: function _checkScrollDirection() {
      if (this._scrollY > this._prevScrollY) {
        return 'down';
      }
      return 'up';
    }
  }, {
    key: "_onLocomotiveScroll",
    value: function _onLocomotiveScroll(evt) {
      this._checkTheme();
      if (evt.direction === 'down' && evt.delta.y > this._hidePoint) {
        this._hideHeader();
      }
      if (evt.direction === 'up' || evt.delta.y <= this._hidePoint) {
        this._showHeader();
      }
    }
  }, {
    key: "_onWindowScroll",
    value: function _onWindowScroll() {
      this._scrollY = document.documentElement.scrollTop;
      var intro = document.querySelector('.intro');
      var header = document.querySelector('header');
      if (this._checkScrollDirection() === 'down' && this._scrollY > intro.offsetHeight - header.offsetHeight) {
        this._showHeader();
        this._stickyHeader.classList.add('header--sticky');
      }
      if (this._checkScrollDirection() === 'up' || this._scrollY <= intro.offsetHeight - header.offsetHeight) {
        this._stickyHeader.classList.remove('header--sticky');
      }
      this._prevScrollY = this._scrollY;
    }
  }, {
    key: "_checkTheme",
    value: function _checkTheme() {
      var _this = this;
      this._themeItems.forEach(function (item) {
        if (item.getBoundingClientRect().top <= 0 && item.getBoundingClientRect().height + item.getBoundingClientRect().top > 0) {
          if (_this._activeTheme === item.dataset.headerThemeClass) {
            return;
          }
          _this._stickyHeader.classList.remove(_this._activeTheme);
          _this._activeTheme = item.dataset.headerThemeClass;
          _this._stickyHeader.classList.add(_this._activeTheme);
        }
      });
    }
  }]);
  return StickyHeader;
}();
exports.StickyHeader = StickyHeader;

},{}],21:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.iosVhFix = void 0;
var _iosChecker = require("./ios-checker");
var iosVhFix = function iosVhFix() {
  if (!(!!window.MSInputMethodContext && !!document.documentMode)) {
    if ((0, _iosChecker.iosChecker)()) {
      var vh = window.innerHeight * 0.01;
      document.documentElement.style.setProperty('--vh', "".concat(vh, "px"));
      window.addEventListener('resize', function () {
        vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', "".concat(vh, "px"));
      });
    }
  }
};
exports.iosVhFix = iosVhFix;

},{"./ios-checker":21}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resizeObserver = exports.clickObserver = exports.EventObserver = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var EventObserver = /*#__PURE__*/function () {
  function EventObserver() {
    _classCallCheck(this, EventObserver);
    this.observers = [];
    this.fire = this.fire.bind(this);
  }
  _createClass(EventObserver, [{
    key: "subscribe",
    value: function subscribe(fn) {
      this.observers.push(fn);
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe(fn) {
      this.observers = this.observers.filter(function (subscriber) {
        return subscriber !== fn;
      });
    }
  }, {
    key: "fire",
    value: function fire(data) {
      this.observers.forEach(function (subscriber) {
        return subscriber(data);
      });
    }
  }]);
  return EventObserver;
}();
exports.EventObserver = EventObserver;
var resizeObserver = new EventObserver();
exports.resizeObserver = resizeObserver;
var resizeObserverProto = new ResizeObserver(function () {
  return setTimeout(function () {
    return resizeObserver.fire('resize');
  }, 10);
});
resizeObserverProto.observe(document.documentElement);
var clickObserver = new EventObserver();
exports.clickObserver = clickObserver;
window.addEventListener('click', clickObserver.fire);

},{}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pageScroller = void 0;
var vp1023 = window.matchMedia('(max-width: 1023px)');
var vpTouch = window.matchMedia('(pointer: coarse)');
var pageScroller = function pageScroller() {
  return vp1023.matches || vpTouch.matches ? '.wrapper' : 'body';
};
exports.pageScroller = pageScroller;

},{}],25:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
/*!
 * GSAP 3.12.1
 * https://greensock.com
 *
 * @license Copyright 2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */

!function (t, e) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = t || self).window = t.window || {});
}(void 0, function (e) {
  "use strict";

  function _inheritsLoose(t, e) {
    t.prototype = Object.create(e.prototype), (t.prototype.constructor = t).__proto__ = e;
  }
  function _assertThisInitialized(t) {
    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t;
  }
  function r(t) {
    return "string" == typeof t;
  }
  function s(t) {
    return "function" == typeof t;
  }
  function t(t) {
    return "number" == typeof t;
  }
  function u(t) {
    return void 0 === t;
  }
  function v(t) {
    return "object" == _typeof(t);
  }
  function w(t) {
    return !1 !== t;
  }
  function x() {
    return "undefined" != typeof window;
  }
  function y(t) {
    return s(t) || r(t);
  }
  function P(t) {
    return (i = yt(t, ot)) && Ee;
  }
  function Q(t, e) {
    return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()");
  }
  function R(t, e) {
    return !e && console.warn(t);
  }
  function S(t, e) {
    return t && (ot[t] = e) && i && (i[t] = e) || ot;
  }
  function T() {
    return 0;
  }
  function ea(t) {
    var e,
      r,
      i = t[0];
    if (v(i) || s(i) || (t = [t]), !(e = (i._gsap || {}).harness)) {
      for (r = gt.length; r-- && !gt[r].targetTest(i););
      e = gt[r];
    }
    for (r = t.length; r--;) t[r] && (t[r]._gsap || (t[r]._gsap = new Vt(t[r], e))) || t.splice(r, 1);
    return t;
  }
  function fa(t) {
    return t._gsap || ea(Ot(t))[0]._gsap;
  }
  function ga(t, e, r) {
    return (r = t[e]) && s(r) ? t[e]() : u(r) && t.getAttribute && t.getAttribute(e) || r;
  }
  function ha(t, e) {
    return (t = t.split(",")).forEach(e) || t;
  }
  function ia(t) {
    return Math.round(1e5 * t) / 1e5 || 0;
  }
  function ja(t) {
    return Math.round(1e7 * t) / 1e7 || 0;
  }
  function ka(t, e) {
    var r = e.charAt(0),
      i = parseFloat(e.substr(2));
    return t = parseFloat(t), "+" === r ? t + i : "-" === r ? t - i : "*" === r ? t * i : t / i;
  }
  function la(t, e) {
    for (var r = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < r;);
    return i < r;
  }
  function ma() {
    var t,
      e,
      r = ct.length,
      i = ct.slice(0);
    for (dt = {}, t = ct.length = 0; t < r; t++) (e = i[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0);
  }
  function na(t, e, r, i) {
    ct.length && !L && ma(), t.render(e, r, i || L && e < 0 && (t._initted || t._startAt)), ct.length && !L && ma();
  }
  function oa(t) {
    var e = parseFloat(t);
    return (e || 0 === e) && (t + "").match(at).length < 2 ? e : r(t) ? t.trim() : t;
  }
  function pa(t) {
    return t;
  }
  function qa(t, e) {
    for (var r in e) r in t || (t[r] = e[r]);
    return t;
  }
  function ta(t, e) {
    for (var r in e) "__proto__" !== r && "constructor" !== r && "prototype" !== r && (t[r] = v(e[r]) ? ta(t[r] || (t[r] = {}), e[r]) : e[r]);
    return t;
  }
  function ua(t, e) {
    var r,
      i = {};
    for (r in t) r in e || (i[r] = t[r]);
    return i;
  }
  function va(t) {
    var e = t.parent || I,
      r = t.keyframes ? function _setKeyframeDefaults(i) {
        return function (t, e) {
          for (var r in e) r in t || "duration" === r && i || "ease" === r || (t[r] = e[r]);
        };
      }($(t.keyframes)) : qa;
    if (w(t.inherit)) for (; e;) r(t, e.vars.defaults), e = e.parent || e._dp;
    return t;
  }
  function xa(t, e, r, i, n) {
    void 0 === r && (r = "_first"), void 0 === i && (i = "_last");
    var a,
      s = t[i];
    if (n) for (a = e[n]; s && s[n] > a;) s = s._prev;
    return s ? (e._next = s._next, s._next = e) : (e._next = t[r], t[r] = e), e._next ? e._next._prev = e : t[i] = e, e._prev = s, e.parent = e._dp = t, e;
  }
  function ya(t, e, r, i) {
    void 0 === r && (r = "_first"), void 0 === i && (i = "_last");
    var n = e._prev,
      a = e._next;
    n ? n._next = a : t[r] === e && (t[r] = a), a ? a._prev = n : t[i] === e && (t[i] = n), e._next = e._prev = e.parent = null;
  }
  function za(t, e) {
    t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove && t.parent.remove(t), t._act = 0;
  }
  function Aa(t, e) {
    if (t && (!e || e._end > t._dur || e._start < 0)) for (var r = t; r;) r._dirty = 1, r = r.parent;
    return t;
  }
  function Ca(t, e, r, i) {
    return t._startAt && (L ? t._startAt.revert(ht) : t.vars.immediateRender && !t.vars.autoRevert || t._startAt.render(e, !0, i));
  }
  function Ea(t) {
    return t._repeat ? Tt(t._tTime, t = t.duration() + t._rDelay) * t : 0;
  }
  function Ga(t, e) {
    return (t - e._start) * e._ts + (0 <= e._ts ? 0 : e._dirty ? e.totalDuration() : e._tDur);
  }
  function Ha(t) {
    return t._end = ja(t._start + (t._tDur / Math.abs(t._ts || t._rts || X) || 0));
  }
  function Ia(t, e) {
    var r = t._dp;
    return r && r.smoothChildTiming && t._ts && (t._start = ja(r._time - (0 < t._ts ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), Ha(t), r._dirty || Aa(r, t)), t;
  }
  function Ja(t, e) {
    var r;
    if ((e._time || e._initted && !e._dur) && (r = Ga(t.rawTime(), e), (!e._dur || kt(0, e.totalDuration(), r) - e._tTime > X) && e.render(r, !0)), Aa(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
      if (t._dur < t.duration()) for (r = t; r._dp;) 0 <= r.rawTime() && r.totalTime(r._tTime), r = r._dp;
      t._zTime = -X;
    }
  }
  function Ka(e, r, i, n) {
    return r.parent && za(r), r._start = ja((t(i) ? i : i || e !== I ? xt(e, i, r) : e._time) + r._delay), r._end = ja(r._start + (r.totalDuration() / Math.abs(r.timeScale()) || 0)), xa(e, r, "_first", "_last", e._sort ? "_start" : 0), bt(r) || (e._recent = r), n || Ja(e, r), e._ts < 0 && Ia(e, e._tTime), e;
  }
  function La(t, e) {
    return (ot.ScrollTrigger || Q("scrollTrigger", e)) && ot.ScrollTrigger.create(e, t);
  }
  function Ma(t, e, r, i, n) {
    return Gt(t, e, n), t._initted ? !r && t._pt && !L && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && f !== Rt.frame ? (ct.push(t), t._lazy = [n, i], 1) : void 0 : 1;
  }
  function Ra(t, e, r, i) {
    var n = t._repeat,
      a = ja(e) || 0,
      s = t._tTime / t._tDur;
    return s && !i && (t._time *= a / t._dur), t._dur = a, t._tDur = n ? n < 0 ? 1e10 : ja(a * (n + 1) + t._rDelay * n) : a, 0 < s && !i && Ia(t, t._tTime = t._tDur * s), t.parent && Ha(t), r || Aa(t.parent, t), t;
  }
  function Sa(t) {
    return t instanceof Xt ? Aa(t) : Ra(t, t._dur);
  }
  function Va(e, r, i) {
    var n,
      a,
      s = t(r[1]),
      o = (s ? 2 : 1) + (e < 2 ? 0 : 1),
      u = r[o];
    if (s && (u.duration = r[1]), u.parent = i, e) {
      for (n = u, a = i; a && !("immediateRender" in n);) n = a.vars.defaults || {}, a = w(a.vars.inherit) && a.parent;
      u.immediateRender = w(n.immediateRender), e < 2 ? u.runBackwards = 1 : u.startAt = r[o - 1];
    }
    return new Zt(r[0], u, r[1 + o]);
  }
  function Wa(t, e) {
    return t || 0 === t ? e(t) : e;
  }
  function Ya(t, e) {
    return r(t) && (e = st.exec(t)) ? e[1] : "";
  }
  function _a(t, e) {
    return t && v(t) && "length" in t && (!e && !t.length || t.length - 1 in t && v(t[0])) && !t.nodeType && t !== h;
  }
  function cb(r) {
    return r = Ot(r)[0] || R("Invalid scope") || {}, function (t) {
      var e = r.current || r.nativeElement || r;
      return Ot(t, e.querySelectorAll ? e : e === r ? R("Invalid scope") || a.createElement("div") : r);
    };
  }
  function db(t) {
    return t.sort(function () {
      return .5 - Math.random();
    });
  }
  function eb(t) {
    if (s(t)) return t;
    var p = v(t) ? t : {
        each: t
      },
      _ = jt(p.ease),
      m = p.from || 0,
      g = parseFloat(p.base) || 0,
      y = {},
      e = 0 < m && m < 1,
      T = isNaN(m) || e,
      b = p.axis,
      w = m,
      x = m;
    return r(m) ? w = x = {
      center: .5,
      edges: .5,
      end: 1
    }[m] || 0 : !e && T && (w = m[0], x = m[1]), function (t, e, r) {
      var i,
        n,
        a,
        s,
        o,
        u,
        h,
        l,
        f,
        c = (r || p).length,
        d = y[c];
      if (!d) {
        if (!(f = "auto" === p.grid ? 0 : (p.grid || [1, U])[1])) {
          for (h = -U; h < (h = r[f++].getBoundingClientRect().left) && f < c;);
          f--;
        }
        for (d = y[c] = [], i = T ? Math.min(f, c) * w - .5 : m % f, n = f === U ? 0 : T ? c * x / f - .5 : m / f | 0, l = U, u = h = 0; u < c; u++) a = u % f - i, s = n - (u / f | 0), d[u] = o = b ? Math.abs("y" === b ? s : a) : K(a * a + s * s), h < o && (h = o), o < l && (l = o);
        "random" === m && db(d), d.max = h - l, d.min = l, d.v = c = (parseFloat(p.amount) || parseFloat(p.each) * (c < f ? c - 1 : b ? "y" === b ? c / f : f : Math.max(f, c / f)) || 0) * ("edges" === m ? -1 : 1), d.b = c < 0 ? g - c : g, d.u = Ya(p.amount || p.each) || 0, _ = _ && c < 0 ? Yt(_) : _;
      }
      return c = (d[t] - d.min) / d.max || 0, ja(d.b + (_ ? _(c) : c) * d.v) + d.u;
    };
  }
  function fb(i) {
    var n = Math.pow(10, ((i + "").split(".")[1] || "").length);
    return function (e) {
      var r = ja(Math.round(parseFloat(e) / i) * i * n);
      return (r - r % 1) / n + (t(e) ? 0 : Ya(e));
    };
  }
  function gb(h, e) {
    var l,
      f,
      r = $(h);
    return !r && v(h) && (l = r = h.radius || U, h.values ? (h = Ot(h.values), (f = !t(h[0])) && (l *= l)) : h = fb(h.increment)), Wa(e, r ? s(h) ? function (t) {
      return f = h(t), Math.abs(f - t) <= l ? f : t;
    } : function (e) {
      for (var r, i, n = parseFloat(f ? e.x : e), a = parseFloat(f ? e.y : 0), s = U, o = 0, u = h.length; u--;) (r = f ? (r = h[u].x - n) * r + (i = h[u].y - a) * i : Math.abs(h[u] - n)) < s && (s = r, o = u);
      return o = !l || s <= l ? h[o] : e, f || o === e || t(e) ? o : o + Ya(e);
    } : fb(h));
  }
  function hb(t, e, r, i) {
    return Wa($(t) ? !e : !0 === r ? !!(r = 0) : !i, function () {
      return $(t) ? t[~~(Math.random() * t.length)] : (r = r || 1e-5) && (i = r < 1 ? Math.pow(10, (r + "").length - 2) : 1) && Math.floor(Math.round((t - r / 2 + Math.random() * (e - t + .99 * r)) / r) * r * i) / i;
    });
  }
  function lb(e, r, t) {
    return Wa(t, function (t) {
      return e[~~r(t)];
    });
  }
  function ob(t) {
    for (var e, r, i, n, a = 0, s = ""; ~(e = t.indexOf("random(", a));) i = t.indexOf(")", e), n = "[" === t.charAt(e + 7), r = t.substr(e + 7, i - e - 7).match(n ? at : tt), s += t.substr(a, e - a) + hb(n ? r : +r[0], n ? 0 : +r[1], +r[2] || 1e-5), a = i + 1;
    return s + t.substr(a, t.length - a);
  }
  function rb(t, e, r) {
    var i,
      n,
      a,
      s = t.labels,
      o = U;
    for (i in s) (n = s[i] - e) < 0 == !!r && n && o > (n = Math.abs(n)) && (a = i, o = n);
    return a;
  }
  function tb(t) {
    return za(t), t.scrollTrigger && t.scrollTrigger.kill(!!L), t.progress() < 1 && At(t, "onInterrupt"), t;
  }
  function wb(t) {
    if (x() && t) {
      var e = (t = !t.name && t.default || t).name,
        r = s(t),
        i = e && !r && t.init ? function () {
          this._props = [];
        } : t,
        n = {
          init: T,
          render: he,
          add: Qt,
          kill: ce,
          modifier: fe,
          rawVars: 0
        },
        a = {
          targetTest: 0,
          get: 0,
          getSetter: ne,
          aliases: {},
          register: 0
        };
      if (Ft(), t !== i) {
        if (pt[e]) return;
        qa(i, qa(ua(t, n), a)), yt(i.prototype, yt(n, ua(t, a))), pt[i.prop = e] = i, t.targetTest && (gt.push(i), ft[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin";
      }
      S(e, i), t.register && t.register(Ee, i, _e);
    } else t && Ct.push(t);
  }
  function zb(t, e, r) {
    return (6 * (t += t < 0 ? 1 : 1 < t ? -1 : 0) < 1 ? e + (r - e) * t * 6 : t < .5 ? r : 3 * t < 2 ? e + (r - e) * (2 / 3 - t) * 6 : e) * St + .5 | 0;
  }
  function Ab(e, r, i) {
    var n,
      a,
      s,
      o,
      u,
      h,
      l,
      f,
      c,
      d,
      p = e ? t(e) ? [e >> 16, e >> 8 & St, e & St] : 0 : Et.black;
    if (!p) {
      if ("," === e.substr(-1) && (e = e.substr(0, e.length - 1)), Et[e]) p = Et[e];else if ("#" === e.charAt(0)) {
        if (e.length < 6 && (e = "#" + (n = e.charAt(1)) + n + (a = e.charAt(2)) + a + (s = e.charAt(3)) + s + (5 === e.length ? e.charAt(4) + e.charAt(4) : "")), 9 === e.length) return [(p = parseInt(e.substr(1, 6), 16)) >> 16, p >> 8 & St, p & St, parseInt(e.substr(7), 16) / 255];
        p = [(e = parseInt(e.substr(1), 16)) >> 16, e >> 8 & St, e & St];
      } else if ("hsl" === e.substr(0, 3)) {
        if (p = d = e.match(tt), r) {
          if (~e.indexOf("=")) return p = e.match(et), i && p.length < 4 && (p[3] = 1), p;
        } else o = +p[0] % 360 / 360, u = p[1] / 100, n = 2 * (h = p[2] / 100) - (a = h <= .5 ? h * (u + 1) : h + u - h * u), 3 < p.length && (p[3] *= 1), p[0] = zb(o + 1 / 3, n, a), p[1] = zb(o, n, a), p[2] = zb(o - 1 / 3, n, a);
      } else p = e.match(tt) || Et.transparent;
      p = p.map(Number);
    }
    return r && !d && (n = p[0] / St, a = p[1] / St, s = p[2] / St, h = ((l = Math.max(n, a, s)) + (f = Math.min(n, a, s))) / 2, l === f ? o = u = 0 : (c = l - f, u = .5 < h ? c / (2 - l - f) : c / (l + f), o = l === n ? (a - s) / c + (a < s ? 6 : 0) : l === a ? (s - n) / c + 2 : (n - a) / c + 4, o *= 60), p[0] = ~~(o + .5), p[1] = ~~(100 * u + .5), p[2] = ~~(100 * h + .5)), i && p.length < 4 && (p[3] = 1), p;
  }
  function Bb(t) {
    var r = [],
      i = [],
      n = -1;
    return t.split(Dt).forEach(function (t) {
      var e = t.match(rt) || [];
      r.push.apply(r, e), i.push(n += e.length + 1);
    }), r.c = i, r;
  }
  function Cb(t, e, r) {
    var i,
      n,
      a,
      s,
      o = "",
      u = (t + o).match(Dt),
      h = e ? "hsla(" : "rgba(",
      l = 0;
    if (!u) return t;
    if (u = u.map(function (t) {
      return (t = Ab(t, e, 1)) && h + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")";
    }), r && (a = Bb(t), (i = r.c).join(o) !== a.c.join(o))) for (s = (n = t.replace(Dt, "1").split(rt)).length - 1; l < s; l++) o += n[l] + (~i.indexOf(l) ? u.shift() || h + "0,0,0,0)" : (a.length ? a : u.length ? u : r).shift());
    if (!n) for (s = (n = t.split(Dt)).length - 1; l < s; l++) o += n[l] + u[l];
    return o + n[s];
  }
  function Fb(t) {
    var e,
      r = t.join(" ");
    if (Dt.lastIndex = 0, Dt.test(r)) return e = zt.test(r), t[1] = Cb(t[1], e), t[0] = Cb(t[0], e, Bb(t[1])), !0;
  }
  function Ob(t) {
    var e = (t + "").split("("),
      r = Bt[e[0]];
    return r && 1 < e.length && r.config ? r.config.apply(null, ~t.indexOf("{") ? [function _parseObjectInString(t) {
      for (var e, r, i, n = {}, a = t.substr(1, t.length - 3).split(":"), s = a[0], o = 1, u = a.length; o < u; o++) r = a[o], e = o !== u - 1 ? r.lastIndexOf(",") : r.length, i = r.substr(0, e), n[s] = isNaN(i) ? i.replace(It, "").trim() : +i, s = r.substr(e + 1).trim();
      return n;
    }(e[1])] : function _valueInParentheses(t) {
      var e = t.indexOf("(") + 1,
        r = t.indexOf(")"),
        i = t.indexOf("(", e);
      return t.substring(e, ~i && i < r ? t.indexOf(")", r + 1) : r);
    }(t).split(",").map(oa)) : Bt._CE && Lt.test(t) ? Bt._CE("", t) : r;
  }
  function Qb(t, e) {
    for (var r, i = t._first; i;) i instanceof Xt ? Qb(i, e) : !i.vars.yoyoEase || i._yoyo && i._repeat || i._yoyo === e || (i.timeline ? Qb(i.timeline, e) : (r = i._ease, i._ease = i._yEase, i._yEase = r, i._yoyo = e)), i = i._next;
  }
  function Sb(t, e, r, i) {
    void 0 === r && (r = function easeOut(t) {
      return 1 - e(1 - t);
    }), void 0 === i && (i = function easeInOut(t) {
      return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2;
    });
    var n,
      a = {
        easeIn: e,
        easeOut: r,
        easeInOut: i
      };
    return ha(t, function (t) {
      for (var e in Bt[t] = ot[t] = a, Bt[n = t.toLowerCase()] = r, a) Bt[n + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = Bt[t + "." + e] = a[e];
    }), a;
  }
  function Tb(e) {
    return function (t) {
      return t < .5 ? (1 - e(1 - 2 * t)) / 2 : .5 + e(2 * (t - .5)) / 2;
    };
  }
  function Ub(r, t, e) {
    function Jm(t) {
      return 1 === t ? 1 : i * Math.pow(2, -10 * t) * H((t - a) * n) + 1;
    }
    var i = 1 <= t ? t : 1,
      n = (e || (r ? .3 : .45)) / (t < 1 ? t : 1),
      a = n / N * (Math.asin(1 / i) || 0),
      s = "out" === r ? Jm : "in" === r ? function (t) {
        return 1 - Jm(1 - t);
      } : Tb(Jm);
    return n = N / n, s.config = function (t, e) {
      return Ub(r, t, e);
    }, s;
  }
  function Vb(e, r) {
    function Rm(t) {
      return t ? --t * t * ((r + 1) * t + r) + 1 : 0;
    }
    void 0 === r && (r = 1.70158);
    var t = "out" === e ? Rm : "in" === e ? function (t) {
      return 1 - Rm(1 - t);
    } : Tb(Rm);
    return t.config = function (t) {
      return Vb(e, t);
    }, t;
  }
  var B,
    L,
    l,
    I,
    h,
    n,
    a,
    i,
    o,
    f,
    c,
    d,
    p,
    _,
    m,
    g,
    b,
    k,
    M,
    O,
    A,
    C,
    E,
    D,
    z,
    F,
    Y,
    j,
    q = {
      autoSleep: 120,
      force3D: "auto",
      nullTargetWarn: 1,
      units: {
        lineHeight: ""
      }
    },
    V = {
      duration: .5,
      overwrite: !1,
      delay: 0
    },
    U = 1e8,
    X = 1 / U,
    N = 2 * Math.PI,
    W = N / 4,
    G = 0,
    K = Math.sqrt,
    J = Math.cos,
    H = Math.sin,
    Z = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function () {},
    $ = Array.isArray,
    tt = /(?:-?\.?\d|\.)+/gi,
    et = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    rt = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    it = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
    nt = /[+-]=-?[.\d]+/,
    at = /[^,'"\[\]\s]+/gi,
    st = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
    ot = {},
    ut = {
      suppressEvents: !0,
      isStart: !0,
      kill: !1
    },
    ht = {
      suppressEvents: !0,
      kill: !1
    },
    lt = {
      suppressEvents: !0
    },
    ft = {},
    ct = [],
    dt = {},
    pt = {},
    _t = {},
    mt = 30,
    gt = [],
    vt = "",
    yt = function _merge(t, e) {
      for (var r in e) t[r] = e[r];
      return t;
    },
    Tt = function _animationCycle(t, e) {
      var r = Math.floor(t /= e);
      return t && r === t ? r - 1 : r;
    },
    bt = function _isFromOrFromStart(t) {
      var e = t.data;
      return "isFromStart" === e || "isStart" === e;
    },
    wt = {
      _start: 0,
      endTime: T,
      totalDuration: T
    },
    xt = function _parsePosition(t, e, i) {
      var n,
        a,
        s,
        o = t.labels,
        u = t._recent || wt,
        h = t.duration() >= U ? u.endTime(!1) : t._dur;
      return r(e) && (isNaN(e) || e in o) ? (a = e.charAt(0), s = "%" === e.substr(-1), n = e.indexOf("="), "<" === a || ">" === a ? (0 <= n && (e = e.replace(/=/, "")), ("<" === a ? u._start : u.endTime(0 <= u._repeat)) + (parseFloat(e.substr(1)) || 0) * (s ? (n < 0 ? u : i).totalDuration() / 100 : 1)) : n < 0 ? (e in o || (o[e] = h), o[e]) : (a = parseFloat(e.charAt(n - 1) + e.substr(n + 1)), s && i && (a = a / 100 * ($(i) ? i[0] : i).totalDuration()), 1 < n ? _parsePosition(t, e.substr(0, n - 1), i) + a : h + a)) : null == e ? h : +e;
    },
    kt = function _clamp(t, e, r) {
      return r < t ? t : e < r ? e : r;
    },
    Mt = [].slice,
    Ot = function toArray(t, e, i) {
      return l && !e && l.selector ? l.selector(t) : !r(t) || i || !n && Ft() ? $(t) ? function _flatten(t, e, i) {
        return void 0 === i && (i = []), t.forEach(function (t) {
          return r(t) && !e || _a(t, 1) ? i.push.apply(i, Ot(t)) : i.push(t);
        }) || i;
      }(t, i) : _a(t) ? Mt.call(t, 0) : t ? [t] : [] : Mt.call((e || a).querySelectorAll(t), 0);
    },
    Pt = function mapRange(e, t, r, i, n) {
      var a = t - e,
        s = i - r;
      return Wa(n, function (t) {
        return r + ((t - e) / a * s || 0);
      });
    },
    At = function _callback(t, e, r) {
      var i,
        n,
        a,
        s = t.vars,
        o = s[e],
        u = l,
        h = t._ctx;
      if (o) return i = s[e + "Params"], n = s.callbackScope || t, r && ct.length && ma(), h && (l = h), a = i ? o.apply(n, i) : o.call(n), l = u, a;
    },
    Ct = [],
    St = 255,
    Et = {
      aqua: [0, St, St],
      lime: [0, St, 0],
      silver: [192, 192, 192],
      black: [0, 0, 0],
      maroon: [128, 0, 0],
      teal: [0, 128, 128],
      blue: [0, 0, St],
      navy: [0, 0, 128],
      white: [St, St, St],
      olive: [128, 128, 0],
      yellow: [St, St, 0],
      orange: [St, 165, 0],
      gray: [128, 128, 128],
      purple: [128, 0, 128],
      green: [0, 128, 0],
      red: [St, 0, 0],
      pink: [St, 192, 203],
      cyan: [0, St, St],
      transparent: [St, St, St, 0]
    },
    Dt = function () {
      var t,
        e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
      for (t in Et) e += "|" + t + "\\b";
      return new RegExp(e + ")", "gi");
    }(),
    zt = /hsl[a]?\(/,
    Rt = (M = Date.now, O = 500, A = 33, C = M(), E = C, z = D = 1e3 / 240, g = {
      time: 0,
      frame: 0,
      tick: function tick() {
        yl(!0);
      },
      deltaRatio: function deltaRatio(t) {
        return b / (1e3 / (t || 60));
      },
      wake: function wake() {
        o && (!n && x() && (h = n = window, a = h.document || {}, ot.gsap = Ee, (h.gsapVersions || (h.gsapVersions = [])).push(Ee.version), P(i || h.GreenSockGlobals || !h.gsap && h || {}), m = h.requestAnimationFrame, Ct.forEach(wb)), p && g.sleep(), _ = m || function (t) {
          return setTimeout(t, z - 1e3 * g.time + 1 | 0);
        }, d = 1, yl(2));
      },
      sleep: function sleep() {
        (m ? h.cancelAnimationFrame : clearTimeout)(p), d = 0, _ = T;
      },
      lagSmoothing: function lagSmoothing(t, e) {
        O = t || 1 / 0, A = Math.min(e || 33, O);
      },
      fps: function fps(t) {
        D = 1e3 / (t || 240), z = 1e3 * g.time + D;
      },
      add: function add(n, t, e) {
        var a = t ? function (t, e, r, i) {
          n(t, e, r, i), g.remove(a);
        } : n;
        return g.remove(n), F[e ? "unshift" : "push"](a), Ft(), a;
      },
      remove: function remove(t, e) {
        ~(e = F.indexOf(t)) && F.splice(e, 1) && e <= k && k--;
      },
      _listeners: F = []
    }),
    Ft = function _wake() {
      return !d && Rt.wake();
    },
    Bt = {},
    Lt = /^[\d.\-M][\d.\-,\s]/,
    It = /["']/g,
    Yt = function _invertEase(e) {
      return function (t) {
        return 1 - e(1 - t);
      };
    },
    jt = function _parseEase(t, e) {
      return t && (s(t) ? t : Bt[t] || Ob(t)) || e;
    };
  function yl(t) {
    var e,
      r,
      i,
      n,
      a = M() - E,
      s = !0 === t;
    if (O < a && (C += a - A), (0 < (e = (i = (E += a) - C) - z) || s) && (n = ++g.frame, b = i - 1e3 * g.time, g.time = i /= 1e3, z += e + (D <= e ? 4 : D - e), r = 1), s || (p = _(yl)), r) for (k = 0; k < F.length; k++) F[k](i, b, n, t);
  }
  function gn(t) {
    return t < j ? Y * t * t : t < .7272727272727273 ? Y * Math.pow(t - 1.5 / 2.75, 2) + .75 : t < .9090909090909092 ? Y * (t -= 2.25 / 2.75) * t + .9375 : Y * Math.pow(t - 2.625 / 2.75, 2) + .984375;
  }
  ha("Linear,Quad,Cubic,Quart,Quint,Strong", function (t, e) {
    var r = e < 5 ? e + 1 : e;
    Sb(t + ",Power" + (r - 1), e ? function (t) {
      return Math.pow(t, r);
    } : function (t) {
      return t;
    }, function (t) {
      return 1 - Math.pow(1 - t, r);
    }, function (t) {
      return t < .5 ? Math.pow(2 * t, r) / 2 : 1 - Math.pow(2 * (1 - t), r) / 2;
    });
  }), Bt.Linear.easeNone = Bt.none = Bt.Linear.easeIn, Sb("Elastic", Ub("in"), Ub("out"), Ub()), Y = 7.5625, j = 1 / 2.75, Sb("Bounce", function (t) {
    return 1 - gn(1 - t);
  }, gn), Sb("Expo", function (t) {
    return t ? Math.pow(2, 10 * (t - 1)) : 0;
  }), Sb("Circ", function (t) {
    return -(K(1 - t * t) - 1);
  }), Sb("Sine", function (t) {
    return 1 === t ? 1 : 1 - J(t * W);
  }), Sb("Back", Vb("in"), Vb("out"), Vb()), Bt.SteppedEase = Bt.steps = ot.SteppedEase = {
    config: function config(t, e) {
      void 0 === t && (t = 1);
      var r = 1 / t,
        i = t + (e ? 0 : 1),
        n = e ? 1 : 0;
      return function (t) {
        return ((i * kt(0, .99999999, t) | 0) + n) * r;
      };
    }
  }, V.ease = Bt["quad.out"], ha("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (t) {
    return vt += t + "," + t + "Params,";
  });
  var qt,
    Vt = function GSCache(t, e) {
      this.id = G++, (t._gsap = this).target = t, this.harness = e, this.get = e ? e.get : ga, this.set = e ? e.getSetter : ne;
    },
    Ut = ((qt = Animation.prototype).delay = function delay(t) {
      return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay;
    }, qt.duration = function duration(t) {
      return arguments.length ? this.totalDuration(0 < this._repeat ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur;
    }, qt.totalDuration = function totalDuration(t) {
      return arguments.length ? (this._dirty = 0, Ra(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur;
    }, qt.totalTime = function totalTime(t, e) {
      if (Ft(), !arguments.length) return this._tTime;
      var r = this._dp;
      if (r && r.smoothChildTiming && this._ts) {
        for (Ia(this, t), !r._dp || r.parent || Ja(r, this); r && r.parent;) r.parent._time !== r._start + (0 <= r._ts ? r._tTime / r._ts : (r.totalDuration() - r._tTime) / -r._ts) && r.totalTime(r._tTime, !0), r = r.parent;
        !this.parent && this._dp.autoRemoveChildren && (0 < this._ts && t < this._tDur || this._ts < 0 && 0 < t || !this._tDur && !t) && Ka(this._dp, this, this._start - this._delay);
      }
      return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === X || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), na(this, t, e)), this;
    }, qt.time = function time(t, e) {
      return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + Ea(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), e) : this._time;
    }, qt.totalProgress = function totalProgress(t, e) {
      return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
    }, qt.progress = function progress(t, e) {
      return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + Ea(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
    }, qt.iteration = function iteration(t, e) {
      var r = this.duration() + this._rDelay;
      return arguments.length ? this.totalTime(this._time + (t - 1) * r, e) : this._repeat ? Tt(this._tTime, r) + 1 : 1;
    }, qt.timeScale = function timeScale(t) {
      if (!arguments.length) return this._rts === -X ? 0 : this._rts;
      if (this._rts === t) return this;
      var e = this.parent && this._ts ? Ga(this.parent._time, this) : this._tTime;
      return this._rts = +t || 0, this._ts = this._ps || t === -X ? 0 : this._rts, this.totalTime(kt(-Math.abs(this._delay), this._tDur, e), !0), Ha(this), function _recacheAncestors(t) {
        for (var e = t.parent; e && e.parent;) e._dirty = 1, e.totalDuration(), e = e.parent;
        return t;
      }(this);
    }, qt.paused = function paused(t) {
      return arguments.length ? (this._ps !== t && ((this._ps = t) ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Ft(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== X && (this._tTime -= X)))), this) : this._ps;
    }, qt.startTime = function startTime(t) {
      if (arguments.length) {
        this._start = t;
        var e = this.parent || this._dp;
        return !e || !e._sort && this.parent || Ka(e, this, t - this._delay), this;
      }
      return this._start;
    }, qt.endTime = function endTime(t) {
      return this._start + (w(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
    }, qt.rawTime = function rawTime(t) {
      var e = this.parent || this._dp;
      return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Ga(e.rawTime(t), this) : this._tTime : this._tTime;
    }, qt.revert = function revert(t) {
      void 0 === t && (t = lt);
      var e = L;
      return L = t, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(t), this.totalTime(-.01, t.suppressEvents)), "nested" !== this.data && !1 !== t.kill && this.kill(), L = e, this;
    }, qt.globalTime = function globalTime(t) {
      for (var e = this, r = arguments.length ? t : e.rawTime(); e;) r = e._start + r / (e._ts || 1), e = e._dp;
      return !this.parent && this._sat ? this._sat.vars.immediateRender ? -1 : this._sat.globalTime(t) : r;
    }, qt.repeat = function repeat(t) {
      return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t, Sa(this)) : -2 === this._repeat ? 1 / 0 : this._repeat;
    }, qt.repeatDelay = function repeatDelay(t) {
      if (arguments.length) {
        var e = this._time;
        return this._rDelay = t, Sa(this), e ? this.time(e) : this;
      }
      return this._rDelay;
    }, qt.yoyo = function yoyo(t) {
      return arguments.length ? (this._yoyo = t, this) : this._yoyo;
    }, qt.seek = function seek(t, e) {
      return this.totalTime(xt(this, t), w(e));
    }, qt.restart = function restart(t, e) {
      return this.play().totalTime(t ? -this._delay : 0, w(e));
    }, qt.play = function play(t, e) {
      return null != t && this.seek(t, e), this.reversed(!1).paused(!1);
    }, qt.reverse = function reverse(t, e) {
      return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1);
    }, qt.pause = function pause(t, e) {
      return null != t && this.seek(t, e), this.paused(!0);
    }, qt.resume = function resume() {
      return this.paused(!1);
    }, qt.reversed = function reversed(t) {
      return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -X : 0)), this) : this._rts < 0;
    }, qt.invalidate = function invalidate() {
      return this._initted = this._act = 0, this._zTime = -X, this;
    }, qt.isActive = function isActive() {
      var t,
        e = this.parent || this._dp,
        r = this._start;
      return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= r && t < this.endTime(!0) - X));
    }, qt.eventCallback = function eventCallback(t, e, r) {
      var i = this.vars;
      return 1 < arguments.length ? (e ? (i[t] = e, r && (i[t + "Params"] = r), "onUpdate" === t && (this._onUpdate = e)) : delete i[t], this) : i[t];
    }, qt.then = function then(t) {
      var i = this;
      return new Promise(function (e) {
        function Bo() {
          var t = i.then;
          i.then = null, s(r) && (r = r(i)) && (r.then || r === i) && (i.then = t), e(r), i.then = t;
        }
        var r = s(t) ? t : pa;
        i._initted && 1 === i.totalProgress() && 0 <= i._ts || !i._tTime && i._ts < 0 ? Bo() : i._prom = Bo;
      });
    }, qt.kill = function kill() {
      tb(this);
    }, Animation);
  function Animation(t) {
    this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Ra(this, +t.duration, 1, 1), this.data = t.data, l && (this._ctx = l).data.push(this), d || Rt.wake();
  }
  qa(Ut.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -X,
    _prom: 0,
    _ps: !1,
    _rts: 1
  });
  var Xt = function (i) {
    function Timeline(t, e) {
      var r;
      return void 0 === t && (t = {}), (r = i.call(this, t) || this).labels = {}, r.smoothChildTiming = !!t.smoothChildTiming, r.autoRemoveChildren = !!t.autoRemoveChildren, r._sort = w(t.sortChildren), I && Ka(t.parent || I, _assertThisInitialized(r), e), t.reversed && r.reverse(), t.paused && r.paused(!0), t.scrollTrigger && La(_assertThisInitialized(r), t.scrollTrigger), r;
    }
    _inheritsLoose(Timeline, i);
    var e = Timeline.prototype;
    return e.to = function to(t, e, r) {
      return Va(0, arguments, this), this;
    }, e.from = function from(t, e, r) {
      return Va(1, arguments, this), this;
    }, e.fromTo = function fromTo(t, e, r, i) {
      return Va(2, arguments, this), this;
    }, e.set = function set(t, e, r) {
      return e.duration = 0, e.parent = this, va(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new Zt(t, e, xt(this, r), 1), this;
    }, e.call = function call(t, e, r) {
      return Ka(this, Zt.delayedCall(0, t, e), r);
    }, e.staggerTo = function staggerTo(t, e, r, i, n, a, s) {
      return r.duration = e, r.stagger = r.stagger || i, r.onComplete = a, r.onCompleteParams = s, r.parent = this, new Zt(t, r, xt(this, n)), this;
    }, e.staggerFrom = function staggerFrom(t, e, r, i, n, a, s) {
      return r.runBackwards = 1, va(r).immediateRender = w(r.immediateRender), this.staggerTo(t, e, r, i, n, a, s);
    }, e.staggerFromTo = function staggerFromTo(t, e, r, i, n, a, s, o) {
      return i.startAt = r, va(i).immediateRender = w(i.immediateRender), this.staggerTo(t, e, i, n, a, s, o);
    }, e.render = function render(t, e, r) {
      var i,
        n,
        a,
        s,
        o,
        u,
        h,
        l,
        f,
        c,
        d,
        p,
        _ = this._time,
        m = this._dirty ? this.totalDuration() : this._tDur,
        g = this._dur,
        v = t <= 0 ? 0 : ja(t),
        y = this._zTime < 0 != t < 0 && (this._initted || !g);
      if (this !== I && m < v && 0 <= t && (v = m), v !== this._tTime || r || y) {
        if (_ !== this._time && g && (v += this._time - _, t += this._time - _), i = v, f = this._start, u = !(l = this._ts), y && (g || (_ = this._zTime), !t && e || (this._zTime = t)), this._repeat) {
          if (d = this._yoyo, o = g + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * o + t, e, r);
          if (i = ja(v % o), v === m ? (s = this._repeat, i = g) : ((s = ~~(v / o)) && s === v / o && (i = g, s--), g < i && (i = g)), c = Tt(this._tTime, o), !_ && this._tTime && c !== s && this._tTime - c * o - this._dur <= 0 && (c = s), d && 1 & s && (i = g - i, p = 1), s !== c && !this._lock) {
            var T = d && 1 & c,
              b = T === (d && 1 & s);
            if (s < c && (T = !T), _ = T ? 0 : g, this._lock = 1, this.render(_ || (p ? 0 : ja(s * o)), e, !g)._lock = 0, this._tTime = v, !e && this.parent && At(this, "onRepeat"), this.vars.repeatRefresh && !p && (this.invalidate()._lock = 1), _ && _ !== this._time || u != !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
            if (g = this._dur, m = this._tDur, b && (this._lock = 2, _ = T ? g : -1e-4, this.render(_, !0), this.vars.repeatRefresh && !p && this.invalidate()), this._lock = 0, !this._ts && !u) return this;
            Qb(this, p);
          }
        }
        if (this._hasPause && !this._forcing && this._lock < 2 && (h = function _findNextPauseTween(t, e, r) {
          var i;
          if (e < r) for (i = t._first; i && i._start <= r;) {
            if ("isPause" === i.data && i._start > e) return i;
            i = i._next;
          } else for (i = t._last; i && i._start >= r;) {
            if ("isPause" === i.data && i._start < e) return i;
            i = i._prev;
          }
        }(this, ja(_), ja(i))) && (v -= i - (i = h._start)), this._tTime = v, this._time = i, this._act = !l, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t, _ = 0), !_ && i && !e && !s && (At(this, "onStart"), this._tTime !== v)) return this;
        if (_ <= i && 0 <= t) for (n = this._first; n;) {
          if (a = n._next, (n._act || i >= n._start) && n._ts && h !== n) {
            if (n.parent !== this) return this.render(t, e, r);
            if (n.render(0 < n._ts ? (i - n._start) * n._ts : (n._dirty ? n.totalDuration() : n._tDur) + (i - n._start) * n._ts, e, r), i !== this._time || !this._ts && !u) {
              h = 0, a && (v += this._zTime = -X);
              break;
            }
          }
          n = a;
        } else {
          n = this._last;
          for (var w = t < 0 ? t : i; n;) {
            if (a = n._prev, (n._act || w <= n._end) && n._ts && h !== n) {
              if (n.parent !== this) return this.render(t, e, r);
              if (n.render(0 < n._ts ? (w - n._start) * n._ts : (n._dirty ? n.totalDuration() : n._tDur) + (w - n._start) * n._ts, e, r || L && (n._initted || n._startAt)), i !== this._time || !this._ts && !u) {
                h = 0, a && (v += this._zTime = w ? -X : X);
                break;
              }
            }
            n = a;
          }
        }
        if (h && !e && (this.pause(), h.render(_ <= i ? 0 : -X)._zTime = _ <= i ? 1 : -1, this._ts)) return this._start = f, Ha(this), this.render(t, e, r);
        this._onUpdate && !e && At(this, "onUpdate", !0), (v === m && this._tTime >= this.totalDuration() || !v && _) && (f !== this._start && Math.abs(l) === Math.abs(this._ts) || this._lock || (!t && g || !(v === m && 0 < this._ts || !v && this._ts < 0) || za(this, 1), e || t < 0 && !_ || !v && !_ && m || (At(this, v === m && 0 <= t ? "onComplete" : "onReverseComplete", !0), !this._prom || v < m && 0 < this.timeScale() || this._prom())));
      }
      return this;
    }, e.add = function add(e, i) {
      var n = this;
      if (t(i) || (i = xt(this, i, e)), !(e instanceof Ut)) {
        if ($(e)) return e.forEach(function (t) {
          return n.add(t, i);
        }), this;
        if (r(e)) return this.addLabel(e, i);
        if (!s(e)) return this;
        e = Zt.delayedCall(0, e);
      }
      return this !== e ? Ka(this, e, i) : this;
    }, e.getChildren = function getChildren(t, e, r, i) {
      void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === r && (r = !0), void 0 === i && (i = -U);
      for (var n = [], a = this._first; a;) a._start >= i && (a instanceof Zt ? e && n.push(a) : (r && n.push(a), t && n.push.apply(n, a.getChildren(!0, e, r)))), a = a._next;
      return n;
    }, e.getById = function getById(t) {
      for (var e = this.getChildren(1, 1, 1), r = e.length; r--;) if (e[r].vars.id === t) return e[r];
    }, e.remove = function remove(t) {
      return r(t) ? this.removeLabel(t) : s(t) ? this.killTweensOf(t) : (ya(this, t), t === this._recent && (this._recent = this._last), Aa(this));
    }, e.totalTime = function totalTime(t, e) {
      return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = ja(Rt.time - (0 < this._ts ? t / this._ts : (this.totalDuration() - t) / -this._ts))), i.prototype.totalTime.call(this, t, e), this._forcing = 0, this) : this._tTime;
    }, e.addLabel = function addLabel(t, e) {
      return this.labels[t] = xt(this, e), this;
    }, e.removeLabel = function removeLabel(t) {
      return delete this.labels[t], this;
    }, e.addPause = function addPause(t, e, r) {
      var i = Zt.delayedCall(0, e || T, r);
      return i.data = "isPause", this._hasPause = 1, Ka(this, i, xt(this, t));
    }, e.removePause = function removePause(t) {
      var e = this._first;
      for (t = xt(this, t); e;) e._start === t && "isPause" === e.data && za(e), e = e._next;
    }, e.killTweensOf = function killTweensOf(t, e, r) {
      for (var i = this.getTweensOf(t, r), n = i.length; n--;) Nt !== i[n] && i[n].kill(t, e);
      return this;
    }, e.getTweensOf = function getTweensOf(e, r) {
      for (var i, n = [], a = Ot(e), s = this._first, o = t(r); s;) s instanceof Zt ? la(s._targets, a) && (o ? (!Nt || s._initted && s._ts) && s.globalTime(0) <= r && s.globalTime(s.totalDuration()) > r : !r || s.isActive()) && n.push(s) : (i = s.getTweensOf(a, r)).length && n.push.apply(n, i), s = s._next;
      return n;
    }, e.tweenTo = function tweenTo(t, e) {
      e = e || {};
      var r,
        i = this,
        n = xt(i, t),
        a = e.startAt,
        s = e.onStart,
        o = e.onStartParams,
        u = e.immediateRender,
        h = Zt.to(i, qa({
          ease: e.ease || "none",
          lazy: !1,
          immediateRender: !1,
          time: n,
          overwrite: "auto",
          duration: e.duration || Math.abs((n - (a && "time" in a ? a.time : i._time)) / i.timeScale()) || X,
          onStart: function onStart() {
            if (i.pause(), !r) {
              var t = e.duration || Math.abs((n - (a && "time" in a ? a.time : i._time)) / i.timeScale());
              h._dur !== t && Ra(h, t, 0, 1).render(h._time, !0, !0), r = 1;
            }
            s && s.apply(h, o || []);
          }
        }, e));
      return u ? h.render(0) : h;
    }, e.tweenFromTo = function tweenFromTo(t, e, r) {
      return this.tweenTo(e, qa({
        startAt: {
          time: xt(this, t)
        }
      }, r));
    }, e.recent = function recent() {
      return this._recent;
    }, e.nextLabel = function nextLabel(t) {
      return void 0 === t && (t = this._time), rb(this, xt(this, t));
    }, e.previousLabel = function previousLabel(t) {
      return void 0 === t && (t = this._time), rb(this, xt(this, t), 1);
    }, e.currentLabel = function currentLabel(t) {
      return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + X);
    }, e.shiftChildren = function shiftChildren(t, e, r) {
      void 0 === r && (r = 0);
      for (var i, n = this._first, a = this.labels; n;) n._start >= r && (n._start += t, n._end += t), n = n._next;
      if (e) for (i in a) a[i] >= r && (a[i] += t);
      return Aa(this);
    }, e.invalidate = function invalidate(t) {
      var e = this._first;
      for (this._lock = 0; e;) e.invalidate(t), e = e._next;
      return i.prototype.invalidate.call(this, t);
    }, e.clear = function clear(t) {
      void 0 === t && (t = !0);
      for (var e, r = this._first; r;) e = r._next, this.remove(r), r = e;
      return this._dp && (this._time = this._tTime = this._pTime = 0), t && (this.labels = {}), Aa(this);
    }, e.totalDuration = function totalDuration(t) {
      var e,
        r,
        i,
        n = 0,
        a = this,
        s = a._last,
        o = U;
      if (arguments.length) return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -t : t));
      if (a._dirty) {
        for (i = a.parent; s;) e = s._prev, s._dirty && s.totalDuration(), o < (r = s._start) && a._sort && s._ts && !a._lock ? (a._lock = 1, Ka(a, s, r - s._delay, 1)._lock = 0) : o = r, r < 0 && s._ts && (n -= r, (!i && !a._dp || i && i.smoothChildTiming) && (a._start += r / a._ts, a._time -= r, a._tTime -= r), a.shiftChildren(-r, !1, -Infinity), o = 0), s._end > n && s._ts && (n = s._end), s = e;
        Ra(a, a === I && a._time > n ? a._time : n, 1, 1), a._dirty = 0;
      }
      return a._tDur;
    }, Timeline.updateRoot = function updateRoot(t) {
      if (I._ts && (na(I, Ga(t, I)), f = Rt.frame), Rt.frame >= mt) {
        mt += q.autoSleep || 120;
        var e = I._first;
        if ((!e || !e._ts) && q.autoSleep && Rt._listeners.length < 2) {
          for (; e && !e._ts;) e = e._next;
          e || Rt.sleep();
        }
      }
    }, Timeline;
  }(Ut);
  qa(Xt.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
  });
  function ac(t, e, i, n, a, o) {
    var u, h, l, f;
    if (pt[t] && !1 !== (u = new pt[t]()).init(a, u.rawVars ? e[t] : function _processVars(t, e, i, n, a) {
      if (s(t) && (t = Kt(t, a, e, i, n)), !v(t) || t.style && t.nodeType || $(t) || Z(t)) return r(t) ? Kt(t, a, e, i, n) : t;
      var o,
        u = {};
      for (o in t) u[o] = Kt(t[o], a, e, i, n);
      return u;
    }(e[t], n, a, o, i), i, n, o) && (i._pt = h = new _e(i._pt, a, t, 0, 1, u.render, u, 0, u.priority), i !== c)) for (l = i._ptLookup[i._targets.indexOf(a)], f = u._props.length; f--;) l[u._props[f]] = h;
    return u;
  }
  function gc(t, r, e, i) {
    var n,
      a,
      s = r.ease || i || "power1.inOut";
    if ($(r)) a = e[t] || (e[t] = []), r.forEach(function (t, e) {
      return a.push({
        t: e / (r.length - 1) * 100,
        v: t,
        e: s
      });
    });else for (n in r) a = e[n] || (e[n] = []), "ease" === n || a.push({
      t: parseFloat(t),
      v: r[n],
      e: s
    });
  }
  var Nt,
    Wt,
    Qt = function _addPropTween(t, e, i, n, a, o, u, h, l, f) {
      s(n) && (n = n(a || 0, t, o));
      var c,
        d = t[e],
        p = "get" !== i ? i : s(d) ? l ? t[e.indexOf("set") || !s(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : t[e]() : d,
        _ = s(d) ? l ? re : te : $t;
      if (r(n) && (~n.indexOf("random(") && (n = ob(n)), "=" === n.charAt(1) && (!(c = ka(p, n) + (Ya(p) || 0)) && 0 !== c || (n = c))), !f || p !== n || Wt) return isNaN(p * n) || "" === n ? (d || e in t || Q(e, n), function _addComplexStringPropTween(t, e, r, i, n, a, s) {
        var o,
          u,
          h,
          l,
          f,
          c,
          d,
          p,
          _ = new _e(this._pt, t, e, 0, 1, ue, null, n),
          m = 0,
          g = 0;
        for (_.b = r, _.e = i, r += "", (d = ~(i += "").indexOf("random(")) && (i = ob(i)), a && (a(p = [r, i], t, e), r = p[0], i = p[1]), u = r.match(it) || []; o = it.exec(i);) l = o[0], f = i.substring(m, o.index), h ? h = (h + 1) % 5 : "rgba(" === f.substr(-5) && (h = 1), l !== u[g++] && (c = parseFloat(u[g - 1]) || 0, _._pt = {
          _next: _._pt,
          p: f || 1 === g ? f : ",",
          s: c,
          c: "=" === l.charAt(1) ? ka(c, l) - c : parseFloat(l) - c,
          m: h && h < 4 ? Math.round : 0
        }, m = it.lastIndex);
        return _.c = m < i.length ? i.substring(m, i.length) : "", _.fp = s, (nt.test(i) || d) && (_.e = 0), this._pt = _;
      }.call(this, t, e, p, n, _, h || q.stringFilter, l)) : (c = new _e(this._pt, t, e, +p || 0, n - (p || 0), "boolean" == typeof d ? se : ae, 0, _), l && (c.fp = l), u && c.modifier(u, this, t), this._pt = c);
    },
    Gt = function _initTween(t, e, r) {
      var i,
        n,
        a,
        s,
        o,
        u,
        h,
        l,
        f,
        c,
        d,
        p,
        _,
        m = t.vars,
        g = m.ease,
        v = m.startAt,
        y = m.immediateRender,
        T = m.lazy,
        b = m.onUpdate,
        x = m.onUpdateParams,
        k = m.callbackScope,
        M = m.runBackwards,
        O = m.yoyoEase,
        P = m.keyframes,
        A = m.autoRevert,
        C = t._dur,
        S = t._startAt,
        E = t._targets,
        D = t.parent,
        z = D && "nested" === D.data ? D.vars.targets : E,
        R = "auto" === t._overwrite && !B,
        F = t.timeline;
      if (!F || P && g || (g = "none"), t._ease = jt(g, V.ease), t._yEase = O ? Yt(jt(!0 === O ? g : O, V.ease)) : 0, O && t._yoyo && !t._repeat && (O = t._yEase, t._yEase = t._ease, t._ease = O), t._from = !F && !!m.runBackwards, !F || P && !m.stagger) {
        if (p = (l = E[0] ? fa(E[0]).harness : 0) && m[l.prop], i = ua(m, ft), S && (S._zTime < 0 && S.progress(1), e < 0 && M && y && !A ? S.render(-1, !0) : S.revert(M && C ? ht : ut), S._lazy = 0), v) {
          if (za(t._startAt = Zt.set(E, qa({
            data: "isStart",
            overwrite: !1,
            parent: D,
            immediateRender: !0,
            lazy: !S && w(T),
            startAt: null,
            delay: 0,
            onUpdate: b,
            onUpdateParams: x,
            callbackScope: k,
            stagger: 0
          }, v))), t._startAt._dp = 0, t._startAt._sat = t, e < 0 && (L || !y && !A) && t._startAt.revert(ht), y && C && e <= 0 && r <= 0) return void (e && (t._zTime = e));
        } else if (M && C && !S) if (e && (y = !1), a = qa({
          overwrite: !1,
          data: "isFromStart",
          lazy: y && !S && w(T),
          immediateRender: y,
          stagger: 0,
          parent: D
        }, i), p && (a[l.prop] = p), za(t._startAt = Zt.set(E, a)), t._startAt._dp = 0, t._startAt._sat = t, e < 0 && (L ? t._startAt.revert(ht) : t._startAt.render(-1, !0)), t._zTime = e, y) {
          if (!e) return;
        } else _initTween(t._startAt, X, X);
        for (t._pt = t._ptCache = 0, T = C && w(T) || T && !C, n = 0; n < E.length; n++) {
          if (h = (o = E[n])._gsap || ea(E)[n]._gsap, t._ptLookup[n] = c = {}, dt[h.id] && ct.length && ma(), d = z === E ? n : z.indexOf(o), l && !1 !== (f = new l()).init(o, p || i, t, d, z) && (t._pt = s = new _e(t._pt, o, f.name, 0, 1, f.render, f, 0, f.priority), f._props.forEach(function (t) {
            c[t] = s;
          }), f.priority && (u = 1)), !l || p) for (a in i) pt[a] && (f = ac(a, i, t, d, o, z)) ? f.priority && (u = 1) : c[a] = s = Qt.call(t, o, a, "get", i[a], d, z, 0, m.stringFilter);
          t._op && t._op[n] && t.kill(o, t._op[n]), R && t._pt && (Nt = t, I.killTweensOf(o, c, t.globalTime(e)), _ = !t.parent, Nt = 0), t._pt && T && (dt[h.id] = 1);
        }
        u && pe(t), t._onInit && t._onInit(t);
      }
      t._onUpdate = b, t._initted = (!t._op || t._pt) && !_, P && e <= 0 && F.render(U, !0, !0);
    },
    Kt = function _parseFuncOrString(t, e, i, n, a) {
      return s(t) ? t.call(e, i, n, a) : r(t) && ~t.indexOf("random(") ? ob(t) : t;
    },
    Jt = vt + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
    Ht = {};
  ha(Jt + ",id,stagger,delay,duration,paused,scrollTrigger", function (t) {
    return Ht[t] = 1;
  });
  var Zt = function (z) {
    function Tween(e, r, i, n) {
      var a;
      "number" == typeof r && (i.duration = r, r = i, i = null);
      var s,
        o,
        u,
        h,
        l,
        f,
        c,
        d,
        p = (a = z.call(this, n ? r : va(r)) || this).vars,
        _ = p.duration,
        m = p.delay,
        g = p.immediateRender,
        T = p.stagger,
        b = p.overwrite,
        x = p.keyframes,
        k = p.defaults,
        M = p.scrollTrigger,
        O = p.yoyoEase,
        P = r.parent || I,
        A = ($(e) || Z(e) ? t(e[0]) : "length" in r) ? [e] : Ot(e);
      if (a._targets = A.length ? ea(A) : R("GSAP target " + e + " not found. https://greensock.com", !q.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = b, x || T || y(_) || y(m)) {
        if (r = a.vars, (s = a.timeline = new Xt({
          data: "nested",
          defaults: k || {},
          targets: P && "nested" === P.data ? P.vars.targets : A
        })).kill(), s.parent = s._dp = _assertThisInitialized(a), s._start = 0, T || y(_) || y(m)) {
          if (h = A.length, c = T && eb(T), v(T)) for (l in T) ~Jt.indexOf(l) && ((d = d || {})[l] = T[l]);
          for (o = 0; o < h; o++) (u = ua(r, Ht)).stagger = 0, O && (u.yoyoEase = O), d && yt(u, d), f = A[o], u.duration = +Kt(_, _assertThisInitialized(a), o, f, A), u.delay = (+Kt(m, _assertThisInitialized(a), o, f, A) || 0) - a._delay, !T && 1 === h && u.delay && (a._delay = m = u.delay, a._start += m, u.delay = 0), s.to(f, u, c ? c(o, f, A) : 0), s._ease = Bt.none;
          s.duration() ? _ = m = 0 : a.timeline = 0;
        } else if (x) {
          va(qa(s.vars.defaults, {
            ease: "none"
          })), s._ease = jt(x.ease || r.ease || "none");
          var C,
            S,
            E,
            D = 0;
          if ($(x)) x.forEach(function (t) {
            return s.to(A, t, ">");
          }), s.duration();else {
            for (l in u = {}, x) "ease" === l || "easeEach" === l || gc(l, x[l], u, x.easeEach);
            for (l in u) for (C = u[l].sort(function (t, e) {
              return t.t - e.t;
            }), o = D = 0; o < C.length; o++) (E = {
              ease: (S = C[o]).e,
              duration: (S.t - (o ? C[o - 1].t : 0)) / 100 * _
            })[l] = S.v, s.to(A, E, D), D += E.duration;
            s.duration() < _ && s.to({}, {
              duration: _ - s.duration()
            });
          }
        }
        _ || a.duration(_ = s.duration());
      } else a.timeline = 0;
      return !0 !== b || B || (Nt = _assertThisInitialized(a), I.killTweensOf(A), Nt = 0), Ka(P, _assertThisInitialized(a), i), r.reversed && a.reverse(), r.paused && a.paused(!0), (g || !_ && !x && a._start === ja(P._time) && w(g) && function _hasNoPausedAncestors(t) {
        return !t || t._ts && _hasNoPausedAncestors(t.parent);
      }(_assertThisInitialized(a)) && "nested" !== P.data) && (a._tTime = -X, a.render(Math.max(0, -m) || 0)), M && La(_assertThisInitialized(a), M), a;
    }
    _inheritsLoose(Tween, z);
    var e = Tween.prototype;
    return e.render = function render(t, e, r) {
      var i,
        n,
        a,
        s,
        o,
        u,
        h,
        l,
        f,
        c = this._time,
        d = this._tDur,
        p = this._dur,
        _ = t < 0,
        m = d - X < t && !_ ? d : t < X ? 0 : t;
      if (p) {
        if (m !== this._tTime || !t || r || !this._initted && this._tTime || this._startAt && this._zTime < 0 != _) {
          if (i = m, l = this.timeline, this._repeat) {
            if (s = p + this._rDelay, this._repeat < -1 && _) return this.totalTime(100 * s + t, e, r);
            if (i = ja(m % s), m === d ? (a = this._repeat, i = p) : ((a = ~~(m / s)) && a === m / s && (i = p, a--), p < i && (i = p)), (u = this._yoyo && 1 & a) && (f = this._yEase, i = p - i), o = Tt(this._tTime, s), i === c && !r && this._initted) return this._tTime = m, this;
            a !== o && (l && this._yEase && Qb(l, u), !this.vars.repeatRefresh || u || this._lock || (this._lock = r = 1, this.render(ja(s * a), !0).invalidate()._lock = 0));
          }
          if (!this._initted) {
            if (Ma(this, _ ? t : i, r, e, m)) return this._tTime = 0, this;
            if (c !== this._time) return this;
            if (p !== this._dur) return this.render(t, e, r);
          }
          if (this._tTime = m, this._time = i, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = h = (f || this._ease)(i / p), this._from && (this.ratio = h = 1 - h), i && !c && !e && !a && (At(this, "onStart"), this._tTime !== m)) return this;
          for (n = this._pt; n;) n.r(h, n.d), n = n._next;
          l && l.render(t < 0 ? t : !i && u ? -X : l._dur * l._ease(i / this._dur), e, r) || this._startAt && (this._zTime = t), this._onUpdate && !e && (_ && Ca(this, t, 0, r), At(this, "onUpdate")), this._repeat && a !== o && this.vars.onRepeat && !e && this.parent && At(this, "onRepeat"), m !== this._tDur && m || this._tTime !== m || (_ && !this._onUpdate && Ca(this, t, 0, !0), !t && p || !(m === this._tDur && 0 < this._ts || !m && this._ts < 0) || za(this, 1), e || _ && !c || !(m || c || u) || (At(this, m === d ? "onComplete" : "onReverseComplete", !0), !this._prom || m < d && 0 < this.timeScale() || this._prom()));
        }
      } else !function _renderZeroDurationTween(t, e, r, i) {
        var n,
          a,
          s,
          o = t.ratio,
          u = e < 0 || !e && (!t._start && function _parentPlayheadIsBeforeStart(t) {
            var e = t.parent;
            return e && e._ts && e._initted && !e._lock && (e.rawTime() < 0 || _parentPlayheadIsBeforeStart(e));
          }(t) && (t._initted || !bt(t)) || (t._ts < 0 || t._dp._ts < 0) && !bt(t)) ? 0 : 1,
          h = t._rDelay,
          l = 0;
        if (h && t._repeat && (l = kt(0, t._tDur, e), a = Tt(l, h), t._yoyo && 1 & a && (u = 1 - u), a !== Tt(t._tTime, h) && (o = 1 - u, t.vars.repeatRefresh && t._initted && t.invalidate())), u !== o || L || i || t._zTime === X || !e && t._zTime) {
          if (!t._initted && Ma(t, e, i, r, l)) return;
          for (s = t._zTime, t._zTime = e || (r ? X : 0), r = r || e && !s, t.ratio = u, t._from && (u = 1 - u), t._time = 0, t._tTime = l, n = t._pt; n;) n.r(u, n.d), n = n._next;
          e < 0 && Ca(t, e, 0, !0), t._onUpdate && !r && At(t, "onUpdate"), l && t._repeat && !r && t.parent && At(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === u && (u && za(t, 1), r || L || (At(t, u ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()));
        } else t._zTime || (t._zTime = e);
      }(this, t, e, r);
      return this;
    }, e.targets = function targets() {
      return this._targets;
    }, e.invalidate = function invalidate(t) {
      return t && this.vars.runBackwards || (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(t), z.prototype.invalidate.call(this, t);
    }, e.resetTo = function resetTo(t, e, r, i) {
      d || Rt.wake(), this._ts || this.play();
      var n,
        a = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
      return this._initted || Gt(this, a), n = this._ease(a / this._dur), function _updatePropTweens(t, e, r, i, n, a, s) {
        var o,
          u,
          h,
          l,
          f = (t._pt && t._ptCache || (t._ptCache = {}))[e];
        if (!f) for (f = t._ptCache[e] = [], h = t._ptLookup, l = t._targets.length; l--;) {
          if ((o = h[l][e]) && o.d && o.d._pt) for (o = o.d._pt; o && o.p !== e && o.fp !== e;) o = o._next;
          if (!o) return Wt = 1, t.vars[e] = "+=0", Gt(t, s), Wt = 0, 1;
          f.push(o);
        }
        for (l = f.length; l--;) (o = (u = f[l])._pt || u).s = !i && 0 !== i || n ? o.s + (i || 0) + a * o.c : i, o.c = r - o.s, u.e && (u.e = ia(r) + Ya(u.e)), u.b && (u.b = o.s + Ya(u.b));
      }(this, t, e, r, i, n, a) ? this.resetTo(t, e, r, i) : (Ia(this, 0), this.parent || xa(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0));
    }, e.kill = function kill(t, e) {
      if (void 0 === e && (e = "all"), !(t || e && "all" !== e)) return this._lazy = this._pt = 0, this.parent ? tb(this) : this;
      if (this.timeline) {
        var i = this.timeline.totalDuration();
        return this.timeline.killTweensOf(t, e, Nt && !0 !== Nt.vars.overwrite)._first || tb(this), this.parent && i !== this.timeline.totalDuration() && Ra(this, this._dur * this.timeline._tDur / i, 0, 1), this;
      }
      var n,
        a,
        s,
        o,
        u,
        h,
        l,
        f = this._targets,
        c = t ? Ot(t) : f,
        d = this._ptLookup,
        p = this._pt;
      if ((!e || "all" === e) && function _arraysMatch(t, e) {
        for (var r = t.length, i = r === e.length; i && r-- && t[r] === e[r];);
        return r < 0;
      }(f, c)) return "all" === e && (this._pt = 0), tb(this);
      for (n = this._op = this._op || [], "all" !== e && (r(e) && (u = {}, ha(e, function (t) {
        return u[t] = 1;
      }), e = u), e = function _addAliasesToVars(t, e) {
        var r,
          i,
          n,
          a,
          s = t[0] ? fa(t[0]).harness : 0,
          o = s && s.aliases;
        if (!o) return e;
        for (i in r = yt({}, e), o) if ((i in r)) for (n = (a = o[i].split(",")).length; n--;) r[a[n]] = r[i];
        return r;
      }(f, e)), l = f.length; l--;) if (~c.indexOf(f[l])) for (u in a = d[l], "all" === e ? (n[l] = e, o = a, s = {}) : (s = n[l] = n[l] || {}, o = e), o) (h = a && a[u]) && ("kill" in h.d && !0 !== h.d.kill(u) || ya(this, h, "_pt"), delete a[u]), "all" !== s && (s[u] = 1);
      return this._initted && !this._pt && p && tb(this), this;
    }, Tween.to = function to(t, e, r) {
      return new Tween(t, e, r);
    }, Tween.from = function from(t, e) {
      return Va(1, arguments);
    }, Tween.delayedCall = function delayedCall(t, e, r, i) {
      return new Tween(e, 0, {
        immediateRender: !1,
        lazy: !1,
        overwrite: !1,
        delay: t,
        onComplete: e,
        onReverseComplete: e,
        onCompleteParams: r,
        onReverseCompleteParams: r,
        callbackScope: i
      });
    }, Tween.fromTo = function fromTo(t, e, r) {
      return Va(2, arguments);
    }, Tween.set = function set(t, e) {
      return e.duration = 0, e.repeatDelay || (e.repeat = 0), new Tween(t, e);
    }, Tween.killTweensOf = function killTweensOf(t, e, r) {
      return I.killTweensOf(t, e, r);
    }, Tween;
  }(Ut);
  qa(Zt.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
  }), ha("staggerTo,staggerFrom,staggerFromTo", function (r) {
    Zt[r] = function () {
      var t = new Xt(),
        e = Mt.call(arguments, 0);
      return e.splice("staggerFromTo" === r ? 5 : 4, 0, 0), t[r].apply(t, e);
    };
  });
  function oc(t, e, r) {
    return t.setAttribute(e, r);
  }
  function wc(t, e, r, i) {
    i.mSet(t, e, i.m.call(i.tween, r, i.mt), i);
  }
  var $t = function _setterPlain(t, e, r) {
      return t[e] = r;
    },
    te = function _setterFunc(t, e, r) {
      return t[e](r);
    },
    re = function _setterFuncWithParam(t, e, r, i) {
      return t[e](i.fp, r);
    },
    ne = function _getSetter(t, e) {
      return s(t[e]) ? te : u(t[e]) && t.setAttribute ? oc : $t;
    },
    ae = function _renderPlain(t, e) {
      return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e);
    },
    se = function _renderBoolean(t, e) {
      return e.set(e.t, e.p, !!(e.s + e.c * t), e);
    },
    ue = function _renderComplexString(t, e) {
      var r = e._pt,
        i = "";
      if (!t && e.b) i = e.b;else if (1 === t && e.e) i = e.e;else {
        for (; r;) i = r.p + (r.m ? r.m(r.s + r.c * t) : Math.round(1e4 * (r.s + r.c * t)) / 1e4) + i, r = r._next;
        i += e.c;
      }
      e.set(e.t, e.p, i, e);
    },
    he = function _renderPropTweens(t, e) {
      for (var r = e._pt; r;) r.r(t, r.d), r = r._next;
    },
    fe = function _addPluginModifier(t, e, r, i) {
      for (var n, a = this._pt; a;) n = a._next, a.p === i && a.modifier(t, e, r), a = n;
    },
    ce = function _killPropTweensOf(t) {
      for (var e, r, i = this._pt; i;) r = i._next, i.p === t && !i.op || i.op === t ? ya(this, i, "_pt") : i.dep || (e = 1), i = r;
      return !e;
    },
    pe = function _sortPropTweensByPriority(t) {
      for (var e, r, i, n, a = t._pt; a;) {
        for (e = a._next, r = i; r && r.pr > a.pr;) r = r._next;
        (a._prev = r ? r._prev : n) ? a._prev._next = a : i = a, (a._next = r) ? r._prev = a : n = a, a = e;
      }
      t._pt = i;
    },
    _e = (PropTween.prototype.modifier = function modifier(t, e, r) {
      this.mSet = this.mSet || this.set, this.set = wc, this.m = t, this.mt = r, this.tween = e;
    }, PropTween);
  function PropTween(t, e, r, i, n, a, s, o, u) {
    this.t = e, this.s = i, this.c = n, this.p = r, this.r = a || ae, this.d = s || this, this.set = o || $t, this.pr = u || 0, (this._next = t) && (t._prev = this);
  }
  ha(vt + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (t) {
    return ft[t] = 1;
  }), ot.TweenMax = ot.TweenLite = Zt, ot.TimelineLite = ot.TimelineMax = Xt, I = new Xt({
    sortChildren: !1,
    defaults: V,
    autoRemoveChildren: !0,
    id: "root",
    smoothChildTiming: !0
  }), q.stringFilter = Fb;
  function Ec(t) {
    return (ye[t] || Te).map(function (t) {
      return t();
    });
  }
  function Fc() {
    var t = Date.now(),
      o = [];
    2 < t - Me && (Ec("matchMediaInit"), ge.forEach(function (t) {
      var e,
        r,
        i,
        n,
        a = t.queries,
        s = t.conditions;
      for (r in a) (e = h.matchMedia(a[r]).matches) && (i = 1), e !== s[r] && (s[r] = e, n = 1);
      n && (t.revert(), i && o.push(t));
    }), Ec("matchMediaRevert"), o.forEach(function (t) {
      return t.onMatch(t);
    }), Me = t, Ec("matchMedia"));
  }
  var me,
    ge = [],
    ye = {},
    Te = [],
    Me = 0,
    Oe = 0,
    Pe = ((me = Context.prototype).add = function add(t, i, n) {
      function Ew() {
        var t,
          e = l,
          r = a.selector;
        return e && e !== a && e.data.push(a), n && (a.selector = cb(n)), l = a, t = i.apply(a, arguments), s(t) && a._r.push(t), l = e, a.selector = r, a.isReverted = !1, t;
      }
      s(t) && (n = i, i = t, t = s);
      var a = this;
      return a.last = Ew, t === s ? Ew(a) : t ? a[t] = Ew : Ew;
    }, me.ignore = function ignore(t) {
      var e = l;
      l = null, t(this), l = e;
    }, me.getTweens = function getTweens() {
      var e = [];
      return this.data.forEach(function (t) {
        return t instanceof Context ? e.push.apply(e, t.getTweens()) : t instanceof Zt && !(t.parent && "nested" === t.parent.data) && e.push(t);
      }), e;
    }, me.clear = function clear() {
      this._r.length = this.data.length = 0;
    }, me.kill = function kill(e, t) {
      var r = this;
      if (e) {
        var i = this.getTweens();
        this.data.forEach(function (t) {
          "isFlip" === t.data && (t.revert(), t.getChildren(!0, !0, !1).forEach(function (t) {
            return i.splice(i.indexOf(t), 1);
          }));
        }), i.map(function (t) {
          return {
            g: t.globalTime(0),
            t: t
          };
        }).sort(function (t, e) {
          return e.g - t.g || -1;
        }).forEach(function (t) {
          return t.t.revert(e);
        }), this.data.forEach(function (t) {
          return t instanceof Xt ? "nested" !== t.data && t.kill() : !(t instanceof Zt) && t.revert && t.revert(e);
        }), this._r.forEach(function (t) {
          return t(e, r);
        }), this.isReverted = !0;
      } else this.data.forEach(function (t) {
        return t.kill && t.kill();
      });
      if (this.clear(), t) for (var n = ge.length; n--;) ge[n].id === this.id && ge.splice(n, 1);
    }, me.revert = function revert(t) {
      this.kill(t || {});
    }, Context);
  function Context(t, e) {
    this.selector = e && cb(e), this.data = [], this._r = [], this.isReverted = !1, this.id = Oe++, t && this.add(t);
  }
  var Ae,
    Ce = ((Ae = MatchMedia.prototype).add = function add(t, e, r) {
      v(t) || (t = {
        matches: t
      });
      var i,
        n,
        a,
        s = new Pe(0, r || this.scope),
        o = s.conditions = {};
      for (n in l && !s.selector && (s.selector = l.selector), this.contexts.push(s), e = s.add("onMatch", e), s.queries = t) "all" === n ? a = 1 : (i = h.matchMedia(t[n])) && (ge.indexOf(s) < 0 && ge.push(s), (o[n] = i.matches) && (a = 1), i.addListener ? i.addListener(Fc) : i.addEventListener("change", Fc));
      return a && e(s), this;
    }, Ae.revert = function revert(t) {
      this.kill(t || {});
    }, Ae.kill = function kill(e) {
      this.contexts.forEach(function (t) {
        return t.kill(e, !0);
      });
    }, MatchMedia);
  function MatchMedia(t) {
    this.contexts = [], this.scope = t;
  }
  var Se = {
    registerPlugin: function registerPlugin() {
      for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++) e[r] = arguments[r];
      e.forEach(function (t) {
        return wb(t);
      });
    },
    timeline: function timeline(t) {
      return new Xt(t);
    },
    getTweensOf: function getTweensOf(t, e) {
      return I.getTweensOf(t, e);
    },
    getProperty: function getProperty(i, t, e, n) {
      r(i) && (i = Ot(i)[0]);
      var a = fa(i || {}).get,
        s = e ? pa : oa;
      return "native" === e && (e = ""), i ? t ? s((pt[t] && pt[t].get || a)(i, t, e, n)) : function (t, e, r) {
        return s((pt[t] && pt[t].get || a)(i, t, e, r));
      } : i;
    },
    quickSetter: function quickSetter(r, e, i) {
      if (1 < (r = Ot(r)).length) {
        var n = r.map(function (t) {
            return Ee.quickSetter(t, e, i);
          }),
          a = n.length;
        return function (t) {
          for (var e = a; e--;) n[e](t);
        };
      }
      r = r[0] || {};
      var s = pt[e],
        o = fa(r),
        u = o.harness && (o.harness.aliases || {})[e] || e,
        h = s ? function (t) {
          var e = new s();
          c._pt = 0, e.init(r, i ? t + i : t, c, 0, [r]), e.render(1, e), c._pt && he(1, c);
        } : o.set(r, u);
      return s ? h : function (t) {
        return h(r, u, i ? t + i : t, o, 1);
      };
    },
    quickTo: function quickTo(t, i, e) {
      function Wx(t, e, r) {
        return n.resetTo(i, t, e, r);
      }
      var r,
        n = Ee.to(t, yt(((r = {})[i] = "+=0.1", r.paused = !0, r), e || {}));
      return Wx.tween = n, Wx;
    },
    isTweening: function isTweening(t) {
      return 0 < I.getTweensOf(t, !0).length;
    },
    defaults: function defaults(t) {
      return t && t.ease && (t.ease = jt(t.ease, V.ease)), ta(V, t || {});
    },
    config: function config(t) {
      return ta(q, t || {});
    },
    registerEffect: function registerEffect(t) {
      var i = t.name,
        n = t.effect,
        e = t.plugins,
        a = t.defaults,
        r = t.extendTimeline;
      (e || "").split(",").forEach(function (t) {
        return t && !pt[t] && !ot[t] && R(i + " effect requires " + t + " plugin.");
      }), _t[i] = function (t, e, r) {
        return n(Ot(t), qa(e || {}, a), r);
      }, r && (Xt.prototype[i] = function (t, e, r) {
        return this.add(_t[i](t, v(e) ? e : (r = e) && {}, this), r);
      });
    },
    registerEase: function registerEase(t, e) {
      Bt[t] = jt(e);
    },
    parseEase: function parseEase(t, e) {
      return arguments.length ? jt(t, e) : Bt;
    },
    getById: function getById(t) {
      return I.getById(t);
    },
    exportRoot: function exportRoot(t, e) {
      void 0 === t && (t = {});
      var r,
        i,
        n = new Xt(t);
      for (n.smoothChildTiming = w(t.smoothChildTiming), I.remove(n), n._dp = 0, n._time = n._tTime = I._time, r = I._first; r;) i = r._next, !e && !r._dur && r instanceof Zt && r.vars.onComplete === r._targets[0] || Ka(n, r, r._start - r._delay), r = i;
      return Ka(I, n, 0), n;
    },
    context: function context(t, e) {
      return t ? new Pe(t, e) : l;
    },
    matchMedia: function matchMedia(t) {
      return new Ce(t);
    },
    matchMediaRefresh: function matchMediaRefresh() {
      return ge.forEach(function (t) {
        var e,
          r,
          i = t.conditions;
        for (r in i) i[r] && (i[r] = !1, e = 1);
        e && t.revert();
      }) || Fc();
    },
    addEventListener: function addEventListener(t, e) {
      var r = ye[t] || (ye[t] = []);
      ~r.indexOf(e) || r.push(e);
    },
    removeEventListener: function removeEventListener(t, e) {
      var r = ye[t],
        i = r && r.indexOf(e);
      0 <= i && r.splice(i, 1);
    },
    utils: {
      wrap: function wrap(e, t, r) {
        var i = t - e;
        return $(e) ? lb(e, wrap(0, e.length), t) : Wa(r, function (t) {
          return (i + (t - e) % i) % i + e;
        });
      },
      wrapYoyo: function wrapYoyo(e, t, r) {
        var i = t - e,
          n = 2 * i;
        return $(e) ? lb(e, wrapYoyo(0, e.length - 1), t) : Wa(r, function (t) {
          return e + (i < (t = (n + (t - e) % n) % n || 0) ? n - t : t);
        });
      },
      distribute: eb,
      random: hb,
      snap: gb,
      normalize: function normalize(t, e, r) {
        return Pt(t, e, 0, 1, r);
      },
      getUnit: Ya,
      clamp: function clamp(e, r, t) {
        return Wa(t, function (t) {
          return kt(e, r, t);
        });
      },
      splitColor: Ab,
      toArray: Ot,
      selector: cb,
      mapRange: Pt,
      pipe: function pipe() {
        for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++) e[r] = arguments[r];
        return function (t) {
          return e.reduce(function (t, e) {
            return e(t);
          }, t);
        };
      },
      unitize: function unitize(e, r) {
        return function (t) {
          return e(parseFloat(t)) + (r || Ya(t));
        };
      },
      interpolate: function interpolate(e, i, t, n) {
        var a = isNaN(e + i) ? 0 : function (t) {
          return (1 - t) * e + t * i;
        };
        if (!a) {
          var s,
            o,
            u,
            h,
            l,
            f = r(e),
            c = {};
          if (!0 === t && (n = 1) && (t = null), f) e = {
            p: e
          }, i = {
            p: i
          };else if ($(e) && !$(i)) {
            for (u = [], h = e.length, l = h - 2, o = 1; o < h; o++) u.push(interpolate(e[o - 1], e[o]));
            h--, a = function func(t) {
              t *= h;
              var e = Math.min(l, ~~t);
              return u[e](t - e);
            }, t = i;
          } else n || (e = yt($(e) ? [] : {}, e));
          if (!u) {
            for (s in i) Qt.call(c, e, s, "get", i[s]);
            a = function func(t) {
              return he(t, c) || (f ? e.p : e);
            };
          }
        }
        return Wa(t, a);
      },
      shuffle: db
    },
    install: P,
    effects: _t,
    ticker: Rt,
    updateRoot: Xt.updateRoot,
    plugins: pt,
    globalTimeline: I,
    core: {
      PropTween: _e,
      globals: S,
      Tween: Zt,
      Timeline: Xt,
      Animation: Ut,
      getCache: fa,
      _removeLinkedListItem: ya,
      reverting: function reverting() {
        return L;
      },
      context: function context(t) {
        return t && l && (l.data.push(t), t._ctx = l), l;
      },
      suppressOverwrites: function suppressOverwrites(t) {
        return B = t;
      }
    }
  };
  ha("to,from,fromTo,delayedCall,set,killTweensOf", function (t) {
    return Se[t] = Zt[t];
  }), Rt.add(Xt.updateRoot), c = Se.to({}, {
    duration: 0
  });
  function Jc(t, e) {
    for (var r = t._pt; r && r.p !== e && r.op !== e && r.fp !== e;) r = r._next;
    return r;
  }
  function Lc(t, a) {
    return {
      name: t,
      rawVars: 1,
      init: function init(t, n, e) {
        e._onInit = function (t) {
          var e, i;
          if (r(n) && (e = {}, ha(n, function (t) {
            return e[t] = 1;
          }), n = e), a) {
            for (i in e = {}, n) e[i] = a(n[i]);
            n = e;
          }
          !function _addModifiers(t, e) {
            var r,
              i,
              n,
              a = t._targets;
            for (r in e) for (i = a.length; i--;) (n = (n = t._ptLookup[i][r]) && n.d) && (n._pt && (n = Jc(n, r)), n && n.modifier && n.modifier(e[r], t, a[i], r));
          }(t, n);
        };
      }
    };
  }
  var Ee = Se.registerPlugin({
    name: "attr",
    init: function init(t, e, r, i, n) {
      var a, s, o;
      for (a in this.tween = r, e) o = t.getAttribute(a) || "", (s = this.add(t, "setAttribute", (o || 0) + "", e[a], i, n, 0, 0, a)).op = a, s.b = o, this._props.push(a);
    },
    render: function render(t, e) {
      for (var r = e._pt; r;) L ? r.set(r.t, r.p, r.b, r) : r.r(t, r.d), r = r._next;
    }
  }, {
    name: "endArray",
    init: function init(t, e) {
      for (var r = e.length; r--;) this.add(t, r, t[r] || 0, e[r], 0, 0, 0, 0, 0, 1);
    }
  }, Lc("roundProps", fb), Lc("modifiers"), Lc("snap", gb)) || Se;
  Zt.version = Xt.version = Ee.version = "3.12.1", o = 1, x() && Ft();
  function vd(t, e) {
    return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e);
  }
  function wd(t, e) {
    return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e);
  }
  function xd(t, e) {
    return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e);
  }
  function yd(t, e) {
    var r = e.s + e.c * t;
    e.set(e.t, e.p, ~~(r + (r < 0 ? -.5 : .5)) + e.u, e);
  }
  function zd(t, e) {
    return e.set(e.t, e.p, t ? e.e : e.b, e);
  }
  function Ad(t, e) {
    return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e);
  }
  function Bd(t, e, r) {
    return t.style[e] = r;
  }
  function Cd(t, e, r) {
    return t.style.setProperty(e, r);
  }
  function Dd(t, e, r) {
    return t._gsap[e] = r;
  }
  function Ed(t, e, r) {
    return t._gsap.scaleX = t._gsap.scaleY = r;
  }
  function Fd(t, e, r, i, n) {
    var a = t._gsap;
    a.scaleX = a.scaleY = r, a.renderTransform(n, a);
  }
  function Gd(t, e, r, i, n) {
    var a = t._gsap;
    a[e] = r, a.renderTransform(n, a);
  }
  function Jd(t, e) {
    var r = this,
      i = this.target,
      n = i.style;
    if (t in ar && n) {
      if (this.tfm = this.tfm || {}, "transform" === t) return cr.transform.split(",").forEach(function (t) {
        return Jd.call(r, t, e);
      });
      if (~(t = cr[t] || t).indexOf(",") ? t.split(",").forEach(function (t) {
        return r.tfm[t] = yr(i, t);
      }) : this.tfm[t] = i._gsap.x ? i._gsap[t] : yr(i, t), 0 <= this.props.indexOf(dr)) return;
      i._gsap.svg && (this.svgo = i.getAttribute("data-svg-origin"), this.props.push(pr, e, "")), t = dr;
    }
    (n || e) && this.props.push(t, e, n[t]);
  }
  function Kd(t) {
    t.translate && (t.removeProperty("translate"), t.removeProperty("scale"), t.removeProperty("rotate"));
  }
  function Ld() {
    var t,
      e,
      r = this.props,
      i = this.target,
      n = i.style,
      a = i._gsap;
    for (t = 0; t < r.length; t += 3) r[t + 1] ? i[r[t]] = r[t + 2] : r[t + 2] ? n[r[t]] = r[t + 2] : n.removeProperty("--" === r[t].substr(0, 2) ? r[t] : r[t].replace(hr, "-$1").toLowerCase());
    if (this.tfm) {
      for (e in this.tfm) a[e] = this.tfm[e];
      a.svg && (a.renderTransform(), i.setAttribute("data-svg-origin", this.svgo || "")), (t = Ie()) && t.isStart || n[dr] || (Kd(n), a.uncache = 1);
    }
  }
  function Md(t, e) {
    var r = {
      target: t,
      props: [],
      revert: Ld,
      save: Jd
    };
    return t._gsap || Ee.core.getCache(t), e && e.split(",").forEach(function (t) {
      return r.save(t);
    }), r;
  }
  function Od(t, e) {
    var r = ze.createElementNS ? ze.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : ze.createElement(t);
    return r.style ? r : ze.createElement(t);
  }
  function Pd(t, e, r) {
    var i = getComputedStyle(t);
    return i[e] || i.getPropertyValue(e.replace(hr, "-$1").toLowerCase()) || i.getPropertyValue(e) || !r && Pd(t, mr(e) || e, 1) || "";
  }
  function Sd() {
    (function _windowExists() {
      return "undefined" != typeof window;
    })() && window.document && (De = window, ze = De.document, Re = ze.documentElement, Be = Od("div") || {
      style: {}
    }, Od("div"), dr = mr(dr), pr = dr + "Origin", Be.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", Ye = !!mr("perspective"), Ie = Ee.core.reverting, Fe = 1);
  }
  function Td(t) {
    var e,
      r = Od("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
      i = this.parentNode,
      n = this.nextSibling,
      a = this.style.cssText;
    if (Re.appendChild(r), r.appendChild(this), this.style.display = "block", t) try {
      e = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = Td;
    } catch (t) {} else this._gsapBBox && (e = this._gsapBBox());
    return i && (n ? i.insertBefore(this, n) : i.appendChild(this)), Re.removeChild(r), this.style.cssText = a, e;
  }
  function Ud(t, e) {
    for (var r = e.length; r--;) if (t.hasAttribute(e[r])) return t.getAttribute(e[r]);
  }
  function Vd(e) {
    var r;
    try {
      r = e.getBBox();
    } catch (t) {
      r = Td.call(e, !0);
    }
    return r && (r.width || r.height) || e.getBBox === Td || (r = Td.call(e, !0)), !r || r.width || r.x || r.y ? r : {
      x: +Ud(e, ["x", "cx", "x1"]) || 0,
      y: +Ud(e, ["y", "cy", "y1"]) || 0,
      width: 0,
      height: 0
    };
  }
  function Wd(t) {
    return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !Vd(t));
  }
  function Xd(t, e) {
    if (e) {
      var r = t.style;
      e in ar && e !== pr && (e = dr), r.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), r.removeProperty(e.replace(hr, "-$1").toLowerCase())) : r.removeAttribute(e);
    }
  }
  function Yd(t, e, r, i, n, a) {
    var s = new _e(t._pt, e, r, 0, 1, a ? Ad : zd);
    return (t._pt = s).b = i, s.e = n, t._props.push(r), s;
  }
  function _d(t, e, r, i) {
    var n,
      a,
      s,
      o,
      u = parseFloat(r) || 0,
      h = (r + "").trim().substr((u + "").length) || "px",
      l = Be.style,
      f = lr.test(e),
      c = "svg" === t.tagName.toLowerCase(),
      d = (c ? "client" : "offset") + (f ? "Width" : "Height"),
      p = "px" === i,
      _ = "%" === i;
    return i === h || !u || gr[i] || gr[h] ? u : ("px" === h || p || (u = _d(t, e, r, "px")), o = t.getCTM && Wd(t), !_ && "%" !== h || !ar[e] && !~e.indexOf("adius") ? (l[f ? "width" : "height"] = 100 + (p ? h : i), a = ~e.indexOf("adius") || "em" === i && t.appendChild && !c ? t : t.parentNode, o && (a = (t.ownerSVGElement || {}).parentNode), a && a !== ze && a.appendChild || (a = ze.body), (s = a._gsap) && _ && s.width && f && s.time === Rt.time && !s.uncache ? ia(u / s.width * 100) : (!_ && "%" !== h || vr[Pd(a, "display")] || (l.position = Pd(t, "position")), a === t && (l.position = "static"), a.appendChild(Be), n = Be[d], a.removeChild(Be), l.position = "absolute", f && _ && ((s = fa(a)).time = Rt.time, s.width = a[d]), ia(p ? n * u / 100 : n && u ? 100 / n * u : 0))) : (n = o ? t.getBBox()[f ? "width" : "height"] : t[d], ia(_ ? u / n * 100 : u / 100 * n)));
  }
  function be(t, e, r, i) {
    if (!r || "none" === r) {
      var n = mr(e, t, 1),
        a = n && Pd(t, n, 1);
      a && a !== r ? (e = n, r = a) : "borderColor" === e && (r = Pd(t, "borderTopColor"));
    }
    var s,
      o,
      u,
      h,
      l,
      f,
      c,
      d,
      p,
      _,
      m,
      g = new _e(this._pt, t.style, e, 0, 1, ue),
      v = 0,
      y = 0;
    if (g.b = r, g.e = i, r += "", "auto" === (i += "") && (t.style[e] = i, i = Pd(t, e) || i, t.style[e] = r), Fb(s = [r, i]), i = s[1], u = (r = s[0]).match(rt) || [], (i.match(rt) || []).length) {
      for (; o = rt.exec(i);) c = o[0], p = i.substring(v, o.index), l ? l = (l + 1) % 5 : "rgba(" !== p.substr(-5) && "hsla(" !== p.substr(-5) || (l = 1), c !== (f = u[y++] || "") && (h = parseFloat(f) || 0, m = f.substr((h + "").length), "=" === c.charAt(1) && (c = ka(h, c) + m), d = parseFloat(c), _ = c.substr((d + "").length), v = rt.lastIndex - _.length, _ || (_ = _ || q.units[e] || m, v === i.length && (i += _, g.e += _)), m !== _ && (h = _d(t, e, f, _) || 0), g._pt = {
        _next: g._pt,
        p: p || 1 === y ? p : ",",
        s: h,
        c: d - h,
        m: l && l < 4 || "zIndex" === e ? Math.round : 0
      });
      g.c = v < i.length ? i.substring(v, i.length) : "";
    } else g.r = "display" === e && "none" === i ? Ad : zd;
    return nt.test(i) && (g.e = 0), this._pt = g;
  }
  function de(t) {
    var e = t.split(" "),
      r = e[0],
      i = e[1] || "50%";
    return "top" !== r && "bottom" !== r && "left" !== i && "right" !== i || (t = r, r = i, i = t), e[0] = Tr[r] || r, e[1] = Tr[i] || i, e.join(" ");
  }
  function ee(t, e) {
    if (e.tween && e.tween._time === e.tween._dur) {
      var r,
        i,
        n,
        a = e.t,
        s = a.style,
        o = e.u,
        u = a._gsap;
      if ("all" === o || !0 === o) s.cssText = "", i = 1;else for (n = (o = o.split(",")).length; -1 < --n;) r = o[n], ar[r] && (i = 1, r = "transformOrigin" === r ? pr : dr), Xd(a, r);
      i && (Xd(a, dr), u && (u.svg && a.removeAttribute("transform"), kr(a, 1), u.uncache = 1, Kd(s)));
    }
  }
  function ie(t) {
    return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t;
  }
  function je(t) {
    var e = Pd(t, dr);
    return ie(e) ? wr : e.substr(7).match(et).map(ia);
  }
  function ke(t, e) {
    var r,
      i,
      n,
      a,
      s = t._gsap || fa(t),
      o = t.style,
      u = je(t);
    return s.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (u = [(n = t.transform.baseVal.consolidate().matrix).a, n.b, n.c, n.d, n.e, n.f]).join(",") ? wr : u : (u !== wr || t.offsetParent || t === Re || s.svg || (n = o.display, o.display = "block", (r = t.parentNode) && t.offsetParent || (a = 1, i = t.nextElementSibling, Re.appendChild(t)), u = je(t), n ? o.display = n : Xd(t, "display"), a && (i ? r.insertBefore(t, i) : r ? r.appendChild(t) : Re.removeChild(t))), e && 6 < u.length ? [u[0], u[1], u[4], u[5], u[12], u[13]] : u);
  }
  function le(t, e, r, i, n, a) {
    var s,
      o,
      u,
      h = t._gsap,
      l = n || ke(t, !0),
      f = h.xOrigin || 0,
      c = h.yOrigin || 0,
      d = h.xOffset || 0,
      p = h.yOffset || 0,
      _ = l[0],
      m = l[1],
      g = l[2],
      v = l[3],
      y = l[4],
      T = l[5],
      b = e.split(" "),
      w = parseFloat(b[0]) || 0,
      x = parseFloat(b[1]) || 0;
    r ? l !== wr && (o = _ * v - m * g) && (u = w * (-m / o) + x * (_ / o) - (_ * T - m * y) / o, w = w * (v / o) + x * (-g / o) + (g * T - v * y) / o, x = u) : (w = (s = Vd(t)).x + (~b[0].indexOf("%") ? w / 100 * s.width : w), x = s.y + (~(b[1] || b[0]).indexOf("%") ? x / 100 * s.height : x)), i || !1 !== i && h.smooth ? (y = w - f, T = x - c, h.xOffset = d + (y * _ + T * g) - y, h.yOffset = p + (y * m + T * v) - T) : h.xOffset = h.yOffset = 0, h.xOrigin = w, h.yOrigin = x, h.smooth = !!i, h.origin = e, h.originIsAbsolute = !!r, t.style[pr] = "0px 0px", a && (Yd(a, h, "xOrigin", f, w), Yd(a, h, "yOrigin", c, x), Yd(a, h, "xOffset", d, h.xOffset), Yd(a, h, "yOffset", p, h.yOffset)), t.setAttribute("data-svg-origin", w + " " + x);
  }
  function oe(t, e, r) {
    var i = Ya(e);
    return ia(parseFloat(e) + parseFloat(_d(t, "x", r + "px", i))) + i;
  }
  function ve(t, e, i, n, a) {
    var s,
      o,
      u = 360,
      h = r(a),
      l = parseFloat(a) * (h && ~a.indexOf("rad") ? sr : 1) - n,
      f = n + l + "deg";
    return h && ("short" === (s = a.split("_")[1]) && (l %= u) !== l % 180 && (l += l < 0 ? u : -u), "cw" === s && l < 0 ? l = (l + 36e9) % u - ~~(l / u) * u : "ccw" === s && 0 < l && (l = (l - 36e9) % u - ~~(l / u) * u)), t._pt = o = new _e(t._pt, e, i, n, l, wd), o.e = f, o.u = "deg", t._props.push(i), o;
  }
  function we(t, e) {
    for (var r in e) t[r] = e[r];
    return t;
  }
  function xe(t, e, r) {
    var i,
      n,
      a,
      s,
      o,
      u,
      h,
      l = we({}, r._gsap),
      f = r.style;
    for (n in l.svg ? (a = r.getAttribute("transform"), r.setAttribute("transform", ""), f[dr] = e, i = kr(r, 1), Xd(r, dr), r.setAttribute("transform", a)) : (a = getComputedStyle(r)[dr], f[dr] = e, i = kr(r, 1), f[dr] = a), ar) (a = l[n]) !== (s = i[n]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(n) < 0 && (o = Ya(a) !== (h = Ya(s)) ? _d(r, n, a, h) : parseFloat(a), u = parseFloat(s), t._pt = new _e(t._pt, i, n, o, u - o, vd), t._pt.u = h || 0, t._props.push(n));
    we(i, l);
  }
  var De,
    ze,
    Re,
    Fe,
    Be,
    Le,
    Ie,
    Ye,
    qe = Bt.Power0,
    Ve = Bt.Power1,
    Ue = Bt.Power2,
    Xe = Bt.Power3,
    Ne = Bt.Power4,
    We = Bt.Linear,
    Qe = Bt.Quad,
    Ge = Bt.Cubic,
    Ke = Bt.Quart,
    Je = Bt.Quint,
    He = Bt.Strong,
    Ze = Bt.Elastic,
    $e = Bt.Back,
    tr = Bt.SteppedEase,
    er = Bt.Bounce,
    rr = Bt.Sine,
    ir = Bt.Expo,
    nr = Bt.Circ,
    ar = {},
    sr = 180 / Math.PI,
    or = Math.PI / 180,
    ur = Math.atan2,
    hr = /([A-Z])/g,
    lr = /(left|right|width|margin|padding|x)/i,
    fr = /[\s,\(]\S/,
    cr = {
      autoAlpha: "opacity,visibility",
      scale: "scaleX,scaleY",
      alpha: "opacity"
    },
    dr = "transform",
    pr = dr + "Origin",
    _r = "O,Moz,ms,Ms,Webkit".split(","),
    mr = function _checkPropPrefix(t, e, r) {
      var i = (e || Be).style,
        n = 5;
      if (t in i && !r) return t;
      for (t = t.charAt(0).toUpperCase() + t.substr(1); n-- && !(_r[n] + t in i););
      return n < 0 ? null : (3 === n ? "ms" : 0 <= n ? _r[n] : "") + t;
    },
    gr = {
      deg: 1,
      rad: 1,
      turn: 1
    },
    vr = {
      grid: 1,
      flex: 1
    },
    yr = function _get(t, e, r, i) {
      var n;
      return Fe || Sd(), e in cr && "transform" !== e && ~(e = cr[e]).indexOf(",") && (e = e.split(",")[0]), ar[e] && "transform" !== e ? (n = kr(t, i), n = "transformOrigin" !== e ? n[e] : n.svg ? n.origin : Mr(Pd(t, pr)) + " " + n.zOrigin + "px") : (n = t.style[e]) && "auto" !== n && !i && !~(n + "").indexOf("calc(") || (n = br[e] && br[e](t, e, r) || Pd(t, e) || ga(t, e) || ("opacity" === e ? 1 : 0)), r && !~(n + "").trim().indexOf(" ") ? _d(t, e, n, r) + r : n;
    },
    Tr = {
      top: "0%",
      bottom: "100%",
      left: "0%",
      right: "100%",
      center: "50%"
    },
    br = {
      clearProps: function clearProps(t, e, r, i, n) {
        if ("isFromStart" !== n.data) {
          var a = t._pt = new _e(t._pt, e, r, 0, 0, ee);
          return a.u = i, a.pr = -10, a.tween = n, t._props.push(r), 1;
        }
      }
    },
    wr = [1, 0, 0, 1, 0, 0],
    xr = {},
    kr = function _parseTransform(t, e) {
      var r = t._gsap || new Vt(t);
      if ("x" in r && !e && !r.uncache) return r;
      var i,
        n,
        a,
        s,
        o,
        u,
        h,
        l,
        f,
        c,
        d,
        p,
        _,
        m,
        g,
        v,
        y,
        T,
        b,
        w,
        x,
        k,
        M,
        O,
        P,
        A,
        C,
        S,
        E,
        D,
        z,
        R,
        F = t.style,
        B = r.scaleX < 0,
        L = "deg",
        I = getComputedStyle(t),
        Y = Pd(t, pr) || "0";
      return i = n = a = u = h = l = f = c = d = 0, s = o = 1, r.svg = !(!t.getCTM || !Wd(t)), I.translate && ("none" === I.translate && "none" === I.scale && "none" === I.rotate || (F[dr] = ("none" !== I.translate ? "translate3d(" + (I.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + ("none" !== I.rotate ? "rotate(" + I.rotate + ") " : "") + ("none" !== I.scale ? "scale(" + I.scale.split(" ").join(",") + ") " : "") + ("none" !== I[dr] ? I[dr] : "")), F.scale = F.rotate = F.translate = "none"), m = ke(t, r.svg), r.svg && (O = r.uncache ? (P = t.getBBox(), Y = r.xOrigin - P.x + "px " + (r.yOrigin - P.y) + "px", "") : !e && t.getAttribute("data-svg-origin"), le(t, O || Y, !!O || r.originIsAbsolute, !1 !== r.smooth, m)), p = r.xOrigin || 0, _ = r.yOrigin || 0, m !== wr && (T = m[0], b = m[1], w = m[2], x = m[3], i = k = m[4], n = M = m[5], 6 === m.length ? (s = Math.sqrt(T * T + b * b), o = Math.sqrt(x * x + w * w), u = T || b ? ur(b, T) * sr : 0, (f = w || x ? ur(w, x) * sr + u : 0) && (o *= Math.abs(Math.cos(f * or))), r.svg && (i -= p - (p * T + _ * w), n -= _ - (p * b + _ * x))) : (R = m[6], D = m[7], C = m[8], S = m[9], E = m[10], z = m[11], i = m[12], n = m[13], a = m[14], h = (g = ur(R, E)) * sr, g && (O = k * (v = Math.cos(-g)) + C * (y = Math.sin(-g)), P = M * v + S * y, A = R * v + E * y, C = k * -y + C * v, S = M * -y + S * v, E = R * -y + E * v, z = D * -y + z * v, k = O, M = P, R = A), l = (g = ur(-w, E)) * sr, g && (v = Math.cos(-g), z = x * (y = Math.sin(-g)) + z * v, T = O = T * v - C * y, b = P = b * v - S * y, w = A = w * v - E * y), u = (g = ur(b, T)) * sr, g && (O = T * (v = Math.cos(g)) + b * (y = Math.sin(g)), P = k * v + M * y, b = b * v - T * y, M = M * v - k * y, T = O, k = P), h && 359.9 < Math.abs(h) + Math.abs(u) && (h = u = 0, l = 180 - l), s = ia(Math.sqrt(T * T + b * b + w * w)), o = ia(Math.sqrt(M * M + R * R)), g = ur(k, M), f = 2e-4 < Math.abs(g) ? g * sr : 0, d = z ? 1 / (z < 0 ? -z : z) : 0), r.svg && (O = t.getAttribute("transform"), r.forceCSS = t.setAttribute("transform", "") || !ie(Pd(t, dr)), O && t.setAttribute("transform", O))), 90 < Math.abs(f) && Math.abs(f) < 270 && (B ? (s *= -1, f += u <= 0 ? 180 : -180, u += u <= 0 ? 180 : -180) : (o *= -1, f += f <= 0 ? 180 : -180)), e = e || r.uncache, r.x = i - ((r.xPercent = i && (!e && r.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-i) ? -50 : 0))) ? t.offsetWidth * r.xPercent / 100 : 0) + "px", r.y = n - ((r.yPercent = n && (!e && r.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-n) ? -50 : 0))) ? t.offsetHeight * r.yPercent / 100 : 0) + "px", r.z = a + "px", r.scaleX = ia(s), r.scaleY = ia(o), r.rotation = ia(u) + L, r.rotationX = ia(h) + L, r.rotationY = ia(l) + L, r.skewX = f + L, r.skewY = c + L, r.transformPerspective = d + "px", (r.zOrigin = parseFloat(Y.split(" ")[2]) || 0) && (F[pr] = Mr(Y)), r.xOffset = r.yOffset = 0, r.force3D = q.force3D, r.renderTransform = r.svg ? Er : Ye ? Sr : Or, r.uncache = 0, r;
    },
    Mr = function _firstTwoOnly(t) {
      return (t = t.split(" "))[0] + " " + t[1];
    },
    Or = function _renderNon3DTransforms(t, e) {
      e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, Sr(t, e);
    },
    Pr = "0deg",
    Ar = "0px",
    Cr = ") ",
    Sr = function _renderCSSTransforms(t, e) {
      var r = e || this,
        i = r.xPercent,
        n = r.yPercent,
        a = r.x,
        s = r.y,
        o = r.z,
        u = r.rotation,
        h = r.rotationY,
        l = r.rotationX,
        f = r.skewX,
        c = r.skewY,
        d = r.scaleX,
        p = r.scaleY,
        _ = r.transformPerspective,
        m = r.force3D,
        g = r.target,
        v = r.zOrigin,
        y = "",
        T = "auto" === m && t && 1 !== t || !0 === m;
      if (v && (l !== Pr || h !== Pr)) {
        var b,
          w = parseFloat(h) * or,
          x = Math.sin(w),
          k = Math.cos(w);
        w = parseFloat(l) * or, b = Math.cos(w), a = oe(g, a, x * b * -v), s = oe(g, s, -Math.sin(w) * -v), o = oe(g, o, k * b * -v + v);
      }
      _ !== Ar && (y += "perspective(" + _ + Cr), (i || n) && (y += "translate(" + i + "%, " + n + "%) "), !T && a === Ar && s === Ar && o === Ar || (y += o !== Ar || T ? "translate3d(" + a + ", " + s + ", " + o + ") " : "translate(" + a + ", " + s + Cr), u !== Pr && (y += "rotate(" + u + Cr), h !== Pr && (y += "rotateY(" + h + Cr), l !== Pr && (y += "rotateX(" + l + Cr), f === Pr && c === Pr || (y += "skew(" + f + ", " + c + Cr), 1 === d && 1 === p || (y += "scale(" + d + ", " + p + Cr), g.style[dr] = y || "translate(0, 0)";
    },
    Er = function _renderSVGTransforms(t, e) {
      var r,
        i,
        n,
        a,
        s,
        o = e || this,
        u = o.xPercent,
        h = o.yPercent,
        l = o.x,
        f = o.y,
        c = o.rotation,
        d = o.skewX,
        p = o.skewY,
        _ = o.scaleX,
        m = o.scaleY,
        g = o.target,
        v = o.xOrigin,
        y = o.yOrigin,
        T = o.xOffset,
        b = o.yOffset,
        w = o.forceCSS,
        x = parseFloat(l),
        k = parseFloat(f);
      c = parseFloat(c), d = parseFloat(d), (p = parseFloat(p)) && (d += p = parseFloat(p), c += p), c || d ? (c *= or, d *= or, r = Math.cos(c) * _, i = Math.sin(c) * _, n = Math.sin(c - d) * -m, a = Math.cos(c - d) * m, d && (p *= or, s = Math.tan(d - p), n *= s = Math.sqrt(1 + s * s), a *= s, p && (s = Math.tan(p), r *= s = Math.sqrt(1 + s * s), i *= s)), r = ia(r), i = ia(i), n = ia(n), a = ia(a)) : (r = _, a = m, i = n = 0), (x && !~(l + "").indexOf("px") || k && !~(f + "").indexOf("px")) && (x = _d(g, "x", l, "px"), k = _d(g, "y", f, "px")), (v || y || T || b) && (x = ia(x + v - (v * r + y * n) + T), k = ia(k + y - (v * i + y * a) + b)), (u || h) && (s = g.getBBox(), x = ia(x + u / 100 * s.width), k = ia(k + h / 100 * s.height)), s = "matrix(" + r + "," + i + "," + n + "," + a + "," + x + "," + k + ")", g.setAttribute("transform", s), w && (g.style[dr] = s);
    };
  ha("padding,margin,Width,Radius", function (e, r) {
    var t = "Right",
      i = "Bottom",
      n = "Left",
      o = (r < 3 ? ["Top", t, i, n] : ["Top" + n, "Top" + t, i + t, i + n]).map(function (t) {
        return r < 2 ? e + t : "border" + t + e;
      });
    br[1 < r ? "border" + e : e] = function (e, t, r, i, n) {
      var a, s;
      if (arguments.length < 4) return a = o.map(function (t) {
        return yr(e, t, r);
      }), 5 === (s = a.join(" ")).split(a[0]).length ? a[0] : s;
      a = (i + "").split(" "), s = {}, o.forEach(function (t, e) {
        return s[t] = a[e] = a[e] || a[(e - 1) / 2 | 0];
      }), e.init(t, s, n);
    };
  });
  var Dr,
    zr,
    Rr,
    Fr = {
      name: "css",
      register: Sd,
      targetTest: function targetTest(t) {
        return t.style && t.nodeType;
      },
      init: function init(t, e, i, n, a) {
        var s,
          o,
          u,
          h,
          l,
          f,
          c,
          d,
          p,
          _,
          m,
          g,
          v,
          y,
          T,
          b,
          w = this._props,
          x = t.style,
          k = i.vars.startAt;
        for (c in Fe || Sd(), this.styles = this.styles || Md(t), b = this.styles.props, this.tween = i, e) if ("autoRound" !== c && (o = e[c], !pt[c] || !ac(c, e, i, n, t, a))) if (l = _typeof(o), f = br[c], "function" === l && (l = _typeof(o = o.call(i, n, t, a))), "string" === l && ~o.indexOf("random(") && (o = ob(o)), f) f(this, t, c, o, i) && (T = 1);else if ("--" === c.substr(0, 2)) s = (getComputedStyle(t).getPropertyValue(c) + "").trim(), o += "", Dt.lastIndex = 0, Dt.test(s) || (d = Ya(s), p = Ya(o)), p ? d !== p && (s = _d(t, c, s, p) + p) : d && (o += d), this.add(x, "setProperty", s, o, n, a, 0, 0, c), w.push(c), b.push(c, 0, x[c]);else if ("undefined" !== l) {
          if (k && c in k ? (s = "function" == typeof k[c] ? k[c].call(i, n, t, a) : k[c], r(s) && ~s.indexOf("random(") && (s = ob(s)), Ya(s + "") || (s += q.units[c] || Ya(yr(t, c)) || ""), "=" === (s + "").charAt(1) && (s = yr(t, c))) : s = yr(t, c), h = parseFloat(s), (_ = "string" === l && "=" === o.charAt(1) && o.substr(0, 2)) && (o = o.substr(2)), u = parseFloat(o), c in cr && ("autoAlpha" === c && (1 === h && "hidden" === yr(t, "visibility") && u && (h = 0), b.push("visibility", 0, x.visibility), Yd(this, x, "visibility", h ? "inherit" : "hidden", u ? "inherit" : "hidden", !u)), "scale" !== c && "transform" !== c && ~(c = cr[c]).indexOf(",") && (c = c.split(",")[0])), m = c in ar) {
            if (this.styles.save(c), g || ((v = t._gsap).renderTransform && !e.parseTransform || kr(t, e.parseTransform), y = !1 !== e.smoothOrigin && v.smooth, (g = this._pt = new _e(this._pt, x, dr, 0, 1, v.renderTransform, v, 0, -1)).dep = 1), "scale" === c) this._pt = new _e(this._pt, v, "scaleY", v.scaleY, (_ ? ka(v.scaleY, _ + u) : u) - v.scaleY || 0, vd), this._pt.u = 0, w.push("scaleY", c), c += "X";else {
              if ("transformOrigin" === c) {
                b.push(pr, 0, x[pr]), o = de(o), v.svg ? le(t, o, 0, y, 0, this) : ((p = parseFloat(o.split(" ")[2]) || 0) !== v.zOrigin && Yd(this, v, "zOrigin", v.zOrigin, p), Yd(this, x, c, Mr(s), Mr(o)));
                continue;
              }
              if ("svgOrigin" === c) {
                le(t, o, 1, y, 0, this);
                continue;
              }
              if (c in xr) {
                ve(this, v, c, h, _ ? ka(h, _ + o) : o);
                continue;
              }
              if ("smoothOrigin" === c) {
                Yd(this, v, "smooth", v.smooth, o);
                continue;
              }
              if ("force3D" === c) {
                v[c] = o;
                continue;
              }
              if ("transform" === c) {
                xe(this, o, t);
                continue;
              }
            }
          } else c in x || (c = mr(c) || c);
          if (m || (u || 0 === u) && (h || 0 === h) && !fr.test(o) && c in x) u = u || 0, (d = (s + "").substr((h + "").length)) !== (p = Ya(o) || (c in q.units ? q.units[c] : d)) && (h = _d(t, c, s, p)), this._pt = new _e(this._pt, m ? v : x, c, h, (_ ? ka(h, _ + u) : u) - h, m || "px" !== p && "zIndex" !== c || !1 === e.autoRound ? vd : yd), this._pt.u = p || 0, d !== p && "%" !== p && (this._pt.b = s, this._pt.r = xd);else if (c in x) be.call(this, t, c, s, _ ? _ + o : o);else if (c in t) this.add(t, c, s || t[c], _ ? _ + o : o, n, a);else if ("parseTransform" !== c) {
            Q(c, o);
            continue;
          }
          m || (c in x ? b.push(c, 0, x[c]) : b.push(c, 1, s || t[c])), w.push(c);
        }
        T && pe(this);
      },
      render: function render(t, e) {
        if (e.tween._time || !Ie()) for (var r = e._pt; r;) r.r(t, r.d), r = r._next;else e.styles.revert();
      },
      get: yr,
      aliases: cr,
      getSetter: function getSetter(t, e, r) {
        var i = cr[e];
        return i && i.indexOf(",") < 0 && (e = i), e in ar && e !== pr && (t._gsap.x || yr(t, "x")) ? r && Le === r ? "scale" === e ? Ed : Dd : (Le = r || {}) && ("scale" === e ? Fd : Gd) : t.style && !u(t.style[e]) ? Bd : ~e.indexOf("-") ? Cd : ne(t, e);
      },
      core: {
        _removeProperty: Xd,
        _getMatrix: ke
      }
    };
  Ee.utils.checkPrefix = mr, Ee.core.getStyleSaver = Md, Rr = ha((Dr = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (zr = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", function (t) {
    ar[t] = 1;
  }), ha(zr, function (t) {
    q.units[t] = "deg", xr[t] = 1;
  }), cr[Rr[13]] = Dr + "," + zr, ha("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", function (t) {
    var e = t.split(":");
    cr[e[1]] = Rr[e[0]];
  }), ha("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (t) {
    q.units[t] = "px";
  }), Ee.registerPlugin(Fr);
  var Br = Ee.registerPlugin(Fr) || Ee,
    Lr = Br.core.Tween;
  e.Back = $e, e.Bounce = er, e.CSSPlugin = Fr, e.Circ = nr, e.Cubic = Ge, e.Elastic = Ze, e.Expo = ir, e.Linear = We, e.Power0 = qe, e.Power1 = Ve, e.Power2 = Ue, e.Power3 = Xe, e.Power4 = Ne, e.Quad = Qe, e.Quart = Ke, e.Quint = Je, e.Sine = rr, e.SteppedEase = tr, e.Strong = He, e.TimelineLite = Xt, e.TimelineMax = Xt, e.TweenLite = Zt, e.TweenMax = Lr, e.default = Br, e.gsap = Br;
  if (typeof window === "undefined" || window !== e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    });
  } else {
    delete e.default;
  }
});

},{}],26:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
/*!
 * ScrollToPlugin 3.12.1
 * https://greensock.com
 *
 * @license Copyright 2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */

!function (e, t) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = e || self).window = e.window || {});
}(void 0, function (e) {
  "use strict";

  function l() {
    return "undefined" != typeof window;
  }
  function m() {
    return f || l() && (f = window.gsap) && f.registerPlugin && f;
  }
  function n(e) {
    return "string" == typeof e;
  }
  function o(e) {
    return "function" == typeof e;
  }
  function p(e, t) {
    var o = "x" === t ? "Width" : "Height",
      n = "scroll" + o,
      l = "client" + o;
    return e === T || e === i || e === c ? Math.max(i[n], c[n]) - (T["inner" + o] || i[l] || c[l]) : e[n] - e["offset" + o];
  }
  function q(e, t) {
    var o = "scroll" + ("x" === t ? "Left" : "Top");
    return e === T && (null != e.pageXOffset ? o = "page" + t.toUpperCase() + "Offset" : e = null != i[o] ? i : c), function () {
      return e[o];
    };
  }
  function s(e, t) {
    if (!(e = y(e)[0]) || !e.getBoundingClientRect) return console.warn("scrollTo target doesn't exist. Using 0") || {
      x: 0,
      y: 0
    };
    var o = e.getBoundingClientRect(),
      n = !t || t === T || t === c,
      l = n ? {
        top: i.clientTop - (T.pageYOffset || i.scrollTop || c.scrollTop || 0),
        left: i.clientLeft - (T.pageXOffset || i.scrollLeft || c.scrollLeft || 0)
      } : t.getBoundingClientRect(),
      r = {
        x: o.left - l.left,
        y: o.top - l.top
      };
    return !n && t && (r.x += q(t, "x")(), r.y += q(t, "y")()), r;
  }
  function t(e, t, o, l, r) {
    return isNaN(e) || "object" == _typeof(e) ? n(e) && "=" === e.charAt(1) ? parseFloat(e.substr(2)) * ("-" === e.charAt(0) ? -1 : 1) + l - r : "max" === e ? p(t, o) - r : Math.min(p(t, o), s(e, t)[o] - r) : parseFloat(e) - r;
  }
  function u() {
    f = m(), l() && f && "undefined" != typeof document && document.body && (T = window, c = document.body, i = document.documentElement, y = f.utils.toArray, f.config({
      autoKillThreshold: 7
    }), v = f.config(), a = 1);
  }
  var f,
    a,
    T,
    i,
    c,
    y,
    v,
    h,
    r = {
      version: "3.12.1",
      name: "scrollTo",
      rawVars: 1,
      register: function register(e) {
        f = e, u();
      },
      init: function init(e, l, r, s, i) {
        a || u();
        var p = this,
          c = f.getProperty(e, "scrollSnapType");
        p.isWin = e === T, p.target = e, p.tween = r, l = function _clean(e, t, l, r) {
          if (o(e) && (e = e(t, l, r)), "object" != _typeof(e)) return n(e) && "max" !== e && "=" !== e.charAt(1) ? {
            x: e,
            y: e
          } : {
            y: e
          };
          if (e.nodeType) return {
            y: e,
            x: e
          };
          var s,
            i = {};
          for (s in e) i[s] = "onAutoKill" !== s && o(e[s]) ? e[s](t, l, r) : e[s];
          return i;
        }(l, s, e, i), p.vars = l, p.autoKill = !!l.autoKill, p.getX = q(e, "x"), p.getY = q(e, "y"), p.x = p.xPrev = p.getX(), p.y = p.yPrev = p.getY(), h = h || f.core.globals().ScrollTrigger, "smooth" === f.getProperty(e, "scrollBehavior") && f.set(e, {
          scrollBehavior: "auto"
        }), c && "none" !== c && (p.snap = 1, p.snapInline = e.style.scrollSnapType, e.style.scrollSnapType = "none"), null != l.x ? (p.add(p, "x", p.x, t(l.x, e, "x", p.x, l.offsetX || 0), s, i), p._props.push("scrollTo_x")) : p.skipX = 1, null != l.y ? (p.add(p, "y", p.y, t(l.y, e, "y", p.y, l.offsetY || 0), s, i), p._props.push("scrollTo_y")) : p.skipY = 1;
      },
      render: function render(e, t) {
        for (var o, n, l, r, s, i = t._pt, c = t.target, u = t.tween, f = t.autoKill, a = t.xPrev, y = t.yPrev, d = t.isWin, g = t.snap, x = t.snapInline; i;) i.r(e, i.d), i = i._next;
        o = d || !t.skipX ? t.getX() : a, l = (n = d || !t.skipY ? t.getY() : y) - y, r = o - a, s = v.autoKillThreshold, t.x < 0 && (t.x = 0), t.y < 0 && (t.y = 0), f && (!t.skipX && (s < r || r < -s) && o < p(c, "x") && (t.skipX = 1), !t.skipY && (s < l || l < -s) && n < p(c, "y") && (t.skipY = 1), t.skipX && t.skipY && (u.kill(), t.vars.onAutoKill && t.vars.onAutoKill.apply(u, t.vars.onAutoKillParams || []))), d ? T.scrollTo(t.skipX ? o : t.x, t.skipY ? n : t.y) : (t.skipY || (c.scrollTop = t.y), t.skipX || (c.scrollLeft = t.x)), !g || 1 !== e && 0 !== e || (n = c.scrollTop, o = c.scrollLeft, x ? c.style.scrollSnapType = x : c.style.removeProperty("scroll-snap-type"), c.scrollTop = n + 1, c.scrollLeft = o + 1, c.scrollTop = n, c.scrollLeft = o), t.xPrev = t.x, t.yPrev = t.y, h && h.update();
      },
      kill: function kill(e) {
        var t = "scrollTo" === e;
        !t && "scrollTo_x" !== e || (this.skipX = 1), !t && "scrollTo_y" !== e || (this.skipY = 1);
      }
    };
  r.max = p, r.getOffset = s, r.buildGetter = q, m() && f.registerPlugin(r), e.ScrollToPlugin = r, e.default = r;
  if (typeof window === "undefined" || window !== e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    });
  } else {
    delete e.default;
  }
});

},{}],27:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
/*!
 * ScrollTrigger 3.12.1
 * https://greensock.com
 *
 * @license Copyright 2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */

!function (e, t) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = e || self).window = e.window || {});
}(void 0, function (e) {
  "use strict";

  function _defineProperties(e, t) {
    for (var r = 0; r < t.length; r++) {
      var n = t[r];
      n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
    }
  }
  function r() {
    return Se || "undefined" != typeof window && (Se = window.gsap) && Se.registerPlugin && Se;
  }
  function z(e, t) {
    return ~ze.indexOf(e) && ze[ze.indexOf(e) + 1][t];
  }
  function A(e) {
    return !!~t.indexOf(e);
  }
  function B(e, t, r, n, i) {
    return e.addEventListener(t, r, {
      passive: !n,
      capture: !!i
    });
  }
  function C(e, t, r, n) {
    return e.removeEventListener(t, r, !!n);
  }
  function F() {
    return De && De.isPressed || qe.cache++;
  }
  function G(r, n) {
    function Yc(e) {
      if (e || 0 === e) {
        i && (Te.history.scrollRestoration = "manual");
        var t = De && De.isPressed;
        e = Yc.v = Math.round(e) || (De && De.iOS ? 1 : 0), r(e), Yc.cacheID = qe.cache, t && o("ss", e);
      } else (n || qe.cache !== Yc.cacheID || o("ref")) && (Yc.cacheID = qe.cache, Yc.v = r());
      return Yc.v + Yc.offset;
    }
    return Yc.offset = 0, r && Yc;
  }
  function J(e, t) {
    return (t && t._ctx && t._ctx.selector || Se.utils.toArray)(e)[0] || ("string" == typeof e && !1 !== Se.config().nullTargetWarn ? console.warn("Element not found:", e) : null);
  }
  function K(t, e) {
    var r = e.s,
      n = e.sc;
    A(t) && (t = ke.scrollingElement || Ee);
    var i = qe.indexOf(t),
      o = n === Ie.sc ? 1 : 2;
    ~i || (i = qe.push(t) - 1), qe[i + o] || t.addEventListener("scroll", F);
    var a = qe[i + o],
      s = a || (qe[i + o] = G(z(t, r), !0) || (A(t) ? n : G(function (e) {
        return arguments.length ? t[r] = e : t[r];
      })));
    return s.target = t, a || (s.smooth = "smooth" === Se.getProperty(t, "scrollBehavior")), s;
  }
  function L(e, t, i) {
    function vd(e, t) {
      var r = Fe();
      t || n < r - s ? (a = o, o = e, l = s, s = r) : i ? o += e : o = a + (e - a) / (r - l) * (s - l);
    }
    var o = e,
      a = e,
      s = Fe(),
      l = s,
      n = t || 50,
      c = Math.max(500, 3 * n);
    return {
      update: vd,
      reset: function reset() {
        a = o = i ? 0 : o, l = s = 0;
      },
      getVelocity: function getVelocity(e) {
        var t = l,
          r = a,
          n = Fe();
        return !e && 0 !== e || e === o || vd(e), s === l || c < n - l ? 0 : (o + (i ? r : -r)) / ((i ? n : s) - t) * 1e3;
      }
    };
  }
  function M(e, t) {
    return t && !e._gsapAllow && e.preventDefault(), e.changedTouches ? e.changedTouches[0] : e;
  }
  function N(e) {
    var t = Math.max.apply(Math, e),
      r = Math.min.apply(Math, e);
    return Math.abs(t) >= Math.abs(r) ? t : r;
  }
  function O() {
    (Ae = Se.core.globals().ScrollTrigger) && Ae.core && function _integrate() {
      var e = Ae.core,
        r = e.bridge || {},
        t = e._scrollers,
        n = e._proxies;
      t.push.apply(t, qe), n.push.apply(n, ze), qe = t, ze = n, o = function _bridge(e, t) {
        return r[e](t);
      };
    }();
  }
  function P(e) {
    return (Se = e || r()) && "undefined" != typeof document && document.body && (Te = window, Ee = (ke = document).documentElement, Pe = ke.body, t = [Te, ke, Ee, Pe], Se.utils.clamp, Be = Se.core.context || function () {}, Oe = "onpointerenter" in Pe ? "pointer" : "mouse", Me = k.isTouch = Te.matchMedia && Te.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in Te || 0 < navigator.maxTouchPoints || 0 < navigator.msMaxTouchPoints ? 2 : 0, Re = k.eventTypes = ("ontouchstart" in Ee ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in Ee ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout(function () {
      return i = 0;
    }, 500), O(), Ce = 1), Ce;
  }
  var Se,
    Ce,
    Te,
    ke,
    Ee,
    Pe,
    Me,
    Oe,
    Ae,
    t,
    De,
    Re,
    Be,
    i = 1,
    Ye = [],
    qe = [],
    ze = [],
    Fe = Date.now,
    o = function _bridge(e, t) {
      return t;
    },
    n = "scrollLeft",
    a = "scrollTop",
    Le = {
      s: n,
      p: "left",
      p2: "Left",
      os: "right",
      os2: "Right",
      d: "width",
      d2: "Width",
      a: "x",
      sc: G(function (e) {
        return arguments.length ? Te.scrollTo(e, Ie.sc()) : Te.pageXOffset || ke[n] || Ee[n] || Pe[n] || 0;
      })
    },
    Ie = {
      s: a,
      p: "top",
      p2: "Top",
      os: "bottom",
      os2: "Bottom",
      d: "height",
      d2: "Height",
      a: "y",
      op: Le,
      sc: G(function (e) {
        return arguments.length ? Te.scrollTo(Le.sc(), e) : Te.pageYOffset || ke[a] || Ee[a] || Pe[a] || 0;
      })
    };
  Le.op = Ie, qe.cache = 0;
  var k = (Observer.prototype.init = function init(e) {
    Ce || P(Se) || console.warn("Please gsap.registerPlugin(Observer)"), Ae || O();
    var i = e.tolerance,
      a = e.dragMinimum,
      t = e.type,
      o = e.target,
      r = e.lineHeight,
      n = e.debounce,
      s = e.preventDefault,
      l = e.onStop,
      c = e.onStopDelay,
      u = e.ignore,
      f = e.wheelSpeed,
      p = e.event,
      d = e.onDragStart,
      h = e.onDragEnd,
      g = e.onDrag,
      v = e.onPress,
      b = e.onRelease,
      m = e.onRight,
      y = e.onLeft,
      x = e.onUp,
      _ = e.onDown,
      w = e.onChangeX,
      S = e.onChangeY,
      T = e.onChange,
      k = e.onToggleX,
      E = e.onToggleY,
      D = e.onHover,
      R = e.onHoverEnd,
      Y = e.onMove,
      q = e.ignoreCheck,
      z = e.isNormalizer,
      I = e.onGestureStart,
      X = e.onGestureEnd,
      H = e.onWheel,
      W = e.onEnable,
      G = e.onDisable,
      j = e.onClick,
      V = e.scrollSpeed,
      U = e.capture,
      Q = e.allowClicks,
      Z = e.lockAxis,
      $ = e.onLockAxis;
    function We() {
      return ye = Fe();
    }
    function Xe(e, t) {
      return (se.event = e) && u && ~u.indexOf(e.target) || t && he && "touch" !== e.pointerType || q && q(e, t);
    }
    function Ze() {
      var e = se.deltaX = N(be),
        t = se.deltaY = N(me),
        r = Math.abs(e) >= i,
        n = Math.abs(t) >= i;
      T && (r || n) && T(se, e, t, be, me), r && (m && 0 < se.deltaX && m(se), y && se.deltaX < 0 && y(se), w && w(se), k && se.deltaX < 0 != le < 0 && k(se), le = se.deltaX, be[0] = be[1] = be[2] = 0), n && (_ && 0 < se.deltaY && _(se), x && se.deltaY < 0 && x(se), S && S(se), E && se.deltaY < 0 != ce < 0 && E(se), ce = se.deltaY, me[0] = me[1] = me[2] = 0), (ne || re) && (Y && Y(se), re && (g(se), re = !1), ne = !1), oe && !(oe = !1) && $ && $(se), ie && (H(se), ie = !1), ee = 0;
    }
    function $e(e, t, r) {
      be[r] += e, me[r] += t, se._vx.update(e), se._vy.update(t), n ? ee = ee || requestAnimationFrame(Ze) : Ze();
    }
    function _e(e, t) {
      Z && !ae && (se.axis = ae = Math.abs(e) > Math.abs(t) ? "x" : "y", oe = !0), "y" !== ae && (be[2] += e, se._vx.update(e, !0)), "x" !== ae && (me[2] += t, se._vy.update(t, !0)), n ? ee = ee || requestAnimationFrame(Ze) : Ze();
    }
    function af(e) {
      if (!Xe(e, 1)) {
        var t = (e = M(e, s)).clientX,
          r = e.clientY,
          n = t - se.x,
          i = r - se.y,
          o = se.isDragging;
        se.x = t, se.y = r, (o || Math.abs(se.startX - t) >= a || Math.abs(se.startY - r) >= a) && (g && (re = !0), o || (se.isDragging = !0), _e(n, i), o || d && d(se));
      }
    }
    function df(e) {
      return e.touches && 1 < e.touches.length && (se.isGesturing = !0) && I(e, se.isDragging);
    }
    function ef() {
      return (se.isGesturing = !1) || X(se);
    }
    function ff(e) {
      if (!Xe(e)) {
        var t = ue(),
          r = fe();
        $e((t - pe) * V, (r - de) * V, 1), pe = t, de = r, l && te.restart(!0);
      }
    }
    function gf(e) {
      if (!Xe(e)) {
        e = M(e, s), H && (ie = !0);
        var t = (1 === e.deltaMode ? r : 2 === e.deltaMode ? Te.innerHeight : 1) * f;
        $e(e.deltaX * t, e.deltaY * t, 0), l && !z && te.restart(!0);
      }
    }
    function hf(e) {
      if (!Xe(e)) {
        var t = e.clientX,
          r = e.clientY,
          n = t - se.x,
          i = r - se.y;
        se.x = t, se.y = r, ne = !0, (n || i) && _e(n, i);
      }
    }
    function jf(e) {
      se.event = e, D(se);
    }
    function kf(e) {
      se.event = e, R(se);
    }
    function lf(e) {
      return Xe(e) || M(e, s) && j(se);
    }
    this.target = o = J(o) || Ee, this.vars = e, u = u && Se.utils.toArray(u), i = i || 1e-9, a = a || 0, f = f || 1, V = V || 1, t = t || "wheel,touch,pointer", n = !1 !== n, r = r || parseFloat(Te.getComputedStyle(Pe).lineHeight) || 22;
    var ee,
      te,
      re,
      ne,
      ie,
      oe,
      ae,
      se = this,
      le = 0,
      ce = 0,
      ue = K(o, Le),
      fe = K(o, Ie),
      pe = ue(),
      de = fe(),
      he = ~t.indexOf("touch") && !~t.indexOf("pointer") && "pointerdown" === Re[0],
      ge = A(o),
      ve = o.ownerDocument || ke,
      be = [0, 0, 0],
      me = [0, 0, 0],
      ye = 0,
      xe = se.onPress = function (e) {
        Xe(e, 1) || e && e.button || (se.axis = ae = null, te.pause(), se.isPressed = !0, e = M(e), le = ce = 0, se.startX = se.x = e.clientX, se.startY = se.y = e.clientY, se._vx.reset(), se._vy.reset(), B(z ? o : ve, Re[1], af, s, !0), se.deltaX = se.deltaY = 0, v && v(se));
      },
      we = se.onRelease = function (t) {
        if (!Xe(t, 1)) {
          C(z ? o : ve, Re[1], af, !0);
          var e = !isNaN(se.y - se.startY),
            r = se.isDragging && (3 < Math.abs(se.x - se.startX) || 3 < Math.abs(se.y - se.startY)),
            n = M(t);
          !r && e && (se._vx.reset(), se._vy.reset(), s && Q && Se.delayedCall(.08, function () {
            if (300 < Fe() - ye && !t.defaultPrevented) if (t.target.click) t.target.click();else if (ve.createEvent) {
              var e = ve.createEvent("MouseEvents");
              e.initMouseEvent("click", !0, !0, Te, 1, n.screenX, n.screenY, n.clientX, n.clientY, !1, !1, !1, !1, 0, null), t.target.dispatchEvent(e);
            }
          })), se.isDragging = se.isGesturing = se.isPressed = !1, l && !z && te.restart(!0), h && r && h(se), b && b(se, r);
        }
      };
    te = se._dc = Se.delayedCall(c || .25, function onStopFunc() {
      se._vx.reset(), se._vy.reset(), te.pause(), l && l(se);
    }).pause(), se.deltaX = se.deltaY = 0, se._vx = L(0, 50, !0), se._vy = L(0, 50, !0), se.scrollX = ue, se.scrollY = fe, se.isDragging = se.isGesturing = se.isPressed = !1, Be(this), se.enable = function (e) {
      return se.isEnabled || (B(ge ? ve : o, "scroll", F), 0 <= t.indexOf("scroll") && B(ge ? ve : o, "scroll", ff, s, U), 0 <= t.indexOf("wheel") && B(o, "wheel", gf, s, U), (0 <= t.indexOf("touch") && Me || 0 <= t.indexOf("pointer")) && (B(o, Re[0], xe, s, U), B(ve, Re[2], we), B(ve, Re[3], we), Q && B(o, "click", We, !1, !0), j && B(o, "click", lf), I && B(ve, "gesturestart", df), X && B(ve, "gestureend", ef), D && B(o, Oe + "enter", jf), R && B(o, Oe + "leave", kf), Y && B(o, Oe + "move", hf)), se.isEnabled = !0, e && e.type && xe(e), W && W(se)), se;
    }, se.disable = function () {
      se.isEnabled && (Ye.filter(function (e) {
        return e !== se && A(e.target);
      }).length || C(ge ? ve : o, "scroll", F), se.isPressed && (se._vx.reset(), se._vy.reset(), C(z ? o : ve, Re[1], af, !0)), C(ge ? ve : o, "scroll", ff, U), C(o, "wheel", gf, U), C(o, Re[0], xe, U), C(ve, Re[2], we), C(ve, Re[3], we), C(o, "click", We, !0), C(o, "click", lf), C(ve, "gesturestart", df), C(ve, "gestureend", ef), C(o, Oe + "enter", jf), C(o, Oe + "leave", kf), C(o, Oe + "move", hf), se.isEnabled = se.isPressed = se.isDragging = !1, G && G(se));
    }, se.kill = se.revert = function () {
      se.disable();
      var e = Ye.indexOf(se);
      0 <= e && Ye.splice(e, 1), De === se && (De = 0);
    }, Ye.push(se), z && A(o) && (De = se), se.enable(p);
  }, function _createClass(e, t, r) {
    return t && _defineProperties(e.prototype, t), r && _defineProperties(e, r), e;
  }(Observer, [{
    key: "velocityX",
    get: function get() {
      return this._vx.getVelocity();
    }
  }, {
    key: "velocityY",
    get: function get() {
      return this._vy.getVelocity();
    }
  }]), Observer);
  function Observer(e) {
    this.init(e);
  }
  k.version = "3.12.1", k.create = function (e) {
    return new k(e);
  }, k.register = P, k.getAll = function () {
    return Ye.slice();
  }, k.getById = function (t) {
    return Ye.filter(function (e) {
      return e.vars.id === t;
    })[0];
  }, r() && Se.registerPlugin(k);
  function ya(e, t, r) {
    var n = pt(e) && ("clamp(" === e.substr(0, 6) || -1 < e.indexOf("max"));
    return (r["_" + t + "Clamp"] = n) ? e.substr(6, e.length - 7) : e;
  }
  function za(e, t) {
    return !t || pt(e) && "clamp(" === e.substr(0, 6) ? e : "clamp(" + e + ")";
  }
  function Ba() {
    return et = 1;
  }
  function Ca() {
    return et = 0;
  }
  function Da(e) {
    return e;
  }
  function Ea(e) {
    return Math.round(1e5 * e) / 1e5 || 0;
  }
  function Fa() {
    return "undefined" != typeof window;
  }
  function Ga() {
    return Ne || Fa() && (Ne = window.gsap) && Ne.registerPlugin && Ne;
  }
  function Ha(e) {
    return !!~l.indexOf(e);
  }
  function Ia(e) {
    return z(e, "getBoundingClientRect") || (Ha(e) ? function () {
      return Rt.width = He.innerWidth, Rt.height = He.innerHeight, Rt;
    } : function () {
      return Ct(e);
    });
  }
  function La(e, t) {
    var r = t.s,
      n = t.d2,
      i = t.d,
      o = t.a;
    return Math.max(0, (r = "scroll" + n) && (o = z(e, r)) ? o() - Ia(e)()[i] : Ha(e) ? (je[r] || Je[r]) - (He["inner" + n] || je["client" + n] || Je["client" + n]) : e[r] - e["offset" + n]);
  }
  function Ma(e, t) {
    for (var r = 0; r < h.length; r += 3) t && !~t.indexOf(h[r + 1]) || e(h[r], h[r + 1], h[r + 2]);
  }
  function Oa(e) {
    return "function" == typeof e;
  }
  function Pa(e) {
    return "number" == typeof e;
  }
  function Qa(e) {
    return "object" == _typeof(e);
  }
  function Ra(e, t, r) {
    return e && e.progress(t ? 0 : 1) && r && e.pause();
  }
  function Sa(e, t) {
    if (e.enabled) {
      var r = t(e);
      r && r.totalTime && (e.callbackAnimation = r);
    }
  }
  function hb(e) {
    return He.getComputedStyle(e);
  }
  function jb(e, t) {
    for (var r in t) r in e || (e[r] = t[r]);
    return e;
  }
  function lb(e, t) {
    var r = t.d2;
    return e["offset" + r] || e["client" + r] || 0;
  }
  function mb(e) {
    var t,
      r = [],
      n = e.labels,
      i = e.duration();
    for (t in n) r.push(n[t] / i);
    return r;
  }
  function ob(i) {
    var o = Ne.utils.snap(i),
      a = Array.isArray(i) && i.slice(0).sort(function (e, t) {
        return e - t;
      });
    return a ? function (e, t, r) {
      var n;
      if (void 0 === r && (r = .001), !t) return o(e);
      if (0 < t) {
        for (e -= r, n = 0; n < a.length; n++) if (a[n] >= e) return a[n];
        return a[n - 1];
      }
      for (n = a.length, e += r; n--;) if (a[n] <= e) return a[n];
      return a[0];
    } : function (e, t, r) {
      void 0 === r && (r = .001);
      var n = o(e);
      return !t || Math.abs(n - e) < r || n - e < 0 == t < 0 ? n : o(t < 0 ? e - i : e + i);
    };
  }
  function qb(t, r, e, n) {
    return e.split(",").forEach(function (e) {
      return t(r, e, n);
    });
  }
  function rb(e, t, r, n, i) {
    return e.addEventListener(t, r, {
      passive: !n,
      capture: !!i
    });
  }
  function sb(e, t, r, n) {
    return e.removeEventListener(t, r, !!n);
  }
  function tb(e, t, r) {
    (r = r && r.wheelHandler) && (e(t, "wheel", r), e(t, "touchmove", r));
  }
  function xb(e, t) {
    if (pt(e)) {
      var r = e.indexOf("="),
        n = ~r ? (e.charAt(r - 1) + 1) * parseFloat(e.substr(r + 1)) : 0;
      ~r && (e.indexOf("%") > r && (n *= t / 100), e = e.substr(0, r - 1)), e = n + (e in Y ? Y[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0);
    }
    return e;
  }
  function yb(e, t, r, n, i, o, a, s) {
    var l = i.startColor,
      c = i.endColor,
      u = i.fontSize,
      f = i.indent,
      p = i.fontWeight,
      d = Ge.createElement("div"),
      h = Ha(r) || "fixed" === z(r, "pinType"),
      g = -1 !== e.indexOf("scroller"),
      v = h ? Je : r,
      b = -1 !== e.indexOf("start"),
      m = b ? l : c,
      y = "border-color:" + m + ";font-size:" + u + ";color:" + m + ";font-weight:" + p + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
    return y += "position:" + ((g || s) && h ? "fixed;" : "absolute;"), !g && !s && h || (y += (n === Ie ? T : D) + ":" + (o + parseFloat(f)) + "px;"), a && (y += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"), d._isStart = b, d.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")), d.style.cssText = y, d.innerText = t || 0 === t ? e + "-" + t : e, v.children[0] ? v.insertBefore(d, v.children[0]) : v.appendChild(d), d._offset = d["offset" + n.op.d2], q(d, 0, n, b), d;
  }
  function Db() {
    return 34 < ct() - ut && (w = w || requestAnimationFrame(V));
  }
  function Eb() {
    v && v.isPressed && !(v.startX > Je.clientWidth) || (qe.cache++, v ? w = w || requestAnimationFrame(V) : V(), ut || H("scrollStart"), ut = ct());
  }
  function Fb() {
    y = He.innerWidth, m = He.innerHeight;
  }
  function Gb() {
    qe.cache++, Qe || g || Ge.fullscreenElement || Ge.webkitFullscreenElement || b && y === He.innerWidth && !(Math.abs(He.innerHeight - m) > .25 * He.innerHeight) || c.restart(!0);
  }
  function Jb() {
    return sb(ee, "scrollEnd", Jb) || Ot(!0);
  }
  function Mb(e) {
    for (var t = 0; t < W.length; t += 5) (!e || W[t + 4] && W[t + 4].query === e) && (W[t].style.cssText = W[t + 1], W[t].getBBox && W[t].setAttribute("transform", W[t + 2] || ""), W[t + 3].uncache = 1);
  }
  function Nb(e, t) {
    var r;
    for (tt = 0; tt < Et.length; tt++) !(r = Et[tt]) || t && r._ctx !== t || (e ? r.kill(1) : r.revert(!0, !0));
    t && Mb(t), t || H("revert");
  }
  function Ob(e, t) {
    qe.cache++, !t && ot || qe.forEach(function (e) {
      return Oa(e) && e.cacheID++ && (e.rec = 0);
    }), pt(e) && (He.history.scrollRestoration = _ = e);
  }
  function _b(e, t, r, n) {
    if (!e._gsap.swappedIn) {
      for (var i, o = U.length, a = t.style, s = e.style; o--;) a[i = U[o]] = r[i];
      a.position = "absolute" === r.position ? "absolute" : "relative", "inline" === r.display && (a.display = "inline-block"), s[D] = s[T] = "auto", a.flexBasis = r.flexBasis || "auto", a.overflow = "visible", a.boxSizing = "border-box", a[ht] = lb(e, Le) + St, a[gt] = lb(e, Ie) + St, a[xt] = s[_t] = s.top = s.left = "0", Dt(n), s[ht] = s.maxWidth = r[ht], s[gt] = s.maxHeight = r[gt], s[xt] = r[xt], e.parentNode !== t && (e.parentNode.insertBefore(t, e), t.appendChild(e)), e._gsap.swappedIn = !0;
    }
  }
  function cc(e) {
    for (var t = Q.length, r = e.style, n = [], i = 0; i < t; i++) n.push(Q[i], r[Q[i]]);
    return n.t = e, n;
  }
  function fc(e, t, r, n, i, o, a, s, l, c, u, f, p, d) {
    Oa(e) && (e = e(s)), pt(e) && "max" === e.substr(0, 3) && (e = f + ("=" === e.charAt(4) ? xb("0" + e.substr(3), r) : 0));
    var h,
      g,
      v,
      b = p ? p.time() : 0;
    if (p && p.seek(0), isNaN(e) || (e = +e), Pa(e)) p && (e = Ne.utils.mapRange(p.scrollTrigger.start, p.scrollTrigger.end, 0, f, e)), a && q(a, r, n, !0);else {
      Oa(t) && (t = t(s));
      var m,
        y,
        x,
        _,
        w = (e || "0").split(" ");
      v = J(t, s) || Je, (m = Ct(v) || {}) && (m.left || m.top) || "none" !== hb(v).display || (_ = v.style.display, v.style.display = "block", m = Ct(v), _ ? v.style.display = _ : v.style.removeProperty("display")), y = xb(w[0], m[n.d]), x = xb(w[1] || "0", r), e = m[n.p] - l[n.p] - c + y + i - x, a && q(a, x, n, r - x < 20 || a._isStart && 20 < x), r -= r - x;
    }
    if (d && (s[d] = e || -.001, e < 0 && (e = 0)), o) {
      var S = e + r,
        C = o._isStart;
      h = "scroll" + n.d2, q(o, S, n, C && 20 < S || !C && (u ? Math.max(Je[h], je[h]) : o.parentNode[h]) <= S + 1), u && (l = Ct(a), u && (o.style[n.op.p] = l[n.op.p] - n.op.m - o._offset + St));
    }
    return p && v && (h = Ct(v), p.seek(f), g = Ct(v), p._caScrollDist = h[n.p] - g[n.p], e = e / p._caScrollDist * f), p && p.seek(b), p ? e : Math.round(e);
  }
  function hc(e, t, r, n) {
    if (e.parentNode !== t) {
      var i,
        o,
        a = e.style;
      if (t === Je) {
        for (i in e._stOrig = a.cssText, o = hb(e)) +i || $.test(i) || !o[i] || "string" != typeof a[i] || "0" === i || (a[i] = o[i]);
        a.top = r, a.left = n;
      } else a.cssText = e._stOrig;
      Ne.core.getCache(e).uncache = 1, t.appendChild(e);
    }
  }
  function ic(r, e, n) {
    var i = e,
      o = i;
    return function (e) {
      var t = Math.round(r());
      return t !== i && t !== o && 3 < Math.abs(t - i) && 3 < Math.abs(t - o) && (e = t, n && n()), o = i, i = e;
    };
  }
  function jc(e, t, r) {
    var n = {};
    n[t.p] = "+=" + r, Ne.set(e, n);
  }
  function kc(c, e) {
    function pk(e, t, r, n, i) {
      var o = pk.tween,
        a = t.onComplete,
        s = {};
      r = r || u();
      var l = ic(u, r, function () {
        o.kill(), pk.tween = 0;
      });
      return i = n && i || 0, n = n || e - r, o && o.kill(), t[f] = e, (t.modifiers = s)[f] = function () {
        return l(r + n * o.ratio + i * o.ratio * o.ratio);
      }, t.onUpdate = function () {
        qe.cache++, V();
      }, t.onComplete = function () {
        pk.tween = 0, a && a.call(o);
      }, o = pk.tween = Ne.to(c, t);
    }
    var u = K(c, e),
      f = "_scroll" + e.p2;
    return (c[f] = u).wheelHandler = function () {
      return pk.tween && pk.tween.kill() && (pk.tween = 0);
    }, rb(c, "wheel", u.wheelHandler), ee.isTouch && rb(c, "touchmove", u.wheelHandler), pk;
  }
  var Ne,
    s,
    He,
    Ge,
    je,
    Je,
    l,
    c,
    Ve,
    Ue,
    Ke,
    u,
    Qe,
    et,
    f,
    tt,
    p,
    d,
    h,
    rt,
    nt,
    g,
    v,
    b,
    m,
    y,
    E,
    x,
    _,
    it,
    w,
    ot,
    at,
    st,
    lt = 1,
    ct = Date.now,
    S = ct(),
    ut = 0,
    ft = 0,
    pt = function _isString(e) {
      return "string" == typeof e;
    },
    dt = Math.abs,
    T = "right",
    D = "bottom",
    ht = "width",
    gt = "height",
    vt = "Right",
    bt = "Left",
    mt = "Top",
    yt = "Bottom",
    xt = "padding",
    _t = "margin",
    wt = "Width",
    R = "Height",
    St = "px",
    Ct = function _getBounds(e, t) {
      var r = t && "matrix(1, 0, 0, 1, 0, 0)" !== hb(e)[f] && Ne.to(e, {
          x: 0,
          y: 0,
          xPercent: 0,
          yPercent: 0,
          rotation: 0,
          rotationX: 0,
          rotationY: 0,
          scale: 1,
          skewX: 0,
          skewY: 0
        }).progress(1),
        n = e.getBoundingClientRect();
      return r && r.progress(0).kill(), n;
    },
    Tt = {
      startColor: "green",
      endColor: "red",
      indent: 0,
      fontSize: "16px",
      fontWeight: "normal"
    },
    kt = {
      toggleActions: "play",
      anticipatePin: 0
    },
    Y = {
      top: 0,
      left: 0,
      center: .5,
      bottom: 1,
      right: 1
    },
    q = function _positionMarker(e, t, r, n) {
      var i = {
          display: "block"
        },
        o = r[n ? "os2" : "p2"],
        a = r[n ? "p2" : "os2"];
      e._isFlipped = n, i[r.a + "Percent"] = n ? -100 : 0, i[r.a] = n ? "1px" : 0, i["border" + o + wt] = 1, i["border" + a + wt] = 0, i[r.p] = t + "px", Ne.set(e, i);
    },
    Et = [],
    Pt = {},
    I = {},
    X = [],
    H = function _dispatch(e) {
      return I[e] && I[e].map(function (e) {
        return e();
      }) || X;
    },
    W = [],
    Mt = 0,
    Ot = function _refreshAll(e, t) {
      if (!ut || e) {
        ot = ee.isRefreshing = !0, qe.forEach(function (e) {
          return Oa(e) && ++e.cacheID && (e.rec = e());
        });
        var r = H("refreshInit");
        rt && ee.sort(), t || Nb(), qe.forEach(function (e) {
          Oa(e) && (e.smooth && (e.target.style.scrollBehavior = "auto"), e(0));
        }), Et.slice(0).forEach(function (e) {
          return e.refresh();
        }), Et.forEach(function (e, t) {
          if (e._subPinOffset && e.pin) {
            var r = e.vars.horizontal ? "offsetWidth" : "offsetHeight",
              n = e.pin[r];
            e.revert(!0, 1), e.adjustPinSpacing(e.pin[r] - n), e.refresh();
          }
        }), Et.forEach(function (e) {
          var t = La(e.scroller, e._dir);
          ("max" === e.vars.end || e._endClamp && e.end > t) && e.setPositions(e.start, Math.max(e.start + 1, t), !0);
        }), r.forEach(function (e) {
          return e && e.render && e.render(-1);
        }), qe.forEach(function (e) {
          Oa(e) && (e.smooth && requestAnimationFrame(function () {
            return e.target.style.scrollBehavior = "smooth";
          }), e.rec && e(e.rec));
        }), Ob(_, 1), c.pause(), Mt++, V(ot = 2), Et.forEach(function (e) {
          return Oa(e.vars.onRefresh) && e.vars.onRefresh(e);
        }), ot = ee.isRefreshing = !1, H("refresh");
      } else rb(ee, "scrollEnd", Jb);
    },
    j = 0,
    At = 1,
    V = function _updateAll(e) {
      if (!ot || 2 === e) {
        ee.isUpdating = !0, st && st.update(0);
        var t = Et.length,
          r = ct(),
          n = 50 <= r - S,
          i = t && Et[0].scroll();
        if (At = i < j ? -1 : 1, ot || (j = i), n && (ut && !et && 200 < r - ut && (ut = 0, H("scrollEnd")), Ke = S, S = r), At < 0) {
          for (tt = t; 0 < tt--;) Et[tt] && Et[tt].update(0, n);
          At = 1;
        } else for (tt = 0; tt < t; tt++) Et[tt] && Et[tt].update(0, n);
        ee.isUpdating = !1;
      }
      w = 0;
    },
    U = ["left", "top", D, T, _t + yt, _t + vt, _t + mt, _t + bt, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
    Q = U.concat([ht, gt, "boxSizing", "max" + wt, "max" + R, "position", _t, xt, xt + mt, xt + vt, xt + yt, xt + bt]),
    Z = /([A-Z])/g,
    Dt = function _setState(e) {
      if (e) {
        var t,
          r,
          n = e.t.style,
          i = e.length,
          o = 0;
        for ((e.t._gsap || Ne.core.getCache(e.t)).uncache = 1; o < i; o += 2) r = e[o + 1], t = e[o], r ? n[t] = r : n[t] && n.removeProperty(t.replace(Z, "-$1").toLowerCase());
      }
    },
    Rt = {
      left: 0,
      top: 0
    },
    $ = /(webkit|moz|length|cssText|inset)/i,
    ee = (ScrollTrigger.prototype.init = function init(M, O) {
      if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), ft) {
        var A,
          n,
          d,
          D,
          R,
          B,
          Y,
          q,
          F,
          L,
          I,
          e,
          X,
          N,
          H,
          W,
          G,
          j,
          t,
          V,
          b,
          U,
          Q,
          m,
          Z,
          y,
          $,
          x,
          r,
          _,
          w,
          ee,
          i,
          h,
          te,
          re,
          ne,
          S,
          o,
          C = (M = jb(pt(M) || Pa(M) || M.nodeType ? {
            trigger: M
          } : M, kt)).onUpdate,
          T = M.toggleClass,
          a = M.id,
          k = M.onToggle,
          ie = M.onRefresh,
          E = M.scrub,
          oe = M.trigger,
          ae = M.pin,
          se = M.pinSpacing,
          le = M.invalidateOnRefresh,
          P = M.anticipatePin,
          s = M.onScrubComplete,
          g = M.onSnapComplete,
          ce = M.once,
          ue = M.snap,
          fe = M.pinReparent,
          l = M.pinSpacer,
          pe = M.containerAnimation,
          de = M.fastScrollEnd,
          he = M.preventOverlaps,
          ge = M.horizontal || M.containerAnimation && !1 !== M.horizontal ? Le : Ie,
          ve = !E && 0 !== E,
          be = J(M.scroller || He),
          c = Ne.core.getCache(be),
          me = Ha(be),
          ye = "fixed" === ("pinType" in M ? M.pinType : z(be, "pinType") || me && "fixed"),
          xe = [M.onEnter, M.onLeave, M.onEnterBack, M.onLeaveBack],
          _e = ve && M.toggleActions.split(" "),
          we = "markers" in M ? M.markers : kt.markers,
          Se = me ? 0 : parseFloat(hb(be)["border" + ge.p2 + wt]) || 0,
          Ce = this,
          Te = M.onRefreshInit && function () {
            return M.onRefreshInit(Ce);
          },
          ke = function _getSizeFunc(e, t, r) {
            var n = r.d,
              i = r.d2,
              o = r.a;
            return (o = z(e, "getBoundingClientRect")) ? function () {
              return o()[n];
            } : function () {
              return (t ? He["inner" + i] : e["client" + i]) || 0;
            };
          }(be, me, ge),
          Ee = function _getOffsetsFunc(e, t) {
            return !t || ~ze.indexOf(e) ? Ia(e) : function () {
              return Rt;
            };
          }(be, me),
          Pe = 0,
          Me = 0,
          Oe = 0,
          Ae = K(be, ge);
        if (Ce._startClamp = Ce._endClamp = !1, Ce._dir = ge, P *= 45, Ce.scroller = be, Ce.scroll = pe ? pe.time.bind(pe) : Ae, D = Ae(), Ce.vars = M, O = O || M.animation, "refreshPriority" in M && (rt = 1, -9999 === M.refreshPriority && (st = Ce)), c.tweenScroll = c.tweenScroll || {
          top: kc(be, Ie),
          left: kc(be, Le)
        }, Ce.tweenTo = A = c.tweenScroll[ge.p], Ce.scrubDuration = function (e) {
          (i = Pa(e) && e) ? ee ? ee.duration(e) : ee = Ne.to(O, {
            ease: "expo",
            totalProgress: "+=0",
            duration: i,
            paused: !0,
            onComplete: function onComplete() {
              return s && s(Ce);
            }
          }) : (ee && ee.progress(1).kill(), ee = 0);
        }, O && (O.vars.lazy = !1, O._initted && !Ce.isReverted || !1 !== O.vars.immediateRender && !1 !== M.immediateRender && O.duration() && O.render(0, !0, !0), Ce.animation = O.pause(), (O.scrollTrigger = Ce).scrubDuration(E), _ = 0, a = a || O.vars.id), ue && (Qa(ue) && !ue.push || (ue = {
          snapTo: ue
        }), "scrollBehavior" in Je.style && Ne.set(me ? [Je, je] : be, {
          scrollBehavior: "auto"
        }), qe.forEach(function (e) {
          return Oa(e) && e.target === (me ? Ge.scrollingElement || je : be) && (e.smooth = !1);
        }), d = Oa(ue.snapTo) ? ue.snapTo : "labels" === ue.snapTo ? function _getClosestLabel(t) {
          return function (e) {
            return Ne.utils.snap(mb(t), e);
          };
        }(O) : "labelsDirectional" === ue.snapTo ? function _getLabelAtDirection(r) {
          return function (e, t) {
            return ob(mb(r))(e, t.direction);
          };
        }(O) : !1 !== ue.directional ? function (e, t) {
          return ob(ue.snapTo)(e, ct() - Me < 500 ? 0 : t.direction);
        } : Ne.utils.snap(ue.snapTo), h = ue.duration || {
          min: .1,
          max: 2
        }, h = Qa(h) ? Ue(h.min, h.max) : Ue(h, h), te = Ne.delayedCall(ue.delay || i / 2 || .1, function () {
          var e = Ae(),
            t = ct() - Me < 500,
            r = A.tween;
          if (!(t || Math.abs(Ce.getVelocity()) < 10) || r || et || Pe === e) Ce.isActive && Pe !== e && te.restart(!0);else {
            var n = (e - B) / N,
              i = O && !ve ? O.totalProgress() : n,
              o = t ? 0 : (i - w) / (ct() - Ke) * 1e3 || 0,
              a = Ne.utils.clamp(-n, 1 - n, dt(o / 2) * o / .185),
              s = n + (!1 === ue.inertia ? 0 : a),
              l = Ue(0, 1, d(s, Ce)),
              c = Math.round(B + l * N),
              u = ue.onStart,
              f = ue.onInterrupt,
              p = ue.onComplete;
            if (e <= Y && B <= e && c !== e) {
              if (r && !r._initted && r.data <= dt(c - e)) return;
              !1 === ue.inertia && (a = l - n), A(c, {
                duration: h(dt(.185 * Math.max(dt(s - i), dt(l - i)) / o / .05 || 0)),
                ease: ue.ease || "power3",
                data: dt(c - e),
                onInterrupt: function onInterrupt() {
                  return te.restart(!0) && f && f(Ce);
                },
                onComplete: function onComplete() {
                  Ce.update(), Pe = Ae(), _ = w = O && !ve ? O.totalProgress() : Ce.progress, g && g(Ce), p && p(Ce);
                }
              }, e, a * N, c - e - a * N), u && u(Ce, A.tween);
            }
          }
        }).pause()), a && (Pt[a] = Ce), o = (o = (oe = Ce.trigger = J(oe || !0 !== ae && ae)) && oe._gsap && oe._gsap.stRevert) && o(Ce), ae = !0 === ae ? oe : J(ae), pt(T) && (T = {
          targets: oe,
          className: T
        }), ae && (!1 === se || se === _t || (se = !(!se && ae.parentNode && ae.parentNode.style && "flex" === hb(ae.parentNode).display) && xt), Ce.pin = ae, (n = Ne.core.getCache(ae)).spacer ? H = n.pinState : (l && ((l = J(l)) && !l.nodeType && (l = l.current || l.nativeElement), n.spacerIsNative = !!l, l && (n.spacerState = cc(l))), n.spacer = j = l || Ge.createElement("div"), j.classList.add("pin-spacer"), a && j.classList.add("pin-spacer-" + a), n.pinState = H = cc(ae)), !1 !== M.force3D && Ne.set(ae, {
          force3D: !0
        }), Ce.spacer = j = n.spacer, r = hb(ae), m = r[se + ge.os2], V = Ne.getProperty(ae), b = Ne.quickSetter(ae, ge.a, St), _b(ae, j, r), G = cc(ae)), we) {
          e = Qa(we) ? jb(we, Tt) : Tt, L = yb("scroller-start", a, be, ge, e, 0), I = yb("scroller-end", a, be, ge, e, 0, L), t = L["offset" + ge.op.d2];
          var u = J(z(be, "content") || be);
          q = this.markerStart = yb("start", a, u, ge, e, t, 0, pe), F = this.markerEnd = yb("end", a, u, ge, e, t, 0, pe), pe && (S = Ne.quickSetter([q, F], ge.a, St)), ye || ze.length && !0 === z(be, "fixedMarkers") || (function _makePositionable(e) {
            var t = hb(e).position;
            e.style.position = "absolute" === t || "fixed" === t ? t : "relative";
          }(me ? Je : be), Ne.set([L, I], {
            force3D: !0
          }), y = Ne.quickSetter(L, ge.a, St), x = Ne.quickSetter(I, ge.a, St));
        }
        if (pe) {
          var f = pe.vars.onUpdate,
            p = pe.vars.onUpdateParams;
          pe.eventCallback("onUpdate", function () {
            Ce.update(0, 0, 1), f && f.apply(pe, p || []);
          });
        }
        if (Ce.previous = function () {
          return Et[Et.indexOf(Ce) - 1];
        }, Ce.next = function () {
          return Et[Et.indexOf(Ce) + 1];
        }, Ce.revert = function (e, t) {
          if (!t) return Ce.kill(!0);
          var r = !1 !== e || !Ce.enabled,
            n = Qe;
          r !== Ce.isReverted && (r && (re = Math.max(Ae(), Ce.scroll.rec || 0), Oe = Ce.progress, ne = O && O.progress()), q && [q, F, L, I].forEach(function (e) {
            return e.style.display = r ? "none" : "block";
          }), r && (Qe = Ce).update(r), !ae || fe && Ce.isActive || (r ? function _swapPinOut(e, t, r) {
            Dt(r);
            var n = e._gsap;
            if (n.spacerIsNative) Dt(n.spacerState);else if (e._gsap.swappedIn) {
              var i = t.parentNode;
              i && (i.insertBefore(e, t), i.removeChild(t));
            }
            e._gsap.swappedIn = !1;
          }(ae, j, H) : _b(ae, j, hb(ae), Z)), r || Ce.update(r), Qe = n, Ce.isReverted = r);
        }, Ce.refresh = function (e, t, r, n) {
          if (!Qe && Ce.enabled || t) if (ae && e && ut) rb(ScrollTrigger, "scrollEnd", Jb);else {
            !ot && Te && Te(Ce), Qe = Ce, A.tween && (A.tween.kill(), A.tween = 0), ee && ee.pause(), le && O && O.revert({
              kill: !1
            }).invalidate(), Ce.isReverted || Ce.revert(!0, !0), Ce._subPinOffset = !1;
            var i,
              o,
              a,
              s,
              l,
              c,
              u,
              f,
              p,
              d,
              h,
              g,
              v,
              b = ke(),
              m = Ee(),
              y = pe ? pe.duration() : La(be, ge),
              x = N <= .01,
              _ = 0,
              w = n || 0,
              S = Qa(r) ? r.end : M.end,
              C = M.endTrigger || oe,
              T = Qa(r) ? r.start : M.start || (0 !== M.start && oe ? ae ? "0 0" : "0 100%" : 0),
              k = Ce.pinnedContainer = M.pinnedContainer && J(M.pinnedContainer, Ce),
              E = oe && Math.max(0, Et.indexOf(Ce)) || 0,
              P = E;
            for (we && Qa(r) && (g = Ne.getProperty(L, ge.p), v = Ne.getProperty(I, ge.p)); P--;) (c = Et[P]).end || c.refresh(0, 1) || (Qe = Ce), !(u = c.pin) || u !== oe && u !== ae && u !== k || c.isReverted || ((d = d || []).unshift(c), c.revert(!0, !0)), c !== Et[P] && (E--, P--);
            for (Oa(T) && (T = T(Ce)), T = ya(T, "start", Ce), B = fc(T, oe, b, ge, Ae(), q, L, Ce, m, Se, ye, y, pe, Ce._startClamp && "_startClamp") || (ae ? -.001 : 0), Oa(S) && (S = S(Ce)), pt(S) && !S.indexOf("+=") && (~S.indexOf(" ") ? S = (pt(T) ? T.split(" ")[0] : "") + S : (_ = xb(S.substr(2), b), S = pt(T) ? T : (pe ? Ne.utils.mapRange(0, pe.duration(), pe.scrollTrigger.start, pe.scrollTrigger.end, B) : B) + _, C = oe)), S = ya(S, "end", Ce), Y = Math.max(B, fc(S || (C ? "100% 0" : y), C, b, ge, Ae() + _, F, I, Ce, m, Se, ye, y, pe, Ce._endClamp && "_endClamp")) || -.001, _ = 0, P = E; P--;) (u = (c = Et[P]).pin) && c.start - c._pinPush <= B && !pe && 0 < c.end && (i = c.end - (Ce._startClamp ? Math.max(0, c.start) : c.start), (u === oe && c.start - c._pinPush < B || u === k) && isNaN(T) && (_ += i * (1 - c.progress)), u === ae && (w += i));
            if (B += _, Y += _, Ce._startClamp && (Ce._startClamp += _), Ce._endClamp && !ot && (Ce._endClamp = Y || -.001, Y = Math.min(Y, La(be, ge))), N = Y - B || (B -= .01) && .001, x && (Oe = Ne.utils.clamp(0, 1, Ne.utils.normalize(B, Y, re))), Ce._pinPush = w, q && _ && ((i = {})[ge.a] = "+=" + _, k && (i[ge.p] = "-=" + Ae()), Ne.set([q, F], i)), ae) i = hb(ae), s = ge === Ie, a = Ae(), U = parseFloat(V(ge.a)) + w, !y && 1 < Y && (h = {
              style: h = (me ? Ge.scrollingElement || je : be).style,
              value: h["overflow" + ge.a.toUpperCase()]
            }, me && "scroll" !== hb(Je)["overflow" + ge.a.toUpperCase()] && (h.style["overflow" + ge.a.toUpperCase()] = "scroll")), _b(ae, j, i), G = cc(ae), o = Ct(ae, !0), f = ye && K(be, s ? Le : Ie)(), se && ((Z = [se + ge.os2, N + w + St]).t = j, (P = se === xt ? lb(ae, ge) + N + w : 0) && Z.push(ge.d, P + St), Dt(Z), k && Et.forEach(function (e) {
              e.pin === k && !1 !== e.vars.pinSpacing && (e._subPinOffset = !0);
            }), ye && Ae(re)), ye && ((l = {
              top: o.top + (s ? a - B : f) + St,
              left: o.left + (s ? f : a - B) + St,
              boxSizing: "border-box",
              position: "fixed"
            })[ht] = l.maxWidth = Math.ceil(o.width) + St, l[gt] = l.maxHeight = Math.ceil(o.height) + St, l[_t] = l[_t + mt] = l[_t + vt] = l[_t + yt] = l[_t + bt] = "0", l[xt] = i[xt], l[xt + mt] = i[xt + mt], l[xt + vt] = i[xt + vt], l[xt + yt] = i[xt + yt], l[xt + bt] = i[xt + bt], W = function _copyState(e, t, r) {
              for (var n, i = [], o = e.length, a = r ? 8 : 0; a < o; a += 2) n = e[a], i.push(n, n in t ? t[n] : e[a + 1]);
              return i.t = e.t, i;
            }(H, l, fe), ot && Ae(0)), O ? (p = O._initted, nt(1), O.render(O.duration(), !0, !0), Q = V(ge.a) - U + N + w, $ = 1 < Math.abs(N - Q), ye && $ && W.splice(W.length - 2, 2), O.render(0, !0, !0), p || O.invalidate(!0), O.parent || O.totalTime(O.totalTime()), nt(0)) : Q = N, h && (h.value ? h.style["overflow" + ge.a.toUpperCase()] = h.value : h.style.removeProperty("overflow-" + ge.a));else if (oe && Ae() && !pe) for (o = oe.parentNode; o && o !== Je;) o._pinOffset && (B -= o._pinOffset, Y -= o._pinOffset), o = o.parentNode;
            d && d.forEach(function (e) {
              return e.revert(!1, !0);
            }), Ce.start = B, Ce.end = Y, D = R = ot ? re : Ae(), pe || ot || (D < re && Ae(re), Ce.scroll.rec = 0), Ce.revert(!1, !0), Me = ct(), te && (Pe = -1, Ce.isActive && Ae(B + N * Oe), te.restart(!0)), Qe = 0, O && ve && (O._initted || ne) && O.progress() !== ne && O.progress(ne || 0, !0).render(O.time(), !0, !0), (x || Oe !== Ce.progress || pe) && (O && !ve && O.totalProgress(pe && B < -.001 && !Oe ? Ne.utils.normalize(B, Y, 0) : Oe, !0), Ce.progress = x || (D - B) / N === Oe ? 0 : Oe), ae && se && (j._pinOffset = Math.round(Ce.progress * Q)), ee && ee.invalidate(), isNaN(g) || (g -= Ne.getProperty(L, ge.p), v -= Ne.getProperty(I, ge.p), jc(L, ge, g), jc(q, ge, g - (n || 0)), jc(I, ge, v), jc(F, ge, v - (n || 0))), x && !ot && Ce.update(), !ie || ot || X || (X = !0, ie(Ce), X = !1);
          }
        }, Ce.getVelocity = function () {
          return (Ae() - R) / (ct() - Ke) * 1e3 || 0;
        }, Ce.endAnimation = function () {
          Ra(Ce.callbackAnimation), O && (ee ? ee.progress(1) : O.paused() ? ve || Ra(O, Ce.direction < 0, 1) : Ra(O, O.reversed()));
        }, Ce.labelToScroll = function (e) {
          return O && O.labels && (B || Ce.refresh() || B) + O.labels[e] / O.duration() * N || 0;
        }, Ce.getTrailing = function (t) {
          var e = Et.indexOf(Ce),
            r = 0 < Ce.direction ? Et.slice(0, e).reverse() : Et.slice(e + 1);
          return (pt(t) ? r.filter(function (e) {
            return e.vars.preventOverlaps === t;
          }) : r).filter(function (e) {
            return 0 < Ce.direction ? e.end <= B : e.start >= Y;
          });
        }, Ce.update = function (e, t, r) {
          if (!pe || r || e) {
            var n,
              i,
              o,
              a,
              s,
              l,
              c,
              u = !0 === ot ? re : Ce.scroll(),
              f = e ? 0 : (u - B) / N,
              p = f < 0 ? 0 : 1 < f ? 1 : f || 0,
              d = Ce.progress;
            if (t && (R = D, D = pe ? Ae() : u, ue && (w = _, _ = O && !ve ? O.totalProgress() : p)), P && !p && ae && !Qe && !lt && ut && B < u + (u - R) / (ct() - Ke) * P && (p = 1e-4), p !== d && Ce.enabled) {
              if (a = (s = (n = Ce.isActive = !!p && p < 1) != (!!d && d < 1)) || !!p != !!d, Ce.direction = d < p ? 1 : -1, Ce.progress = p, a && !Qe && (i = p && !d ? 0 : 1 === p ? 1 : 1 === d ? 2 : 3, ve && (o = !s && "none" !== _e[i + 1] && _e[i + 1] || _e[i], c = O && ("complete" === o || "reset" === o || o in O))), he && (s || c) && (c || E || !O) && (Oa(he) ? he(Ce) : Ce.getTrailing(he).forEach(function (e) {
                return e.endAnimation();
              })), ve || (!ee || Qe || lt ? O && O.totalProgress(p, !(!Qe || !Me && !e)) : (ee._dp._time - ee._start !== ee._time && ee.render(ee._dp._time - ee._start), ee.resetTo ? ee.resetTo("totalProgress", p, O._tTime / O._tDur) : (ee.vars.totalProgress = p, ee.invalidate().restart()))), ae) if (e && se && (j.style[se + ge.os2] = m), ye) {
                if (a) {
                  if (l = !e && d < p && u < Y + 1 && u + 1 >= La(be, ge), fe) if (e || !n && !l) hc(ae, j);else {
                    var h = Ct(ae, !0),
                      g = u - B;
                    hc(ae, Je, h.top + (ge === Ie ? g : 0) + St, h.left + (ge === Ie ? 0 : g) + St);
                  }
                  Dt(n || l ? W : G), $ && p < 1 && n || b(U + (1 !== p || l ? 0 : Q));
                }
              } else b(Ea(U + Q * p));
              !ue || A.tween || Qe || lt || te.restart(!0), T && (s || ce && p && (p < 1 || !it)) && Ve(T.targets).forEach(function (e) {
                return e.classList[n || ce ? "add" : "remove"](T.className);
              }), !C || ve || e || C(Ce), a && !Qe ? (ve && (c && ("complete" === o ? O.pause().totalProgress(1) : "reset" === o ? O.restart(!0).pause() : "restart" === o ? O.restart(!0) : O[o]()), C && C(Ce)), !s && it || (k && s && Sa(Ce, k), xe[i] && Sa(Ce, xe[i]), ce && (1 === p ? Ce.kill(!1, 1) : xe[i] = 0), s || xe[i = 1 === p ? 1 : 3] && Sa(Ce, xe[i])), de && !n && Math.abs(Ce.getVelocity()) > (Pa(de) ? de : 2500) && (Ra(Ce.callbackAnimation), ee ? ee.progress(1) : Ra(O, "reverse" === o ? 1 : !p, 1))) : ve && C && !Qe && C(Ce);
            }
            if (x) {
              var v = pe ? u / pe.duration() * (pe._caScrollDist || 0) : u;
              y(v + (L._isFlipped ? 1 : 0)), x(v);
            }
            S && S(-u / pe.duration() * (pe._caScrollDist || 0));
          }
        }, Ce.enable = function (e, t) {
          Ce.enabled || (Ce.enabled = !0, rb(be, "resize", Gb), rb(me ? Ge : be, "scroll", Eb), Te && rb(ScrollTrigger, "refreshInit", Te), !1 !== e && (Ce.progress = Oe = 0, D = R = Pe = Ae()), !1 !== t && Ce.refresh());
        }, Ce.getTween = function (e) {
          return e && A ? A.tween : ee;
        }, Ce.setPositions = function (e, t, r, n) {
          if (pe) {
            var i = pe.scrollTrigger,
              o = pe.duration(),
              a = i.end - i.start;
            e = i.start + a * e / o, t = i.start + a * t / o;
          }
          Ce.refresh(!1, !1, {
            start: za(e, r && !!Ce._startClamp),
            end: za(t, r && !!Ce._endClamp)
          }, n), Ce.update();
        }, Ce.adjustPinSpacing = function (e) {
          if (Z && e) {
            var t = Z.indexOf(ge.d) + 1;
            Z[t] = parseFloat(Z[t]) + e + St, Z[1] = parseFloat(Z[1]) + e + St, Dt(Z);
          }
        }, Ce.disable = function (e, t) {
          if (Ce.enabled && (!1 !== e && Ce.revert(!0, !0), Ce.enabled = Ce.isActive = !1, t || ee && ee.pause(), re = 0, n && (n.uncache = 1), Te && sb(ScrollTrigger, "refreshInit", Te), te && (te.pause(), A.tween && A.tween.kill() && (A.tween = 0)), !me)) {
            for (var r = Et.length; r--;) if (Et[r].scroller === be && Et[r] !== Ce) return;
            sb(be, "resize", Gb), sb(be, "scroll", Eb);
          }
        }, Ce.kill = function (e, t) {
          Ce.disable(e, t), ee && !t && ee.kill(), a && delete Pt[a];
          var r = Et.indexOf(Ce);
          0 <= r && Et.splice(r, 1), r === tt && 0 < At && tt--, r = 0, Et.forEach(function (e) {
            return e.scroller === Ce.scroller && (r = 1);
          }), r || ot || (Ce.scroll.rec = 0), O && (O.scrollTrigger = null, e && O.revert({
            kill: !1
          }), t || O.kill()), q && [q, F, L, I].forEach(function (e) {
            return e.parentNode && e.parentNode.removeChild(e);
          }), st === Ce && (st = 0), ae && (n && (n.uncache = 1), r = 0, Et.forEach(function (e) {
            return e.pin === ae && r++;
          }), r || (n.spacer = 0)), M.onKill && M.onKill(Ce);
        }, Et.push(Ce), Ce.enable(!1, !1), o && o(Ce), O && O.add && !N) {
          var v = Ce.update;
          Ce.update = function () {
            Ce.update = v, B || Y || Ce.refresh();
          }, Ne.delayedCall(.01, Ce.update), N = .01, B = Y = 0;
        } else Ce.refresh();
        ae && function _queueRefreshAll() {
          if (at !== Mt) {
            var e = at = Mt;
            requestAnimationFrame(function () {
              return e === Mt && Ot(!0);
            });
          }
        }();
      } else this.update = this.refresh = this.kill = Da;
    }, ScrollTrigger.register = function register(e) {
      return s || (Ne = e || Ga(), Fa() && window.document && ScrollTrigger.enable(), s = ft), s;
    }, ScrollTrigger.defaults = function defaults(e) {
      if (e) for (var t in e) kt[t] = e[t];
      return kt;
    }, ScrollTrigger.disable = function disable(t, r) {
      ft = 0, Et.forEach(function (e) {
        return e[r ? "kill" : "disable"](t);
      }), sb(He, "wheel", Eb), sb(Ge, "scroll", Eb), clearInterval(u), sb(Ge, "touchcancel", Da), sb(Je, "touchstart", Da), qb(sb, Ge, "pointerdown,touchstart,mousedown", Ba), qb(sb, Ge, "pointerup,touchend,mouseup", Ca), c.kill(), Ma(sb);
      for (var e = 0; e < qe.length; e += 3) tb(sb, qe[e], qe[e + 1]), tb(sb, qe[e], qe[e + 2]);
    }, ScrollTrigger.enable = function enable() {
      if (He = window, Ge = document, je = Ge.documentElement, Je = Ge.body, Ne && (Ve = Ne.utils.toArray, Ue = Ne.utils.clamp, x = Ne.core.context || Da, nt = Ne.core.suppressOverwrites || Da, _ = He.history.scrollRestoration || "auto", j = He.pageYOffset, Ne.core.globals("ScrollTrigger", ScrollTrigger), Je)) {
        ft = 1, function _rafBugFix() {
          return ft && requestAnimationFrame(_rafBugFix);
        }(), k.register(Ne), ScrollTrigger.isTouch = k.isTouch, E = k.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), rb(He, "wheel", Eb), l = [He, Ge, je, Je], Ne.matchMedia ? (ScrollTrigger.matchMedia = function (e) {
          var t,
            r = Ne.matchMedia();
          for (t in e) r.add(t, e[t]);
          return r;
        }, Ne.addEventListener("matchMediaInit", function () {
          return Nb();
        }), Ne.addEventListener("matchMediaRevert", function () {
          return Mb();
        }), Ne.addEventListener("matchMedia", function () {
          Ot(0, 1), H("matchMedia");
        }), Ne.matchMedia("(orientation: portrait)", function () {
          return Fb(), Fb;
        })) : console.warn("Requires GSAP 3.11.0 or later"), Fb(), rb(Ge, "scroll", Eb);
        var e,
          t,
          r = Je.style,
          n = r.borderTopStyle,
          i = Ne.core.Animation.prototype;
        for (i.revert || Object.defineProperty(i, "revert", {
          value: function value() {
            return this.time(-.01, !0);
          }
        }), r.borderTopStyle = "solid", e = Ct(Je), Ie.m = Math.round(e.top + Ie.sc()) || 0, Le.m = Math.round(e.left + Le.sc()) || 0, n ? r.borderTopStyle = n : r.removeProperty("border-top-style"), u = setInterval(Db, 250), Ne.delayedCall(.5, function () {
          return lt = 0;
        }), rb(Ge, "touchcancel", Da), rb(Je, "touchstart", Da), qb(rb, Ge, "pointerdown,touchstart,mousedown", Ba), qb(rb, Ge, "pointerup,touchend,mouseup", Ca), f = Ne.utils.checkPrefix("transform"), Q.push(f), s = ct(), c = Ne.delayedCall(.2, Ot).pause(), h = [Ge, "visibilitychange", function () {
          var e = He.innerWidth,
            t = He.innerHeight;
          Ge.hidden ? (p = e, d = t) : p === e && d === t || Gb();
        }, Ge, "DOMContentLoaded", Ot, He, "load", Ot, He, "resize", Gb], Ma(rb), Et.forEach(function (e) {
          return e.enable(0, 1);
        }), t = 0; t < qe.length; t += 3) tb(sb, qe[t], qe[t + 1]), tb(sb, qe[t], qe[t + 2]);
      }
    }, ScrollTrigger.config = function config(e) {
      "limitCallbacks" in e && (it = !!e.limitCallbacks);
      var t = e.syncInterval;
      t && clearInterval(u) || (u = t) && setInterval(Db, t), "ignoreMobileResize" in e && (b = 1 === ScrollTrigger.isTouch && e.ignoreMobileResize), "autoRefreshEvents" in e && (Ma(sb) || Ma(rb, e.autoRefreshEvents || "none"), g = -1 === (e.autoRefreshEvents + "").indexOf("resize"));
    }, ScrollTrigger.scrollerProxy = function scrollerProxy(e, t) {
      var r = J(e),
        n = qe.indexOf(r),
        i = Ha(r);
      ~n && qe.splice(n, i ? 6 : 2), t && (i ? ze.unshift(He, t, Je, t, je, t) : ze.unshift(r, t));
    }, ScrollTrigger.clearMatchMedia = function clearMatchMedia(t) {
      Et.forEach(function (e) {
        return e._ctx && e._ctx.query === t && e._ctx.kill(!0, !0);
      });
    }, ScrollTrigger.isInViewport = function isInViewport(e, t, r) {
      var n = (pt(e) ? J(e) : e).getBoundingClientRect(),
        i = n[r ? ht : gt] * t || 0;
      return r ? 0 < n.right - i && n.left + i < He.innerWidth : 0 < n.bottom - i && n.top + i < He.innerHeight;
    }, ScrollTrigger.positionInViewport = function positionInViewport(e, t, r) {
      pt(e) && (e = J(e));
      var n = e.getBoundingClientRect(),
        i = n[r ? ht : gt],
        o = null == t ? i / 2 : t in Y ? Y[t] * i : ~t.indexOf("%") ? parseFloat(t) * i / 100 : parseFloat(t) || 0;
      return r ? (n.left + o) / He.innerWidth : (n.top + o) / He.innerHeight;
    }, ScrollTrigger.killAll = function killAll(e) {
      if (Et.slice(0).forEach(function (e) {
        return "ScrollSmoother" !== e.vars.id && e.kill();
      }), !0 !== e) {
        var t = I.killAll || [];
        I = {}, t.forEach(function (e) {
          return e();
        });
      }
    }, ScrollTrigger);
  function ScrollTrigger(e, t) {
    s || ScrollTrigger.register(Ne) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), x(this), this.init(e, t);
  }
  ee.version = "3.12.1", ee.saveStyles = function (e) {
    return e ? Ve(e).forEach(function (e) {
      if (e && e.style) {
        var t = W.indexOf(e);
        0 <= t && W.splice(t, 5), W.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), Ne.core.getCache(e), x());
      }
    }) : W;
  }, ee.revert = function (e, t) {
    return Nb(!e, t);
  }, ee.create = function (e, t) {
    return new ee(e, t);
  }, ee.refresh = function (e) {
    return e ? Gb() : (s || ee.register()) && Ot(!0);
  }, ee.update = function (e) {
    return ++qe.cache && V(!0 === e ? 2 : 0);
  }, ee.clearScrollMemory = Ob, ee.maxScroll = function (e, t) {
    return La(e, t ? Le : Ie);
  }, ee.getScrollFunc = function (e, t) {
    return K(J(e), t ? Le : Ie);
  }, ee.getById = function (e) {
    return Pt[e];
  }, ee.getAll = function () {
    return Et.filter(function (e) {
      return "ScrollSmoother" !== e.vars.id;
    });
  }, ee.isScrolling = function () {
    return !!ut;
  }, ee.snapDirectional = ob, ee.addEventListener = function (e, t) {
    var r = I[e] || (I[e] = []);
    ~r.indexOf(t) || r.push(t);
  }, ee.removeEventListener = function (e, t) {
    var r = I[e],
      n = r && r.indexOf(t);
    0 <= n && r.splice(n, 1);
  }, ee.batch = function (e, t) {
    function pp(e, t) {
      var r = [],
        n = [],
        i = Ne.delayedCall(o, function () {
          t(r, n), r = [], n = [];
        }).pause();
      return function (e) {
        r.length || i.restart(!0), r.push(e.trigger), n.push(e), a <= r.length && i.progress(1);
      };
    }
    var r,
      n = [],
      i = {},
      o = t.interval || .016,
      a = t.batchMax || 1e9;
    for (r in t) i[r] = "on" === r.substr(0, 2) && Oa(t[r]) && "onRefreshInit" !== r ? pp(0, t[r]) : t[r];
    return Oa(a) && (a = a(), rb(ee, "refresh", function () {
      return a = t.batchMax();
    })), Ve(e).forEach(function (e) {
      var t = {};
      for (r in i) t[r] = i[r];
      t.trigger = e, n.push(ee.create(t));
    }), n;
  };
  function mc(e, t, r, n) {
    return n < t ? e(n) : t < 0 && e(0), n < r ? (n - t) / (r - t) : r < 0 ? t / (t - r) : 1;
  }
  function nc(e, t) {
    !0 === t ? e.style.removeProperty("touch-action") : e.style.touchAction = !0 === t ? "auto" : t ? "pan-" + t + (k.isTouch ? " pinch-zoom" : "") : "none", e === je && nc(Je, t);
  }
  function pc(e) {
    var t,
      r = e.event,
      n = e.target,
      i = e.axis,
      o = (r.changedTouches ? r.changedTouches[0] : r).target,
      a = o._gsap || Ne.core.getCache(o),
      s = ct();
    if (!a._isScrollT || 2e3 < s - a._isScrollT) {
      for (; o && o !== Je && (o.scrollHeight <= o.clientHeight && o.scrollWidth <= o.clientWidth || !re[(t = hb(o)).overflowY] && !re[t.overflowX]);) o = o.parentNode;
      a._isScroll = o && o !== n && !Ha(o) && (re[(t = hb(o)).overflowY] || re[t.overflowX]), a._isScrollT = s;
    }
    !a._isScroll && "x" !== i || (r.stopPropagation(), r._gsapAllow = !0);
  }
  function qc(e, t, r, n) {
    return k.create({
      target: e,
      capture: !0,
      debounce: !1,
      lockAxis: !0,
      type: t,
      onWheel: n = n && pc,
      onPress: n,
      onDrag: n,
      onScroll: n,
      onEnable: function onEnable() {
        return r && rb(Ge, k.eventTypes[0], ie, !1, !0);
      },
      onDisable: function onDisable() {
        return sb(Ge, k.eventTypes[0], ie, !0);
      }
    });
  }
  function uc(e) {
    function mq() {
      return i = !1;
    }
    function pq() {
      o = La(d, Ie), T = Ue(E ? 1 : 0, o), f && (C = Ue(0, La(d, Le))), l = Mt;
    }
    function qq() {
      v._gsap.y = Ea(parseFloat(v._gsap.y) + b.offset) + "px", v.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(v._gsap.y) + ", 0, 1)", b.offset = b.cacheID = 0;
    }
    function wq() {
      pq(), a.isActive() && a.vars.scrollY > o && (b() > o ? a.progress(1) && b(o) : a.resetTo("scrollY", o));
    }
    Qa(e) || (e = {}), e.preventDefault = e.isNormalizer = e.allowClicks = !0, e.type || (e.type = "wheel,touch"), e.debounce = !!e.debounce, e.id = e.id || "normalizer";
    var n,
      o,
      l,
      i,
      a,
      c,
      u,
      s,
      f = e.normalizeScrollX,
      t = e.momentum,
      r = e.allowNestedScroll,
      p = e.onRelease,
      d = J(e.target) || je,
      h = Ne.core.globals().ScrollSmoother,
      g = h && h.get(),
      v = E && (e.content && J(e.content) || g && !1 !== e.content && !g.smooth() && g.content()),
      b = K(d, Ie),
      m = K(d, Le),
      y = 1,
      x = (k.isTouch && He.visualViewport ? He.visualViewport.scale * He.visualViewport.width : He.outerWidth) / He.innerWidth,
      _ = 0,
      w = Oa(t) ? function () {
        return t(n);
      } : function () {
        return t || 2.8;
      },
      S = qc(d, e.type, !0, r),
      C = Da,
      T = Da;
    return v && Ne.set(v, {
      y: "+=0"
    }), e.ignoreCheck = function (e) {
      return E && "touchmove" === e.type && function ignoreDrag() {
        if (i) {
          requestAnimationFrame(mq);
          var e = Ea(n.deltaY / 2),
            t = T(b.v - e);
          if (v && t !== b.v + b.offset) {
            b.offset = t - b.v;
            var r = Ea((parseFloat(v && v._gsap.y) || 0) - b.offset);
            v.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + r + ", 0, 1)", v._gsap.y = r + "px", b.cacheID = qe.cache, V();
          }
          return !0;
        }
        b.offset && qq(), i = !0;
      }() || 1.05 < y && "touchstart" !== e.type || n.isGesturing || e.touches && 1 < e.touches.length;
    }, e.onPress = function () {
      i = !1;
      var e = y;
      y = Ea((He.visualViewport && He.visualViewport.scale || 1) / x), a.pause(), e !== y && nc(d, 1.01 < y || !f && "x"), c = m(), u = b(), pq(), l = Mt;
    }, e.onRelease = e.onGestureStart = function (e, t) {
      if (b.offset && qq(), t) {
        qe.cache++;
        var r,
          n,
          i = w();
        f && (n = (r = m()) + .05 * i * -e.velocityX / .227, i *= mc(m, r, n, La(d, Le)), a.vars.scrollX = C(n)), n = (r = b()) + .05 * i * -e.velocityY / .227, i *= mc(b, r, n, La(d, Ie)), a.vars.scrollY = T(n), a.invalidate().duration(i).play(.01), (E && a.vars.scrollY >= o || o - 1 <= r) && Ne.to({}, {
          onUpdate: wq,
          duration: i
        });
      } else s.restart(!0);
      p && p(e);
    }, e.onWheel = function () {
      a._ts && a.pause(), 1e3 < ct() - _ && (l = 0, _ = ct());
    }, e.onChange = function (e, t, r, n, i) {
      if (Mt !== l && pq(), t && f && m(C(n[2] === t ? c + (e.startX - e.x) : m() + t - n[1])), r) {
        b.offset && qq();
        var o = i[2] === r,
          a = o ? u + e.startY - e.y : b() + r - i[1],
          s = T(a);
        o && a !== s && (u += s - a), b(s);
      }
      (r || t) && V();
    }, e.onEnable = function () {
      nc(d, !f && "x"), ee.addEventListener("refresh", wq), rb(He, "resize", wq), b.smooth && (b.target.style.scrollBehavior = "auto", b.smooth = m.smooth = !1), S.enable();
    }, e.onDisable = function () {
      nc(d, !0), sb(He, "resize", wq), ee.removeEventListener("refresh", wq), S.kill();
    }, e.lockAxis = !1 !== e.lockAxis, ((n = new k(e)).iOS = E) && !b() && b(1), E && Ne.ticker.add(Da), s = n._dc, a = Ne.to(n, {
      ease: "power4",
      paused: !0,
      scrollX: f ? "+=0.1" : "+=0",
      scrollY: "+=0.1",
      modifiers: {
        scrollY: ic(b, b(), function () {
          return a.pause();
        })
      },
      onUpdate: V,
      onComplete: s.vars.onComplete
    }), n;
  }
  var te,
    re = {
      auto: 1,
      scroll: 1
    },
    ne = /(input|label|select|textarea)/i,
    ie = function _captureInputs(e) {
      var t = ne.test(e.target.tagName);
      (t || te) && (e._gsapAllow = !0, te = t);
    };
  ee.sort = function (e) {
    return Et.sort(e || function (e, t) {
      return -1e6 * (e.vars.refreshPriority || 0) + e.start - (t.start + -1e6 * (t.vars.refreshPriority || 0));
    });
  }, ee.observe = function (e) {
    return new k(e);
  }, ee.normalizeScroll = function (e) {
    if (void 0 === e) return v;
    if (!0 === e && v) return v.enable();
    if (!1 === e) return v && v.kill();
    var t = e instanceof k ? e : uc(e);
    return v && v.target === t.target && v.kill(), Ha(t.target) && (v = t), t;
  }, ee.core = {
    _getVelocityProp: L,
    _inputObserver: qc,
    _scrollers: qe,
    _proxies: ze,
    bridge: {
      ss: function ss() {
        ut || H("scrollStart"), ut = ct();
      },
      ref: function ref() {
        return Qe;
      }
    }
  }, Ga() && Ne.registerPlugin(ee), e.ScrollTrigger = ee, e.default = ee;
  if (typeof window === "undefined" || window !== e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    });
  } else {
    delete e.default;
  }
});

},{}],28:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
!function (n, t) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : n.Splitting = t();
}(void 0, function () {
  "use strict";

  var u = document,
    l = u.createTextNode.bind(u);
  function d(n, t, e) {
    n.style.setProperty(t, e);
  }
  function f(n, t) {
    return n.appendChild(t);
  }
  function p(n, t, e, r) {
    var i = u.createElement("span");
    return t && (i.className = t), e && (!r && i.setAttribute("data-" + t, e), i.textContent = e), n && f(n, i) || i;
  }
  function h(n, t) {
    return n.getAttribute("data-" + t);
  }
  function m(n, t) {
    return n && 0 != n.length ? n.nodeName ? [n] : [].slice.call(n[0].nodeName ? n : (t || u).querySelectorAll(n)) : [];
  }
  function o(n) {
    for (var t = []; n--;) t[n] = [];
    return t;
  }
  function g(n, t) {
    n && n.some(t);
  }
  function c(t) {
    return function (n) {
      return t[n];
    };
  }
  var a = {};
  function n(n, t, e, r) {
    return {
      by: n,
      depends: t,
      key: e,
      split: r
    };
  }
  function e(n) {
    return function t(e, n, r) {
      var i = r.indexOf(e);
      if (-1 == i) r.unshift(e), g(a[e].depends, function (n) {
        t(n, e, r);
      });else {
        var u = r.indexOf(n);
        r.splice(i, 1), r.splice(u, 0, e);
      }
      return r;
    }(n, 0, []).map(c(a));
  }
  function t(n) {
    a[n.by] = n;
  }
  function v(n, r, i, u, o) {
    n.normalize();
    var c = [],
      a = document.createDocumentFragment();
    u && c.push(n.previousSibling);
    var s = [];
    return m(n.childNodes).some(function (n) {
      if (!n.tagName || n.hasChildNodes()) {
        if (n.childNodes && n.childNodes.length) return s.push(n), void c.push.apply(c, v(n, r, i, u, o));
        var t = n.wholeText || "",
          e = t.trim();
        e.length && (" " === t[0] && s.push(l(" ")), g(e.split(i), function (n, t) {
          t && o && s.push(p(a, "whitespace", " ", o));
          var e = p(a, r, n);
          c.push(e), s.push(e);
        }), " " === t[t.length - 1] && s.push(l(" ")));
      } else s.push(n);
    }), g(s, function (n) {
      f(a, n);
    }), n.innerHTML = "", f(n, a), c;
  }
  var s = 0;
  var i = "words",
    r = n(i, s, "word", function (n) {
      return v(n, "word", /\s+/, 0, 1);
    }),
    y = "chars",
    w = n(y, [i], "char", function (n, e, t) {
      var r = [];
      return g(t[i], function (n, t) {
        r.push.apply(r, v(n, "char", "", e.whitespace && t));
      }), r;
    });
  function b(t) {
    var f = (t = t || {}).key;
    return m(t.target || "[data-splitting]").map(function (a) {
      var s = a["🍌"];
      if (!t.force && s) return s;
      s = a["🍌"] = {
        el: a
      };
      var n = e(t.by || h(a, "splitting") || y),
        l = function (n, t) {
          for (var e in t) n[e] = t[e];
          return n;
        }({}, t);
      return g(n, function (n) {
        if (n.split) {
          var t = n.by,
            e = (f ? "-" + f : "") + n.key,
            r = n.split(a, l, s);
          e && (i = a, c = (o = "--" + e) + "-index", g(u = r, function (n, t) {
            Array.isArray(n) ? g(n, function (n) {
              d(n, c, t);
            }) : d(n, c, t);
          }), d(i, o + "-total", u.length)), s[t] = r, a.classList.add(t);
        }
        var i, u, o, c;
      }), a.classList.add("splitting"), s;
    });
  }
  function N(n, t, e) {
    var r = m(t.matching || n.children, n),
      i = {};
    return g(r, function (n) {
      var t = Math.round(n[e]);
      (i[t] || (i[t] = [])).push(n);
    }), Object.keys(i).map(Number).sort(x).map(c(i));
  }
  function x(n, t) {
    return n - t;
  }
  b.html = function (n) {
    var t = (n = n || {}).target = p();
    return t.innerHTML = n.content, b(n), t.outerHTML;
  }, b.add = t;
  var T = n("lines", [i], "line", function (n, t, e) {
      return N(n, {
        matching: e[i]
      }, "offsetTop");
    }),
    L = n("items", s, "item", function (n, t) {
      return m(t.matching || n.children, n);
    }),
    k = n("rows", s, "row", function (n, t) {
      return N(n, t, "offsetTop");
    }),
    A = n("cols", s, "col", function (n, t) {
      return N(n, t, "offsetLeft");
    }),
    C = n("grid", ["rows", "cols"]),
    M = "layout",
    S = n(M, s, s, function (n, t) {
      var e = t.rows = +(t.rows || h(n, "rows") || 1),
        r = t.columns = +(t.columns || h(n, "columns") || 1);
      if (t.image = t.image || h(n, "image") || n.currentSrc || n.src, t.image) {
        var i = m("img", n)[0];
        t.image = i && (i.currentSrc || i.src);
      }
      t.image && d(n, "background-image", "url(" + t.image + ")");
      for (var u = e * r, o = [], c = p(s, "cell-grid"); u--;) {
        var a = p(c, "cell");
        p(a, "cell-inner"), o.push(a);
      }
      return f(n, c), o;
    }),
    H = n("cellRows", [M], "row", function (n, t, e) {
      var r = t.rows,
        i = o(r);
      return g(e[M], function (n, t, e) {
        i[Math.floor(t / (e.length / r))].push(n);
      }), i;
    }),
    O = n("cellColumns", [M], "col", function (n, t, e) {
      var r = t.columns,
        i = o(r);
      return g(e[M], function (n, t) {
        i[t % r].push(n);
      }), i;
    }),
    j = n("cells", ["cellRows", "cellColumns"], "cell", function (n, t, e) {
      return e[M];
    });
  return t(r), t(w), t(T), t(L), t(k), t(A), t(C), t(S), t(H), t(O), t(j), b;
});

},{}],29:[function(require,module,exports){
(function (global){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _this = void 0;
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var swiper = function swiper() {
  /**
   * Swiper 7.4.1
   * Most modern mobile touch slider and framework with hardware accelerated transitions
   * https://swiperjs.com
   *
   * Copyright 2014-2021 Vladimir Kharlampidi
   *
   * Released under the MIT License
   *
   * Released on: December 24, 2021
   */

  (function (global, factory) {
    (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Swiper = factory());
  })(_this, function () {
    'use strict';

    /**
     * SSR Window 4.0.2
     * Better handling for window object in SSR environment
     * https://github.com/nolimits4web/ssr-window
     *
     * Copyright 2021, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: December 13, 2021
     */

    /* eslint-disable no-param-reassign */
    function isObject$1(obj) {
      return obj !== null && _typeof(obj) === 'object' && 'constructor' in obj && obj.constructor === Object;
    }
    function extend$1() {
      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var src = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      Object.keys(src).forEach(function (key) {
        if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {
          extend$1(target[key], src[key]);
        }
      });
    }
    var ssrDocument = {
      body: {},
      addEventListener: function addEventListener() {},
      removeEventListener: function removeEventListener() {},
      activeElement: {
        blur: function blur() {},
        nodeName: ''
      },
      querySelector: function querySelector() {
        return null;
      },
      querySelectorAll: function querySelectorAll() {
        return [];
      },
      getElementById: function getElementById() {
        return null;
      },
      createEvent: function createEvent() {
        return {
          initEvent: function initEvent() {}
        };
      },
      createElement: function createElement() {
        return {
          children: [],
          childNodes: [],
          style: {},
          setAttribute: function setAttribute() {},
          getElementsByTagName: function getElementsByTagName() {
            return [];
          }
        };
      },
      createElementNS: function createElementNS() {
        return {};
      },
      importNode: function importNode() {
        return null;
      },
      location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: ''
      }
    };
    function getDocument() {
      var doc = typeof document !== 'undefined' ? document : {};
      extend$1(doc, ssrDocument);
      return doc;
    }
    var ssrWindow = {
      document: ssrDocument,
      navigator: {
        userAgent: ''
      },
      location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: ''
      },
      history: {
        replaceState: function replaceState() {},
        pushState: function pushState() {},
        go: function go() {},
        back: function back() {}
      },
      CustomEvent: function CustomEvent() {
        return this;
      },
      addEventListener: function addEventListener() {},
      removeEventListener: function removeEventListener() {},
      getComputedStyle: function getComputedStyle() {
        return {
          getPropertyValue: function getPropertyValue() {
            return '';
          }
        };
      },
      Image: function Image() {},
      Date: function Date() {},
      screen: {},
      setTimeout: function setTimeout() {},
      clearTimeout: function clearTimeout() {},
      matchMedia: function matchMedia() {
        return {};
      },
      requestAnimationFrame: function requestAnimationFrame(callback) {
        if (typeof setTimeout === 'undefined') {
          callback();
          return null;
        }
        return setTimeout(callback, 0);
      },
      cancelAnimationFrame: function cancelAnimationFrame(id) {
        if (typeof setTimeout === 'undefined') {
          return;
        }
        clearTimeout(id);
      }
    };
    function getWindow() {
      var win = typeof window !== 'undefined' ? window : {};
      extend$1(win, ssrWindow);
      return win;
    }

    /**
     * Dom7 4.0.2
     * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
     * https://framework7.io/docs/dom7.html
     *
     * Copyright 2021, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: December 13, 2021
     */
    /* eslint-disable no-proto */

    function makeReactive(obj) {
      var proto = obj.__proto__;
      Object.defineProperty(obj, '__proto__', {
        get: function get() {
          return proto;
        },
        set: function set(value) {
          proto.__proto__ = value;
        }
      });
    }
    var Dom7 = /*#__PURE__*/function (_Array) {
      _inherits(Dom7, _Array);
      var _super = _createSuper(Dom7);
      function Dom7(items) {
        var _this2;
        _classCallCheck(this, Dom7);
        _this2 = _super.call.apply(_super, [this].concat(_toConsumableArray(items || [])));
        makeReactive(_assertThisInitialized(_this2));
        return _this2;
      }
      return _createClass(Dom7);
    }( /*#__PURE__*/_wrapNativeSuper(Array));
    function arrayFlat() {
      var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var res = [];
      arr.forEach(function (el) {
        if (Array.isArray(el)) {
          res.push.apply(res, _toConsumableArray(arrayFlat(el)));
        } else {
          res.push(el);
        }
      });
      return res;
    }
    function arrayFilter(arr, callback) {
      return Array.prototype.filter.call(arr, callback);
    }
    function arrayUnique(arr) {
      var uniqueArray = [];
      for (var i = 0; i < arr.length; i += 1) {
        if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
      }
      return uniqueArray;
    }
    function qsa(selector, context) {
      if (typeof selector !== 'string') {
        return [selector];
      }
      var a = [];
      var res = context.querySelectorAll(selector);
      for (var i = 0; i < res.length; i += 1) {
        a.push(res[i]);
      }
      return a;
    }
    function $(selector, context) {
      var window = getWindow();
      var document = getDocument();
      var arr = [];
      if (!context && selector instanceof Dom7) {
        return selector;
      }
      if (!selector) {
        return new Dom7(arr);
      }
      if (typeof selector === 'string') {
        var _html = selector.trim();
        if (_html.indexOf('<') >= 0 && _html.indexOf('>') >= 0) {
          var toCreate = 'div';
          if (_html.indexOf('<li') === 0) toCreate = 'ul';
          if (_html.indexOf('<tr') === 0) toCreate = 'tbody';
          if (_html.indexOf('<td') === 0 || _html.indexOf('<th') === 0) toCreate = 'tr';
          if (_html.indexOf('<tbody') === 0) toCreate = 'table';
          if (_html.indexOf('<option') === 0) toCreate = 'select';
          var tempParent = document.createElement(toCreate);
          tempParent.innerHTML = _html;
          for (var i = 0; i < tempParent.childNodes.length; i += 1) {
            arr.push(tempParent.childNodes[i]);
          }
        } else {
          arr = qsa(selector.trim(), context || document);
        } // arr = qsa(selector, document);
      } else if (selector.nodeType || selector === window || selector === document) {
        arr.push(selector);
      } else if (Array.isArray(selector)) {
        if (selector instanceof Dom7) return selector;
        arr = selector;
      }
      return new Dom7(arrayUnique(arr));
    }
    $.fn = Dom7.prototype; // eslint-disable-next-line

    function addClass() {
      for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {
        classes[_key] = arguments[_key];
      }
      var classNames = arrayFlat(classes.map(function (c) {
        return c.split(' ');
      }));
      this.forEach(function (el) {
        var _el$classList;
        (_el$classList = el.classList).add.apply(_el$classList, _toConsumableArray(classNames));
      });
      return this;
    }
    function removeClass() {
      for (var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        classes[_key2] = arguments[_key2];
      }
      var classNames = arrayFlat(classes.map(function (c) {
        return c.split(' ');
      }));
      this.forEach(function (el) {
        var _el$classList2;
        (_el$classList2 = el.classList).remove.apply(_el$classList2, _toConsumableArray(classNames));
      });
      return this;
    }
    function toggleClass() {
      for (var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        classes[_key3] = arguments[_key3];
      }
      var classNames = arrayFlat(classes.map(function (c) {
        return c.split(' ');
      }));
      this.forEach(function (el) {
        classNames.forEach(function (className) {
          el.classList.toggle(className);
        });
      });
    }
    function hasClass() {
      for (var _len4 = arguments.length, classes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        classes[_key4] = arguments[_key4];
      }
      var classNames = arrayFlat(classes.map(function (c) {
        return c.split(' ');
      }));
      return arrayFilter(this, function (el) {
        return classNames.filter(function (className) {
          return el.classList.contains(className);
        }).length > 0;
      }).length > 0;
    }
    function attr(attrs, value) {
      if (arguments.length === 1 && typeof attrs === 'string') {
        // Get attr
        if (this[0]) return this[0].getAttribute(attrs);
        return undefined;
      } // Set attrs

      for (var i = 0; i < this.length; i += 1) {
        if (arguments.length === 2) {
          // String
          this[i].setAttribute(attrs, value);
        } else {
          // Object
          for (var attrName in attrs) {
            this[i][attrName] = attrs[attrName];
            this[i].setAttribute(attrName, attrs[attrName]);
          }
        }
      }
      return this;
    }
    function removeAttr(attr) {
      for (var i = 0; i < this.length; i += 1) {
        this[i].removeAttribute(attr);
      }
      return this;
    }
    function transform(transform) {
      for (var i = 0; i < this.length; i += 1) {
        this[i].style.transform = transform;
      }
      return this;
    }
    function transition$1(duration) {
      for (var i = 0; i < this.length; i += 1) {
        this[i].style.transitionDuration = typeof duration !== 'string' ? "".concat(duration, "ms") : duration;
      }
      return this;
    }
    function on() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      var eventType = args[0],
        targetSelector = args[1],
        listener = args[2],
        capture = args[3];
      if (typeof args[1] === 'function') {
        eventType = args[0];
        listener = args[1];
        capture = args[2];
        targetSelector = undefined;
      }
      if (!capture) capture = false;
      function handleLiveEvent(e) {
        var target = e.target;
        if (!target) return;
        var eventData = e.target.dom7EventData || [];
        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }
        if ($(target).is(targetSelector)) listener.apply(target, eventData);else {
          var _parents = $(target).parents(); // eslint-disable-line

          for (var k = 0; k < _parents.length; k += 1) {
            if ($(_parents[k]).is(targetSelector)) listener.apply(_parents[k], eventData);
          }
        }
      }
      function handleEvent(e) {
        var eventData = e && e.target ? e.target.dom7EventData || [] : [];
        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }
        listener.apply(this, eventData);
      }
      var events = eventType.split(' ');
      var j;
      for (var i = 0; i < this.length; i += 1) {
        var el = this[i];
        if (!targetSelector) {
          for (j = 0; j < events.length; j += 1) {
            var _event = events[j];
            if (!el.dom7Listeners) el.dom7Listeners = {};
            if (!el.dom7Listeners[_event]) el.dom7Listeners[_event] = [];
            el.dom7Listeners[_event].push({
              listener: listener,
              proxyListener: handleEvent
            });
            el.addEventListener(_event, handleEvent, capture);
          }
        } else {
          // Live events
          for (j = 0; j < events.length; j += 1) {
            var _event2 = events[j];
            if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
            if (!el.dom7LiveListeners[_event2]) el.dom7LiveListeners[_event2] = [];
            el.dom7LiveListeners[_event2].push({
              listener: listener,
              proxyListener: handleLiveEvent
            });
            el.addEventListener(_event2, handleLiveEvent, capture);
          }
        }
      }
      return this;
    }
    function off() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      var eventType = args[0],
        targetSelector = args[1],
        listener = args[2],
        capture = args[3];
      if (typeof args[1] === 'function') {
        eventType = args[0];
        listener = args[1];
        capture = args[2];
        targetSelector = undefined;
      }
      if (!capture) capture = false;
      var events = eventType.split(' ');
      for (var i = 0; i < events.length; i += 1) {
        var _event3 = events[i];
        for (var j = 0; j < this.length; j += 1) {
          var el = this[j];
          var handlers = void 0;
          if (!targetSelector && el.dom7Listeners) {
            handlers = el.dom7Listeners[_event3];
          } else if (targetSelector && el.dom7LiveListeners) {
            handlers = el.dom7LiveListeners[_event3];
          }
          if (handlers && handlers.length) {
            for (var k = handlers.length - 1; k >= 0; k -= 1) {
              var handler = handlers[k];
              if (listener && handler.listener === listener) {
                el.removeEventListener(_event3, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
                el.removeEventListener(_event3, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (!listener) {
                el.removeEventListener(_event3, handler.proxyListener, capture);
                handlers.splice(k, 1);
              }
            }
          }
        }
      }
      return this;
    }
    function trigger() {
      var window = getWindow();
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }
      var events = args[0].split(' ');
      var eventData = args[1];
      for (var i = 0; i < events.length; i += 1) {
        var _event4 = events[i];
        for (var j = 0; j < this.length; j += 1) {
          var el = this[j];
          if (window.CustomEvent) {
            var evt = new window.CustomEvent(_event4, {
              detail: eventData,
              bubbles: true,
              cancelable: true
            });
            el.dom7EventData = args.filter(function (data, dataIndex) {
              return dataIndex > 0;
            });
            el.dispatchEvent(evt);
            el.dom7EventData = [];
            delete el.dom7EventData;
          }
        }
      }
      return this;
    }
    function transitionEnd$1(callback) {
      var dom = this;
      function fireCallBack(e) {
        if (e.target !== this) return;
        callback.call(this, e);
        dom.off('transitionend', fireCallBack);
      }
      if (callback) {
        dom.on('transitionend', fireCallBack);
      }
      return this;
    }
    function outerWidth(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          var _styles = this.styles();
          return this[0].offsetWidth + parseFloat(_styles.getPropertyValue('margin-right')) + parseFloat(_styles.getPropertyValue('margin-left'));
        }
        return this[0].offsetWidth;
      }
      return null;
    }
    function outerHeight(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          var _styles2 = this.styles();
          return this[0].offsetHeight + parseFloat(_styles2.getPropertyValue('margin-top')) + parseFloat(_styles2.getPropertyValue('margin-bottom'));
        }
        return this[0].offsetHeight;
      }
      return null;
    }
    function offset() {
      if (this.length > 0) {
        var _window = getWindow();
        var _document = getDocument();
        var el = this[0];
        var box = el.getBoundingClientRect();
        var body = _document.body;
        var clientTop = el.clientTop || body.clientTop || 0;
        var clientLeft = el.clientLeft || body.clientLeft || 0;
        var scrollTop = el === _window ? _window.scrollY : el.scrollTop;
        var scrollLeft = el === _window ? _window.scrollX : el.scrollLeft;
        return {
          top: box.top + scrollTop - clientTop,
          left: box.left + scrollLeft - clientLeft
        };
      }
      return null;
    }
    function styles() {
      var window = getWindow();
      if (this[0]) return window.getComputedStyle(this[0], null);
      return {};
    }
    function css(props, value) {
      var window = getWindow();
      var i;
      if (arguments.length === 1) {
        if (typeof props === 'string') {
          // .css('width')
          if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
        } else {
          // .css({ width: '100px' })
          for (i = 0; i < this.length; i += 1) {
            for (var prop in props) {
              this[i].style[prop] = props[prop];
            }
          }
          return this;
        }
      }
      if (arguments.length === 2 && typeof props === 'string') {
        // .css('width', '100px')
        for (i = 0; i < this.length; i += 1) {
          this[i].style[props] = value;
        }
        return this;
      }
      return this;
    }
    function each(callback) {
      if (!callback) return this;
      this.forEach(function (el, index) {
        callback.apply(el, [el, index]);
      });
      return this;
    }
    function filter(callback) {
      var result = arrayFilter(this, callback);
      return $(result);
    }
    function html(html) {
      if (typeof html === 'undefined') {
        return this[0] ? this[0].innerHTML : null;
      }
      for (var i = 0; i < this.length; i += 1) {
        this[i].innerHTML = html;
      }
      return this;
    }
    function text(text) {
      if (typeof text === 'undefined') {
        return this[0] ? this[0].textContent.trim() : null;
      }
      for (var i = 0; i < this.length; i += 1) {
        this[i].textContent = text;
      }
      return this;
    }
    function is(selector) {
      var window = getWindow();
      var document = getDocument();
      var el = this[0];
      var compareWith;
      var i;
      if (!el || typeof selector === 'undefined') return false;
      if (typeof selector === 'string') {
        if (el.matches) return el.matches(selector);
        if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
        if (el.msMatchesSelector) return el.msMatchesSelector(selector);
        compareWith = $(selector);
        for (i = 0; i < compareWith.length; i += 1) {
          if (compareWith[i] === el) return true;
        }
        return false;
      }
      if (selector === document) {
        return el === document;
      }
      if (selector === window) {
        return el === window;
      }
      if (selector.nodeType || selector instanceof Dom7) {
        compareWith = selector.nodeType ? [selector] : selector;
        for (i = 0; i < compareWith.length; i += 1) {
          if (compareWith[i] === el) return true;
        }
        return false;
      }
      return false;
    }
    function index() {
      var child = this[0];
      var i;
      if (child) {
        i = 0; // eslint-disable-next-line

        while ((child = child.previousSibling) !== null) {
          if (child.nodeType === 1) i += 1;
        }
        return i;
      }
      return undefined;
    }
    function eq(index) {
      if (typeof index === 'undefined') return this;
      var length = this.length;
      if (index > length - 1) {
        return $([]);
      }
      if (index < 0) {
        var returnIndex = length + index;
        if (returnIndex < 0) return $([]);
        return $([this[returnIndex]]);
      }
      return $([this[index]]);
    }
    function append() {
      var newChild;
      var document = getDocument();
      for (var k = 0; k < arguments.length; k += 1) {
        newChild = k < 0 || arguments.length <= k ? undefined : arguments[k];
        for (var i = 0; i < this.length; i += 1) {
          if (typeof newChild === 'string') {
            var tempDiv = document.createElement('div');
            tempDiv.innerHTML = newChild;
            while (tempDiv.firstChild) {
              this[i].appendChild(tempDiv.firstChild);
            }
          } else if (newChild instanceof Dom7) {
            for (var j = 0; j < newChild.length; j += 1) {
              this[i].appendChild(newChild[j]);
            }
          } else {
            this[i].appendChild(newChild);
          }
        }
      }
      return this;
    }
    function prepend(newChild) {
      var document = getDocument();
      var i;
      var j;
      for (i = 0; i < this.length; i += 1) {
        if (typeof newChild === 'string') {
          var tempDiv = document.createElement('div');
          tempDiv.innerHTML = newChild;
          for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
            this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
          }
        } else if (newChild instanceof Dom7) {
          for (j = 0; j < newChild.length; j += 1) {
            this[i].insertBefore(newChild[j], this[i].childNodes[0]);
          }
        } else {
          this[i].insertBefore(newChild, this[i].childNodes[0]);
        }
      }
      return this;
    }
    function next(selector) {
      if (this.length > 0) {
        if (selector) {
          if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
            return $([this[0].nextElementSibling]);
          }
          return $([]);
        }
        if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);
        return $([]);
      }
      return $([]);
    }
    function nextAll(selector) {
      var nextEls = [];
      var el = this[0];
      if (!el) return $([]);
      while (el.nextElementSibling) {
        var _next = el.nextElementSibling; // eslint-disable-line

        if (selector) {
          if ($(_next).is(selector)) nextEls.push(_next);
        } else nextEls.push(_next);
        el = _next;
      }
      return $(nextEls);
    }
    function prev(selector) {
      if (this.length > 0) {
        var el = this[0];
        if (selector) {
          if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
            return $([el.previousElementSibling]);
          }
          return $([]);
        }
        if (el.previousElementSibling) return $([el.previousElementSibling]);
        return $([]);
      }
      return $([]);
    }
    function prevAll(selector) {
      var prevEls = [];
      var el = this[0];
      if (!el) return $([]);
      while (el.previousElementSibling) {
        var _prev = el.previousElementSibling; // eslint-disable-line

        if (selector) {
          if ($(_prev).is(selector)) prevEls.push(_prev);
        } else prevEls.push(_prev);
        el = _prev;
      }
      return $(prevEls);
    }
    function parent(selector) {
      var parents = []; // eslint-disable-line

      for (var i = 0; i < this.length; i += 1) {
        if (this[i].parentNode !== null) {
          if (selector) {
            if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
          } else {
            parents.push(this[i].parentNode);
          }
        }
      }
      return $(parents);
    }
    function parents(selector) {
      var parents = []; // eslint-disable-line

      for (var i = 0; i < this.length; i += 1) {
        var _parent = this[i].parentNode; // eslint-disable-line

        while (_parent) {
          if (selector) {
            if ($(_parent).is(selector)) parents.push(_parent);
          } else {
            parents.push(_parent);
          }
          _parent = _parent.parentNode;
        }
      }
      return $(parents);
    }
    function closest(selector) {
      var closest = this; // eslint-disable-line

      if (typeof selector === 'undefined') {
        return $([]);
      }
      if (!closest.is(selector)) {
        closest = closest.parents(selector).eq(0);
      }
      return closest;
    }
    function find(selector) {
      var foundElements = [];
      for (var i = 0; i < this.length; i += 1) {
        var found = this[i].querySelectorAll(selector);
        for (var j = 0; j < found.length; j += 1) {
          foundElements.push(found[j]);
        }
      }
      return $(foundElements);
    }
    function children(selector) {
      var children = []; // eslint-disable-line

      for (var i = 0; i < this.length; i += 1) {
        var childNodes = this[i].children;
        for (var j = 0; j < childNodes.length; j += 1) {
          if (!selector || $(childNodes[j]).is(selector)) {
            children.push(childNodes[j]);
          }
        }
      }
      return $(children);
    }
    function remove() {
      for (var i = 0; i < this.length; i += 1) {
        if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
      }
      return this;
    }
    var Methods = {
      addClass: addClass,
      removeClass: removeClass,
      hasClass: hasClass,
      toggleClass: toggleClass,
      attr: attr,
      removeAttr: removeAttr,
      transform: transform,
      transition: transition$1,
      on: on,
      off: off,
      trigger: trigger,
      transitionEnd: transitionEnd$1,
      outerWidth: outerWidth,
      outerHeight: outerHeight,
      styles: styles,
      offset: offset,
      css: css,
      each: each,
      html: html,
      text: text,
      is: is,
      index: index,
      eq: eq,
      append: append,
      prepend: prepend,
      next: next,
      nextAll: nextAll,
      prev: prev,
      prevAll: prevAll,
      parent: parent,
      parents: parents,
      closest: closest,
      find: find,
      children: children,
      filter: filter,
      remove: remove
    };
    Object.keys(Methods).forEach(function (methodName) {
      Object.defineProperty($.fn, methodName, {
        value: Methods[methodName],
        writable: true
      });
    });
    function deleteProps(obj) {
      var object = obj;
      Object.keys(object).forEach(function (key) {
        try {
          object[key] = null;
        } catch (e) {
          // no getter for object
        }
        try {
          delete object[key];
        } catch (e) {
          // something got wrong
        }
      });
    }
    function nextTick(callback) {
      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return setTimeout(callback, delay);
    }
    function now() {
      return Date.now();
    }
    function getComputedStyle$1(el) {
      var window = getWindow();
      var style;
      if (window.getComputedStyle) {
        style = window.getComputedStyle(el, null);
      }
      if (!style && el.currentStyle) {
        style = el.currentStyle;
      }
      if (!style) {
        style = el.style;
      }
      return style;
    }
    function getTranslate(el) {
      var axis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';
      var window = getWindow();
      var matrix;
      var curTransform;
      var transformMatrix;
      var curStyle = getComputedStyle$1(el);
      if (window.WebKitCSSMatrix) {
        curTransform = curStyle.transform || curStyle.webkitTransform;
        if (curTransform.split(',').length > 6) {
          curTransform = curTransform.split(', ').map(function (a) {
            return a.replace(',', '.');
          }).join(', ');
        } // Some old versions of Webkit choke when 'none' is passed; pass
        // empty string instead in this case

        transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
      } else {
        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
        matrix = transformMatrix.toString().split(',');
      }
      if (axis === 'x') {
        // Latest Chrome and webkits Fix
        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers
        else curTransform = parseFloat(matrix[4]);
      }
      if (axis === 'y') {
        // Latest Chrome and webkits Fix
        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers
        else curTransform = parseFloat(matrix[5]);
      }
      return curTransform || 0;
    }
    function isObject(o) {
      return _typeof(o) === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
    }
    function isNode(node) {
      // eslint-disable-next-line
      if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
        return node instanceof HTMLElement;
      }
      return node && (node.nodeType === 1 || node.nodeType === 11);
    }
    function extend() {
      var to = Object(arguments.length <= 0 ? undefined : arguments[0]);
      var noExtend = ['__proto__', 'constructor', 'prototype'];
      for (var i = 1; i < arguments.length; i += 1) {
        var nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];
        if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
          var keysArray = Object.keys(Object(nextSource)).filter(function (key) {
            return noExtend.indexOf(key) < 0;
          });
          for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
            var nextKey = keysArray[nextIndex];
            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
            if (desc !== undefined && desc.enumerable) {
              if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
                if (nextSource[nextKey].__swiper__) {
                  to[nextKey] = nextSource[nextKey];
                } else {
                  extend(to[nextKey], nextSource[nextKey]);
                }
              } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
                to[nextKey] = {};
                if (nextSource[nextKey].__swiper__) {
                  to[nextKey] = nextSource[nextKey];
                } else {
                  extend(to[nextKey], nextSource[nextKey]);
                }
              } else {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
      }
      return to;
    }
    function setCSSProperty(el, varName, varValue) {
      el.style.setProperty(varName, varValue);
    }
    function animateCSSModeScroll(_ref) {
      var swiper = _ref.swiper,
        targetPosition = _ref.targetPosition,
        side = _ref.side;
      var window = getWindow();
      var startPosition = -swiper.translate;
      var startTime = null;
      var time;
      var duration = swiper.params.speed;
      swiper.wrapperEl.style.scrollSnapType = 'none';
      window.cancelAnimationFrame(swiper.cssModeFrameID);
      var dir = targetPosition > startPosition ? 'next' : 'prev';
      var isOutOfBound = function isOutOfBound(current, target) {
        return dir === 'next' && current >= target || dir === 'prev' && current <= target;
      };
      var animate = function animate() {
        time = new Date().getTime();
        if (startTime === null) {
          startTime = time;
        }
        var progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
        var easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
        var currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
        if (isOutOfBound(currentPosition, targetPosition)) {
          currentPosition = targetPosition;
        }
        swiper.wrapperEl.scrollTo(_defineProperty({}, side, currentPosition));
        if (isOutOfBound(currentPosition, targetPosition)) {
          swiper.wrapperEl.style.overflow = 'hidden';
          swiper.wrapperEl.style.scrollSnapType = '';
          setTimeout(function () {
            swiper.wrapperEl.style.overflow = '';
            swiper.wrapperEl.scrollTo(_defineProperty({}, side, currentPosition));
          });
          window.cancelAnimationFrame(swiper.cssModeFrameID);
          return;
        }
        swiper.cssModeFrameID = window.requestAnimationFrame(animate);
      };
      animate();
    }
    var support;
    function calcSupport() {
      var window = getWindow();
      var document = getDocument();
      return {
        smoothScroll: document.documentElement && 'scrollBehavior' in document.documentElement.style,
        touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
        passiveListener: function checkPassiveListener() {
          var supportsPassive = false;
          try {
            var opts = Object.defineProperty({}, 'passive', {
              // eslint-disable-next-line
              get: function get() {
                supportsPassive = true;
              }
            });
            window.addEventListener('testPassiveListener', null, opts);
          } catch (e) {
            // No support
          }
          return supportsPassive;
        }(),
        gestures: function checkGestures() {
          return 'ongesturestart' in window;
        }()
      };
    }
    function getSupport() {
      if (!support) {
        support = calcSupport();
      }
      return support;
    }
    var deviceCached;
    function calcDevice() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        userAgent = _ref2.userAgent;
      var support = getSupport();
      var window = getWindow();
      var platform = window.navigator.platform;
      var ua = userAgent || window.navigator.userAgent;
      var device = {
        ios: false,
        android: false
      };
      var screenWidth = window.screen.width;
      var screenHeight = window.screen.height;
      var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

      var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
      var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
      var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
      var windows = platform === 'Win32';
      var macos = platform === 'MacIntel'; // iPadOs 13 fix

      var iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];
      if (!ipad && macos && support.touch && iPadScreens.indexOf("".concat(screenWidth, "x").concat(screenHeight)) >= 0) {
        ipad = ua.match(/(Version)\/([\d.]+)/);
        if (!ipad) ipad = [0, 1, '13_0_0'];
        macos = false;
      } // Android

      if (android && !windows) {
        device.os = 'android';
        device.android = true;
      }
      if (ipad || iphone || ipod) {
        device.os = 'ios';
        device.ios = true;
      } // Export object

      return device;
    }
    function getDevice() {
      var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (!deviceCached) {
        deviceCached = calcDevice(overrides);
      }
      return deviceCached;
    }
    var browser;
    function calcBrowser() {
      var window = getWindow();
      function isSafari() {
        var ua = window.navigator.userAgent.toLowerCase();
        return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
      }
      return {
        isSafari: isSafari(),
        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
      };
    }
    function getBrowser() {
      if (!browser) {
        browser = calcBrowser();
      }
      return browser;
    }
    function Resize(_ref3) {
      var swiper = _ref3.swiper,
        on = _ref3.on,
        emit = _ref3.emit;
      var window = getWindow();
      var observer = null;
      var resizeHandler = function resizeHandler() {
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        emit('beforeResize');
        emit('resize');
      };
      var createObserver = function createObserver() {
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        observer = new ResizeObserver(function (entries) {
          var width = swiper.width,
            height = swiper.height;
          var newWidth = width;
          var newHeight = height;
          entries.forEach(function (_ref4) {
            var contentBoxSize = _ref4.contentBoxSize,
              contentRect = _ref4.contentRect,
              target = _ref4.target;
            if (target && target !== swiper.el) return;
            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
          });
          if (newWidth !== width || newHeight !== height) {
            resizeHandler();
          }
        });
        observer.observe(swiper.el);
      };
      var removeObserver = function removeObserver() {
        if (observer && observer.unobserve && swiper.el) {
          observer.unobserve(swiper.el);
          observer = null;
        }
      };
      var orientationChangeHandler = function orientationChangeHandler() {
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        emit('orientationchange');
      };
      on('init', function () {
        if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {
          createObserver();
          return;
        }
        window.addEventListener('resize', resizeHandler);
        window.addEventListener('orientationchange', orientationChangeHandler);
      });
      on('destroy', function () {
        removeObserver();
        window.removeEventListener('resize', resizeHandler);
        window.removeEventListener('orientationchange', orientationChangeHandler);
      });
    }
    function Observer(_ref5) {
      var swiper = _ref5.swiper,
        extendParams = _ref5.extendParams,
        on = _ref5.on,
        emit = _ref5.emit;
      var observers = [];
      var window = getWindow();
      var attach = function attach(target) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
        var observer = new ObserverFunc(function (mutations) {
          // The observerUpdate event should only be triggered
          // once despite the number of mutations.  Additional
          // triggers are redundant and are very costly
          if (mutations.length === 1) {
            emit('observerUpdate', mutations[0]);
            return;
          }
          var observerUpdate = function observerUpdate() {
            emit('observerUpdate', mutations[0]);
          };
          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(observerUpdate);
          } else {
            window.setTimeout(observerUpdate, 0);
          }
        });
        observer.observe(target, {
          attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
          childList: typeof options.childList === 'undefined' ? true : options.childList,
          characterData: typeof options.characterData === 'undefined' ? true : options.characterData
        });
        observers.push(observer);
      };
      var init = function init() {
        if (!swiper.params.observer) return;
        if (swiper.params.observeParents) {
          var containerParents = swiper.$el.parents();
          for (var i = 0; i < containerParents.length; i += 1) {
            attach(containerParents[i]);
          }
        } // Observe container

        attach(swiper.$el[0], {
          childList: swiper.params.observeSlideChildren
        }); // Observe wrapper

        attach(swiper.$wrapperEl[0], {
          attributes: false
        });
      };
      var destroy = function destroy() {
        observers.forEach(function (observer) {
          observer.disconnect();
        });
        observers.splice(0, observers.length);
      };
      extendParams({
        observer: false,
        observeParents: false,
        observeSlideChildren: false
      });
      on('init', init);
      on('destroy', destroy);
    }

    /* eslint-disable no-underscore-dangle */
    var eventsEmitter = {
      on: function on(events, handler, priority) {
        var self = this;
        if (typeof handler !== 'function') return self;
        var method = priority ? 'unshift' : 'push';
        events.split(' ').forEach(function (event) {
          if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
          self.eventsListeners[event][method](handler);
        });
        return self;
      },
      once: function once(events, handler, priority) {
        var self = this;
        if (typeof handler !== 'function') return self;
        function onceHandler() {
          self.off(events, onceHandler);
          if (onceHandler.__emitterProxy) {
            delete onceHandler.__emitterProxy;
          }
          for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
            args[_key8] = arguments[_key8];
          }
          handler.apply(self, args);
        }
        onceHandler.__emitterProxy = handler;
        return self.on(events, onceHandler, priority);
      },
      onAny: function onAny(handler, priority) {
        var self = this;
        if (typeof handler !== 'function') return self;
        var method = priority ? 'unshift' : 'push';
        if (self.eventsAnyListeners.indexOf(handler) < 0) {
          self.eventsAnyListeners[method](handler);
        }
        return self;
      },
      offAny: function offAny(handler) {
        var self = this;
        if (!self.eventsAnyListeners) return self;
        var index = self.eventsAnyListeners.indexOf(handler);
        if (index >= 0) {
          self.eventsAnyListeners.splice(index, 1);
        }
        return self;
      },
      off: function off(events, handler) {
        var self = this;
        if (!self.eventsListeners) return self;
        events.split(' ').forEach(function (event) {
          if (typeof handler === 'undefined') {
            self.eventsListeners[event] = [];
          } else if (self.eventsListeners[event]) {
            self.eventsListeners[event].forEach(function (eventHandler, index) {
              if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
                self.eventsListeners[event].splice(index, 1);
              }
            });
          }
        });
        return self;
      },
      emit: function emit() {
        var self = this;
        if (!self.eventsListeners) return self;
        var events;
        var data;
        var context;
        for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
          args[_key9] = arguments[_key9];
        }
        if (typeof args[0] === 'string' || Array.isArray(args[0])) {
          events = args[0];
          data = args.slice(1, args.length);
          context = self;
        } else {
          events = args[0].events;
          data = args[0].data;
          context = args[0].context || self;
        }
        data.unshift(context);
        var eventsArray = Array.isArray(events) ? events : events.split(' ');
        eventsArray.forEach(function (event) {
          if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
            self.eventsAnyListeners.forEach(function (eventHandler) {
              eventHandler.apply(context, [event].concat(_toConsumableArray(data)));
            });
          }
          if (self.eventsListeners && self.eventsListeners[event]) {
            self.eventsListeners[event].forEach(function (eventHandler) {
              eventHandler.apply(context, data);
            });
          }
        });
        return self;
      }
    };
    function updateSize() {
      var swiper = this;
      var width;
      var height;
      var $el = swiper.$el;
      if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
        width = swiper.params.width;
      } else {
        width = $el[0].clientWidth;
      }
      if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
        height = swiper.params.height;
      } else {
        height = $el[0].clientHeight;
      }
      if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
        return;
      } // Subtract paddings

      width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);
      height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);
      if (Number.isNaN(width)) width = 0;
      if (Number.isNaN(height)) height = 0;
      Object.assign(swiper, {
        width: width,
        height: height,
        size: swiper.isHorizontal() ? width : height
      });
    }
    function updateSlides() {
      var swiper = this;
      function getDirectionLabel(property) {
        if (swiper.isHorizontal()) {
          return property;
        } // prettier-ignore

        return {
          width: 'height',
          'margin-top': 'margin-left',
          'margin-bottom ': 'margin-right',
          'margin-left': 'margin-top',
          'margin-right': 'margin-bottom',
          'padding-left': 'padding-top',
          'padding-right': 'padding-bottom',
          marginRight: 'marginBottom'
        }[property];
      }
      function getDirectionPropertyValue(node, label) {
        return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
      }
      var params = swiper.params;
      var $wrapperEl = swiper.$wrapperEl,
        swiperSize = swiper.size,
        rtl = swiper.rtlTranslate,
        wrongRTL = swiper.wrongRTL;
      var isVirtual = swiper.virtual && params.virtual.enabled;
      var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
      var slides = $wrapperEl.children(".".concat(swiper.params.slideClass));
      var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
      var snapGrid = [];
      var slidesGrid = [];
      var slidesSizesGrid = [];
      var offsetBefore = params.slidesOffsetBefore;
      if (typeof offsetBefore === 'function') {
        offsetBefore = params.slidesOffsetBefore.call(swiper);
      }
      var offsetAfter = params.slidesOffsetAfter;
      if (typeof offsetAfter === 'function') {
        offsetAfter = params.slidesOffsetAfter.call(swiper);
      }
      var previousSnapGridLength = swiper.snapGrid.length;
      var previousSlidesGridLength = swiper.slidesGrid.length;
      var spaceBetween = params.spaceBetween;
      var slidePosition = -offsetBefore;
      var prevSlideSize = 0;
      var index = 0;
      if (typeof swiperSize === 'undefined') {
        return;
      }
      if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
        spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
      }
      swiper.virtualSize = -spaceBetween; // reset margins

      if (rtl) slides.css({
        marginLeft: '',
        marginBottom: '',
        marginTop: ''
      });else slides.css({
        marginRight: '',
        marginBottom: '',
        marginTop: ''
      }); // reset cssMode offsets

      if (params.centeredSlides && params.cssMode) {
        setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', '');
        setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', '');
      }
      var gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
      if (gridEnabled) {
        swiper.grid.initSlides(slidesLength);
      } // Calc slides

      var slideSize;
      var shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(function (key) {
        return typeof params.breakpoints[key].slidesPerView !== 'undefined';
      }).length > 0;
      for (var i = 0; i < slidesLength; i += 1) {
        slideSize = 0;
        var _slide = slides.eq(i);
        if (gridEnabled) {
          swiper.grid.updateSlide(i, _slide, slidesLength, getDirectionLabel);
        }
        if (_slide.css('display') === 'none') continue; // eslint-disable-line

        if (params.slidesPerView === 'auto') {
          if (shouldResetSlideSize) {
            slides[i].style[getDirectionLabel('width')] = "";
          }
          var slideStyles = getComputedStyle(_slide[0]);
          var currentTransform = _slide[0].style.transform;
          var currentWebKitTransform = _slide[0].style.webkitTransform;
          if (currentTransform) {
            _slide[0].style.transform = 'none';
          }
          if (currentWebKitTransform) {
            _slide[0].style.webkitTransform = 'none';
          }
          if (params.roundLengths) {
            slideSize = swiper.isHorizontal() ? _slide.outerWidth(true) : _slide.outerHeight(true);
          } else {
            // eslint-disable-next-line
            var width = getDirectionPropertyValue(slideStyles, 'width');
            var paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
            var paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
            var marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
            var marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
            var boxSizing = slideStyles.getPropertyValue('box-sizing');
            if (boxSizing && boxSizing === 'border-box') {
              slideSize = width + marginLeft + marginRight;
            } else {
              var _slide$ = _slide[0],
                clientWidth = _slide$.clientWidth,
                offsetWidth = _slide$.offsetWidth;
              slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
            }
          }
          if (currentTransform) {
            _slide[0].style.transform = currentTransform;
          }
          if (currentWebKitTransform) {
            _slide[0].style.webkitTransform = currentWebKitTransform;
          }
          if (params.roundLengths) slideSize = Math.floor(slideSize);
        } else {
          slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
          if (params.roundLengths) slideSize = Math.floor(slideSize);
          if (slides[i]) {
            slides[i].style[getDirectionLabel('width')] = "".concat(slideSize, "px");
          }
        }
        if (slides[i]) {
          slides[i].swiperSlideSize = slideSize;
        }
        slidesSizesGrid.push(slideSize);
        if (params.centeredSlides) {
          slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
          if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
          if (params.roundLengths) slidePosition = Math.floor(slidePosition);
          if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
        } else {
          if (params.roundLengths) slidePosition = Math.floor(slidePosition);
          if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
          slidePosition = slidePosition + slideSize + spaceBetween;
        }
        swiper.virtualSize += slideSize + spaceBetween;
        prevSlideSize = slideSize;
        index += 1;
      }
      swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
      if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
        $wrapperEl.css({
          width: "".concat(swiper.virtualSize + params.spaceBetween, "px")
        });
      }
      if (params.setWrapperSize) {
        $wrapperEl.css(_defineProperty({}, getDirectionLabel('width'), "".concat(swiper.virtualSize + params.spaceBetween, "px")));
      }
      if (gridEnabled) {
        swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
      } // Remove last grid elements depending on width

      if (!params.centeredSlides) {
        var newSlidesGrid = [];
        for (var _i = 0; _i < snapGrid.length; _i += 1) {
          var slidesGridItem = snapGrid[_i];
          if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
          if (snapGrid[_i] <= swiper.virtualSize - swiperSize) {
            newSlidesGrid.push(slidesGridItem);
          }
        }
        snapGrid = newSlidesGrid;
        if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
          snapGrid.push(swiper.virtualSize - swiperSize);
        }
      }
      if (snapGrid.length === 0) snapGrid = [0];
      if (params.spaceBetween !== 0) {
        var key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
        slides.filter(function (_, slideIndex) {
          if (!params.cssMode) return true;
          if (slideIndex === slides.length - 1) {
            return false;
          }
          return true;
        }).css(_defineProperty({}, key, "".concat(spaceBetween, "px")));
      }
      if (params.centeredSlides && params.centeredSlidesBounds) {
        var allSlidesSize = 0;
        slidesSizesGrid.forEach(function (slideSizeValue) {
          allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        allSlidesSize -= params.spaceBetween;
        var maxSnap = allSlidesSize - swiperSize;
        snapGrid = snapGrid.map(function (snap) {
          if (snap < 0) return -offsetBefore;
          if (snap > maxSnap) return maxSnap + offsetAfter;
          return snap;
        });
      }
      if (params.centerInsufficientSlides) {
        var _allSlidesSize = 0;
        slidesSizesGrid.forEach(function (slideSizeValue) {
          _allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        _allSlidesSize -= params.spaceBetween;
        if (_allSlidesSize < swiperSize) {
          var allSlidesOffset = (swiperSize - _allSlidesSize) / 2;
          snapGrid.forEach(function (snap, snapIndex) {
            snapGrid[snapIndex] = snap - allSlidesOffset;
          });
          slidesGrid.forEach(function (snap, snapIndex) {
            slidesGrid[snapIndex] = snap + allSlidesOffset;
          });
        }
      }
      Object.assign(swiper, {
        slides: slides,
        snapGrid: snapGrid,
        slidesGrid: slidesGrid,
        slidesSizesGrid: slidesSizesGrid
      });
      if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
        setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', "".concat(-snapGrid[0], "px"));
        setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', "".concat(swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2, "px"));
        var addToSnapGrid = -swiper.snapGrid[0];
        var addToSlidesGrid = -swiper.slidesGrid[0];
        swiper.snapGrid = swiper.snapGrid.map(function (v) {
          return v + addToSnapGrid;
        });
        swiper.slidesGrid = swiper.slidesGrid.map(function (v) {
          return v + addToSlidesGrid;
        });
      }
      if (slidesLength !== previousSlidesLength) {
        swiper.emit('slidesLengthChange');
      }
      if (snapGrid.length !== previousSnapGridLength) {
        if (swiper.params.watchOverflow) swiper.checkOverflow();
        swiper.emit('snapGridLengthChange');
      }
      if (slidesGrid.length !== previousSlidesGridLength) {
        swiper.emit('slidesGridLengthChange');
      }
      if (params.watchSlidesProgress) {
        swiper.updateSlidesOffset();
      }
    }
    function updateAutoHeight(speed) {
      var swiper = this;
      var activeSlides = [];
      var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      var newHeight = 0;
      var i;
      if (typeof speed === 'number') {
        swiper.setTransition(speed);
      } else if (speed === true) {
        swiper.setTransition(swiper.params.speed);
      }
      var getSlideByIndex = function getSlideByIndex(index) {
        if (isVirtual) {
          return swiper.slides.filter(function (el) {
            return parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index;
          })[0];
        }
        return swiper.slides.eq(index)[0];
      }; // Find slides currently in view

      if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
        if (swiper.params.centeredSlides) {
          swiper.visibleSlides.each(function (slide) {
            activeSlides.push(slide);
          });
        } else {
          for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
            var _index = swiper.activeIndex + i;
            if (_index > swiper.slides.length && !isVirtual) break;
            activeSlides.push(getSlideByIndex(_index));
          }
        }
      } else {
        activeSlides.push(getSlideByIndex(swiper.activeIndex));
      } // Find new height from highest slide in view

      for (i = 0; i < activeSlides.length; i += 1) {
        if (typeof activeSlides[i] !== 'undefined') {
          var height = activeSlides[i].offsetHeight;
          newHeight = height > newHeight ? height : newHeight;
        }
      } // Update Height

      if (newHeight || newHeight === 0) swiper.$wrapperEl.css('height', "".concat(newHeight, "px"));
    }
    function updateSlidesOffset() {
      var swiper = this;
      var slides = swiper.slides;
      for (var i = 0; i < slides.length; i += 1) {
        slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
      }
    }
    function updateSlidesProgress() {
      var translate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this && this.translate || 0;
      var swiper = this;
      var params = swiper.params;
      var slides = swiper.slides,
        rtl = swiper.rtlTranslate,
        snapGrid = swiper.snapGrid;
      if (slides.length === 0) return;
      if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
      var offsetCenter = -translate;
      if (rtl) offsetCenter = translate; // Visible Slides

      slides.removeClass(params.slideVisibleClass);
      swiper.visibleSlidesIndexes = [];
      swiper.visibleSlides = [];
      for (var i = 0; i < slides.length; i += 1) {
        var _slide2 = slides[i];
        var slideOffset = _slide2.swiperSlideOffset;
        if (params.cssMode && params.centeredSlides) {
          slideOffset -= slides[0].swiperSlideOffset;
        }
        var slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (_slide2.swiperSlideSize + params.spaceBetween);
        var originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (_slide2.swiperSlideSize + params.spaceBetween);
        var slideBefore = -(offsetCenter - slideOffset);
        var slideAfter = slideBefore + swiper.slidesSizesGrid[i];
        var isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
        if (isVisible) {
          swiper.visibleSlides.push(_slide2);
          swiper.visibleSlidesIndexes.push(i);
          slides.eq(i).addClass(params.slideVisibleClass);
        }
        _slide2.progress = rtl ? -slideProgress : slideProgress;
        _slide2.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
      }
      swiper.visibleSlides = $(swiper.visibleSlides);
    }
    function updateProgress(translate) {
      var swiper = this;
      if (typeof translate === 'undefined') {
        var multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line

        translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
      }
      var params = swiper.params;
      var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
      var progress = swiper.progress,
        isBeginning = swiper.isBeginning,
        isEnd = swiper.isEnd;
      var wasBeginning = isBeginning;
      var wasEnd = isEnd;
      if (translatesDiff === 0) {
        progress = 0;
        isBeginning = true;
        isEnd = true;
      } else {
        progress = (translate - swiper.minTranslate()) / translatesDiff;
        isBeginning = progress <= 0;
        isEnd = progress >= 1;
      }
      Object.assign(swiper, {
        progress: progress,
        isBeginning: isBeginning,
        isEnd: isEnd
      });
      if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
      if (isBeginning && !wasBeginning) {
        swiper.emit('reachBeginning toEdge');
      }
      if (isEnd && !wasEnd) {
        swiper.emit('reachEnd toEdge');
      }
      if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
        swiper.emit('fromEdge');
      }
      swiper.emit('progress', progress);
    }
    function updateSlidesClasses() {
      var swiper = this;
      var slides = swiper.slides,
        params = swiper.params,
        $wrapperEl = swiper.$wrapperEl,
        activeIndex = swiper.activeIndex,
        realIndex = swiper.realIndex;
      var isVirtual = swiper.virtual && params.virtual.enabled;
      slides.removeClass("".concat(params.slideActiveClass, " ").concat(params.slideNextClass, " ").concat(params.slidePrevClass, " ").concat(params.slideDuplicateActiveClass, " ").concat(params.slideDuplicateNextClass, " ").concat(params.slideDuplicatePrevClass));
      var activeSlide;
      if (isVirtual) {
        activeSlide = swiper.$wrapperEl.find(".".concat(params.slideClass, "[data-swiper-slide-index=\"").concat(activeIndex, "\"]"));
      } else {
        activeSlide = slides.eq(activeIndex);
      } // Active classes

      activeSlide.addClass(params.slideActiveClass);
      if (params.loop) {
        // Duplicate to all looped slides
        if (activeSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children(".".concat(params.slideClass, ":not(.").concat(params.slideDuplicateClass, ")[data-swiper-slide-index=\"").concat(realIndex, "\"]")).addClass(params.slideDuplicateActiveClass);
        } else {
          $wrapperEl.children(".".concat(params.slideClass, ".").concat(params.slideDuplicateClass, "[data-swiper-slide-index=\"").concat(realIndex, "\"]")).addClass(params.slideDuplicateActiveClass);
        }
      } // Next Slide

      var nextSlide = activeSlide.nextAll(".".concat(params.slideClass)).eq(0).addClass(params.slideNextClass);
      if (params.loop && nextSlide.length === 0) {
        nextSlide = slides.eq(0);
        nextSlide.addClass(params.slideNextClass);
      } // Prev Slide

      var prevSlide = activeSlide.prevAll(".".concat(params.slideClass)).eq(0).addClass(params.slidePrevClass);
      if (params.loop && prevSlide.length === 0) {
        prevSlide = slides.eq(-1);
        prevSlide.addClass(params.slidePrevClass);
      }
      if (params.loop) {
        // Duplicate to all looped slides
        if (nextSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children(".".concat(params.slideClass, ":not(.").concat(params.slideDuplicateClass, ")[data-swiper-slide-index=\"").concat(nextSlide.attr('data-swiper-slide-index'), "\"]")).addClass(params.slideDuplicateNextClass);
        } else {
          $wrapperEl.children(".".concat(params.slideClass, ".").concat(params.slideDuplicateClass, "[data-swiper-slide-index=\"").concat(nextSlide.attr('data-swiper-slide-index'), "\"]")).addClass(params.slideDuplicateNextClass);
        }
        if (prevSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children(".".concat(params.slideClass, ":not(.").concat(params.slideDuplicateClass, ")[data-swiper-slide-index=\"").concat(prevSlide.attr('data-swiper-slide-index'), "\"]")).addClass(params.slideDuplicatePrevClass);
        } else {
          $wrapperEl.children(".".concat(params.slideClass, ".").concat(params.slideDuplicateClass, "[data-swiper-slide-index=\"").concat(prevSlide.attr('data-swiper-slide-index'), "\"]")).addClass(params.slideDuplicatePrevClass);
        }
      }
      swiper.emitSlidesClasses();
    }
    function updateActiveIndex(newActiveIndex) {
      var swiper = this;
      var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
      var slidesGrid = swiper.slidesGrid,
        snapGrid = swiper.snapGrid,
        params = swiper.params,
        previousIndex = swiper.activeIndex,
        previousRealIndex = swiper.realIndex,
        previousSnapIndex = swiper.snapIndex;
      var activeIndex = newActiveIndex;
      var snapIndex;
      if (typeof activeIndex === 'undefined') {
        for (var i = 0; i < slidesGrid.length; i += 1) {
          if (typeof slidesGrid[i + 1] !== 'undefined') {
            if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
              activeIndex = i;
            } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
              activeIndex = i + 1;
            }
          } else if (translate >= slidesGrid[i]) {
            activeIndex = i;
          }
        } // Normalize slideIndex

        if (params.normalizeSlideIndex) {
          if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
        }
      }
      if (snapGrid.indexOf(translate) >= 0) {
        snapIndex = snapGrid.indexOf(translate);
      } else {
        var skip = Math.min(params.slidesPerGroupSkip, activeIndex);
        snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
      }
      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
      if (activeIndex === previousIndex) {
        if (snapIndex !== previousSnapIndex) {
          swiper.snapIndex = snapIndex;
          swiper.emit('snapIndexChange');
        }
        return;
      } // Get real index

      var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
      Object.assign(swiper, {
        snapIndex: snapIndex,
        realIndex: realIndex,
        previousIndex: previousIndex,
        activeIndex: activeIndex
      });
      swiper.emit('activeIndexChange');
      swiper.emit('snapIndexChange');
      if (previousRealIndex !== realIndex) {
        swiper.emit('realIndexChange');
      }
      if (swiper.initialized || swiper.params.runCallbacksOnInit) {
        swiper.emit('slideChange');
      }
    }
    function updateClickedSlide(e) {
      var swiper = this;
      var params = swiper.params;
      var slide = $(e).closest(".".concat(params.slideClass))[0];
      var slideFound = false;
      var slideIndex;
      if (slide) {
        for (var i = 0; i < swiper.slides.length; i += 1) {
          if (swiper.slides[i] === slide) {
            slideFound = true;
            slideIndex = i;
            break;
          }
        }
      }
      if (slide && slideFound) {
        swiper.clickedSlide = slide;
        if (swiper.virtual && swiper.params.virtual.enabled) {
          swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
        } else {
          swiper.clickedIndex = slideIndex;
        }
      } else {
        swiper.clickedSlide = undefined;
        swiper.clickedIndex = undefined;
        return;
      }
      if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
        swiper.slideToClickedSlide();
      }
    }
    var update = {
      updateSize: updateSize,
      updateSlides: updateSlides,
      updateAutoHeight: updateAutoHeight,
      updateSlidesOffset: updateSlidesOffset,
      updateSlidesProgress: updateSlidesProgress,
      updateProgress: updateProgress,
      updateSlidesClasses: updateSlidesClasses,
      updateActiveIndex: updateActiveIndex,
      updateClickedSlide: updateClickedSlide
    };
    function getSwiperTranslate() {
      var axis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isHorizontal() ? 'x' : 'y';
      var swiper = this;
      var params = swiper.params,
        rtl = swiper.rtlTranslate,
        translate = swiper.translate,
        $wrapperEl = swiper.$wrapperEl;
      if (params.virtualTranslate) {
        return rtl ? -translate : translate;
      }
      if (params.cssMode) {
        return translate;
      }
      var currentTranslate = getTranslate($wrapperEl[0], axis);
      if (rtl) currentTranslate = -currentTranslate;
      return currentTranslate || 0;
    }
    function setTranslate(translate, byController) {
      var swiper = this;
      var rtl = swiper.rtlTranslate,
        params = swiper.params,
        $wrapperEl = swiper.$wrapperEl,
        wrapperEl = swiper.wrapperEl,
        progress = swiper.progress;
      var x = 0;
      var y = 0;
      var z = 0;
      if (swiper.isHorizontal()) {
        x = rtl ? -translate : translate;
      } else {
        y = translate;
      }
      if (params.roundLengths) {
        x = Math.floor(x);
        y = Math.floor(y);
      }
      if (params.cssMode) {
        wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
      } else if (!params.virtualTranslate) {
        $wrapperEl.transform("translate3d(".concat(x, "px, ").concat(y, "px, ").concat(z, "px)"));
      }
      swiper.previousTranslate = swiper.translate;
      swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress

      var newProgress;
      var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (translate - swiper.minTranslate()) / translatesDiff;
      }
      if (newProgress !== progress) {
        swiper.updateProgress(translate);
      }
      swiper.emit('setTranslate', swiper.translate, byController);
    }
    function minTranslate() {
      return -this.snapGrid[0];
    }
    function maxTranslate() {
      return -this.snapGrid[this.snapGrid.length - 1];
    }
    function translateTo() {
      var translate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.params.speed;
      var runCallbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var translateBounds = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var internal = arguments.length > 4 ? arguments[4] : undefined;
      var swiper = this;
      var params = swiper.params,
        wrapperEl = swiper.wrapperEl;
      if (swiper.animating && params.preventInteractionOnTransition) {
        return false;
      }
      var minTranslate = swiper.minTranslate();
      var maxTranslate = swiper.maxTranslate();
      var newTranslate;
      if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate; // Update progress

      swiper.updateProgress(newTranslate);
      if (params.cssMode) {
        var isH = swiper.isHorizontal();
        if (speed === 0) {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
        } else {
          var _wrapperEl$scrollTo;
          if (!swiper.support.smoothScroll) {
            animateCSSModeScroll({
              swiper: swiper,
              targetPosition: -newTranslate,
              side: isH ? 'left' : 'top'
            });
            return true;
          }
          wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _defineProperty(_wrapperEl$scrollTo, isH ? 'left' : 'top', -newTranslate), _defineProperty(_wrapperEl$scrollTo, "behavior", 'smooth'), _wrapperEl$scrollTo));
        }
        return true;
      }
      if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(newTranslate);
        if (runCallbacks) {
          swiper.emit('beforeTransitionStart', speed, internal);
          swiper.emit('transitionEnd');
        }
      } else {
        swiper.setTransition(speed);
        swiper.setTranslate(newTranslate);
        if (runCallbacks) {
          swiper.emit('beforeTransitionStart', speed, internal);
          swiper.emit('transitionStart');
        }
        if (!swiper.animating) {
          swiper.animating = true;
          if (!swiper.onTranslateToWrapperTransitionEnd) {
            swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
              if (!swiper || swiper.destroyed) return;
              if (e.target !== this) return;
              swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
              swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
              swiper.onTranslateToWrapperTransitionEnd = null;
              delete swiper.onTranslateToWrapperTransitionEnd;
              if (runCallbacks) {
                swiper.emit('transitionEnd');
              }
            };
          }
          swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
        }
      }
      return true;
    }
    var translate = {
      getTranslate: getSwiperTranslate,
      setTranslate: setTranslate,
      minTranslate: minTranslate,
      maxTranslate: maxTranslate,
      translateTo: translateTo
    };
    function setTransition(duration, byController) {
      var swiper = this;
      if (!swiper.params.cssMode) {
        swiper.$wrapperEl.transition(duration);
      }
      swiper.emit('setTransition', duration, byController);
    }
    function transitionEmit(_ref6) {
      var swiper = _ref6.swiper,
        runCallbacks = _ref6.runCallbacks,
        direction = _ref6.direction,
        step = _ref6.step;
      var activeIndex = swiper.activeIndex,
        previousIndex = swiper.previousIndex;
      var dir = direction;
      if (!dir) {
        if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
      }
      swiper.emit("transition".concat(step));
      if (runCallbacks && activeIndex !== previousIndex) {
        if (dir === 'reset') {
          swiper.emit("slideResetTransition".concat(step));
          return;
        }
        swiper.emit("slideChangeTransition".concat(step));
        if (dir === 'next') {
          swiper.emit("slideNextTransition".concat(step));
        } else {
          swiper.emit("slidePrevTransition".concat(step));
        }
      }
    }
    function transitionStart() {
      var runCallbacks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var direction = arguments.length > 1 ? arguments[1] : undefined;
      var swiper = this;
      var params = swiper.params;
      if (params.cssMode) return;
      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }
      transitionEmit({
        swiper: swiper,
        runCallbacks: runCallbacks,
        direction: direction,
        step: 'Start'
      });
    }
    function transitionEnd() {
      var runCallbacks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var direction = arguments.length > 1 ? arguments[1] : undefined;
      var swiper = this;
      var params = swiper.params;
      swiper.animating = false;
      if (params.cssMode) return;
      swiper.setTransition(0);
      transitionEmit({
        swiper: swiper,
        runCallbacks: runCallbacks,
        direction: direction,
        step: 'End'
      });
    }
    var transition = {
      setTransition: setTransition,
      transitionStart: transitionStart,
      transitionEnd: transitionEnd
    };
    function slideTo() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.params.speed;
      var runCallbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var internal = arguments.length > 3 ? arguments[3] : undefined;
      var initial = arguments.length > 4 ? arguments[4] : undefined;
      if (typeof index !== 'number' && typeof index !== 'string') {
        throw new Error("The 'index' argument cannot have type other than 'number' or 'string'. [".concat(_typeof(index), "] given."));
      }
      if (typeof index === 'string') {
        /**
         * The `index` argument converted from `string` to `number`.
         * @type {number}
         */
        var indexAsNumber = parseInt(index, 10);
        /**
         * Determines whether the `index` argument is a valid `number`
         * after being converted from the `string` type.
         * @type {boolean}
         */

        var isValidNumber = isFinite(indexAsNumber);
        if (!isValidNumber) {
          throw new Error("The passed-in 'index' (string) couldn't be converted to 'number'. [".concat(index, "] given."));
        } // Knowing that the converted `index` is a valid number,
        // we can update the original argument's value.

        index = indexAsNumber;
      }
      var swiper = this;
      var slideIndex = index;
      if (slideIndex < 0) slideIndex = 0;
      var params = swiper.params,
        snapGrid = swiper.snapGrid,
        slidesGrid = swiper.slidesGrid,
        previousIndex = swiper.previousIndex,
        activeIndex = swiper.activeIndex,
        rtl = swiper.rtlTranslate,
        wrapperEl = swiper.wrapperEl,
        enabled = swiper.enabled;
      if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
        return false;
      }
      var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
      var snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
      if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
        swiper.emit('beforeSlideChangeStart');
      }
      var translate = -snapGrid[snapIndex]; // Update progress

      swiper.updateProgress(translate); // Normalize slideIndex

      if (params.normalizeSlideIndex) {
        for (var i = 0; i < slidesGrid.length; i += 1) {
          var normalizedTranslate = -Math.floor(translate * 100);
          var normalizedGrid = Math.floor(slidesGrid[i] * 100);
          var normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
          if (typeof slidesGrid[i + 1] !== 'undefined') {
            if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
              slideIndex = i;
            } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
              slideIndex = i + 1;
            }
          } else if (normalizedTranslate >= normalizedGrid) {
            slideIndex = i;
          }
        }
      } // Directions locks

      if (swiper.initialized && slideIndex !== activeIndex) {
        if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
          return false;
        }
        if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
          if ((activeIndex || 0) !== slideIndex) return false;
        }
      }
      var direction;
      if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index

      if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
        swiper.updateActiveIndex(slideIndex); // Update Height

        if (params.autoHeight) {
          swiper.updateAutoHeight();
        }
        swiper.updateSlidesClasses();
        if (params.effect !== 'slide') {
          swiper.setTranslate(translate);
        }
        if (direction !== 'reset') {
          swiper.transitionStart(runCallbacks, direction);
          swiper.transitionEnd(runCallbacks, direction);
        }
        return false;
      }
      if (params.cssMode) {
        var isH = swiper.isHorizontal();
        var t = rtl ? translate : -translate;
        if (speed === 0) {
          var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
          if (isVirtual) {
            swiper.wrapperEl.style.scrollSnapType = 'none';
            swiper._immediateVirtual = true;
          }
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
          if (isVirtual) {
            requestAnimationFrame(function () {
              swiper.wrapperEl.style.scrollSnapType = '';
              swiper._swiperImmediateVirtual = false;
            });
          }
        } else {
          var _wrapperEl$scrollTo2;
          if (!swiper.support.smoothScroll) {
            animateCSSModeScroll({
              swiper: swiper,
              targetPosition: t,
              side: isH ? 'left' : 'top'
            });
            return true;
          }
          wrapperEl.scrollTo((_wrapperEl$scrollTo2 = {}, _defineProperty(_wrapperEl$scrollTo2, isH ? 'left' : 'top', t), _defineProperty(_wrapperEl$scrollTo2, "behavior", 'smooth'), _wrapperEl$scrollTo2));
        }
        return true;
      }
      swiper.setTransition(speed);
      swiper.setTranslate(translate);
      swiper.updateActiveIndex(slideIndex);
      swiper.updateSlidesClasses();
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.transitionStart(runCallbacks, direction);
      if (speed === 0) {
        swiper.transitionEnd(runCallbacks, direction);
      } else if (!swiper.animating) {
        swiper.animating = true;
        if (!swiper.onSlideToWrapperTransitionEnd) {
          swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
            if (!swiper || swiper.destroyed) return;
            if (e.target !== this) return;
            swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
            swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
            swiper.onSlideToWrapperTransitionEnd = null;
            delete swiper.onSlideToWrapperTransitionEnd;
            swiper.transitionEnd(runCallbacks, direction);
          };
        }
        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
      }
      return true;
    }
    function slideToLoop() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.params.speed;
      var runCallbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var internal = arguments.length > 3 ? arguments[3] : undefined;
      var swiper = this;
      var newIndex = index;
      if (swiper.params.loop) {
        newIndex += swiper.loopedSlides;
      }
      return swiper.slideTo(newIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideNext() {
      var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params.speed;
      var runCallbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var internal = arguments.length > 2 ? arguments[2] : undefined;
      var swiper = this;
      var animating = swiper.animating,
        enabled = swiper.enabled,
        params = swiper.params;
      if (!enabled) return swiper;
      var perGroup = params.slidesPerGroup;
      if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
        perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
      }
      var increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
      if (params.loop) {
        if (animating && params.loopPreventsSlide) return false;
        swiper.loopFix(); // eslint-disable-next-line

        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
      }
      if (params.rewind && swiper.isEnd) {
        return swiper.slideTo(0, speed, runCallbacks, internal);
      }
      return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slidePrev() {
      var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params.speed;
      var runCallbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var internal = arguments.length > 2 ? arguments[2] : undefined;
      var swiper = this;
      var params = swiper.params,
        animating = swiper.animating,
        snapGrid = swiper.snapGrid,
        slidesGrid = swiper.slidesGrid,
        rtlTranslate = swiper.rtlTranslate,
        enabled = swiper.enabled;
      if (!enabled) return swiper;
      if (params.loop) {
        if (animating && params.loopPreventsSlide) return false;
        swiper.loopFix(); // eslint-disable-next-line

        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
      }
      var translate = rtlTranslate ? swiper.translate : -swiper.translate;
      function normalize(val) {
        if (val < 0) return -Math.floor(Math.abs(val));
        return Math.floor(val);
      }
      var normalizedTranslate = normalize(translate);
      var normalizedSnapGrid = snapGrid.map(function (val) {
        return normalize(val);
      });
      var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
      if (typeof prevSnap === 'undefined' && params.cssMode) {
        var prevSnapIndex;
        snapGrid.forEach(function (snap, snapIndex) {
          if (normalizedTranslate >= snap) {
            // prevSnap = snap;
            prevSnapIndex = snapIndex;
          }
        });
        if (typeof prevSnapIndex !== 'undefined') {
          prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
        }
      }
      var prevIndex = 0;
      if (typeof prevSnap !== 'undefined') {
        prevIndex = slidesGrid.indexOf(prevSnap);
        if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
        if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
          prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
          prevIndex = Math.max(prevIndex, 0);
        }
      }
      if (params.rewind && swiper.isBeginning) {
        return swiper.slideTo(swiper.slides.length - 1, speed, runCallbacks, internal);
      }
      return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideReset() {
      var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params.speed;
      var runCallbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var internal = arguments.length > 2 ? arguments[2] : undefined;
      var swiper = this;
      return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideToClosest() {
      var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params.speed;
      var runCallbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var internal = arguments.length > 2 ? arguments[2] : undefined;
      var threshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;
      var swiper = this;
      var index = swiper.activeIndex;
      var skip = Math.min(swiper.params.slidesPerGroupSkip, index);
      var snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
      var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
      if (translate >= swiper.snapGrid[snapIndex]) {
        // The current translate is on or after the current snap index, so the choice
        // is between the current index and the one after it.
        var currentSnap = swiper.snapGrid[snapIndex];
        var nextSnap = swiper.snapGrid[snapIndex + 1];
        if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
          index += swiper.params.slidesPerGroup;
        }
      } else {
        // The current translate is before the current snap index, so the choice
        // is between the current index and the one before it.
        var prevSnap = swiper.snapGrid[snapIndex - 1];
        var _currentSnap = swiper.snapGrid[snapIndex];
        if (translate - prevSnap <= (_currentSnap - prevSnap) * threshold) {
          index -= swiper.params.slidesPerGroup;
        }
      }
      index = Math.max(index, 0);
      index = Math.min(index, swiper.slidesGrid.length - 1);
      return swiper.slideTo(index, speed, runCallbacks, internal);
    }
    function slideToClickedSlide() {
      var swiper = this;
      var params = swiper.params,
        $wrapperEl = swiper.$wrapperEl;
      var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
      var slideToIndex = swiper.clickedIndex;
      var realIndex;
      if (params.loop) {
        if (swiper.animating) return;
        realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);
        if (params.centeredSlides) {
          if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
            swiper.loopFix();
            slideToIndex = $wrapperEl.children(".".concat(params.slideClass, "[data-swiper-slide-index=\"").concat(realIndex, "\"]:not(.").concat(params.slideDuplicateClass, ")")).eq(0).index();
            nextTick(function () {
              swiper.slideTo(slideToIndex);
            });
          } else {
            swiper.slideTo(slideToIndex);
          }
        } else if (slideToIndex > swiper.slides.length - slidesPerView) {
          swiper.loopFix();
          slideToIndex = $wrapperEl.children(".".concat(params.slideClass, "[data-swiper-slide-index=\"").concat(realIndex, "\"]:not(.").concat(params.slideDuplicateClass, ")")).eq(0).index();
          nextTick(function () {
            swiper.slideTo(slideToIndex);
          });
        } else {
          swiper.slideTo(slideToIndex);
        }
      } else {
        swiper.slideTo(slideToIndex);
      }
    }
    var slide = {
      slideTo: slideTo,
      slideToLoop: slideToLoop,
      slideNext: slideNext,
      slidePrev: slidePrev,
      slideReset: slideReset,
      slideToClosest: slideToClosest,
      slideToClickedSlide: slideToClickedSlide
    };
    function loopCreate() {
      var swiper = this;
      var document = getDocument();
      var params = swiper.params,
        $wrapperEl = swiper.$wrapperEl; // Remove duplicated slides

      var $selector = $wrapperEl.children().length > 0 ? $($wrapperEl.children()[0].parentNode) : $wrapperEl;
      $selector.children(".".concat(params.slideClass, ".").concat(params.slideDuplicateClass)).remove();
      var slides = $selector.children(".".concat(params.slideClass));
      if (params.loopFillGroupWithBlank) {
        var blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;
        if (blankSlidesNum !== params.slidesPerGroup) {
          for (var i = 0; i < blankSlidesNum; i += 1) {
            var blankNode = $(document.createElement('div')).addClass("".concat(params.slideClass, " ").concat(params.slideBlankClass));
            $selector.append(blankNode);
          }
          slides = $selector.children(".".concat(params.slideClass));
        }
      }
      if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
      swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
      swiper.loopedSlides += params.loopAdditionalSlides;
      if (swiper.loopedSlides > slides.length) {
        swiper.loopedSlides = slides.length;
      }
      var prependSlides = [];
      var appendSlides = [];
      slides.each(function (el, index) {
        var slide = $(el);
        if (index < swiper.loopedSlides) {
          appendSlides.push(el);
        }
        if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
          prependSlides.push(el);
        }
        slide.attr('data-swiper-slide-index', index);
      });
      for (var _i2 = 0; _i2 < appendSlides.length; _i2 += 1) {
        $selector.append($(appendSlides[_i2].cloneNode(true)).addClass(params.slideDuplicateClass));
      }
      for (var _i3 = prependSlides.length - 1; _i3 >= 0; _i3 -= 1) {
        $selector.prepend($(prependSlides[_i3].cloneNode(true)).addClass(params.slideDuplicateClass));
      }
    }
    function loopFix() {
      var swiper = this;
      swiper.emit('beforeLoopFix');
      var activeIndex = swiper.activeIndex,
        slides = swiper.slides,
        loopedSlides = swiper.loopedSlides,
        allowSlidePrev = swiper.allowSlidePrev,
        allowSlideNext = swiper.allowSlideNext,
        snapGrid = swiper.snapGrid,
        rtl = swiper.rtlTranslate;
      var newIndex;
      swiper.allowSlidePrev = true;
      swiper.allowSlideNext = true;
      var snapTranslate = -snapGrid[activeIndex];
      var diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding

      if (activeIndex < loopedSlides) {
        newIndex = slides.length - loopedSlides * 3 + activeIndex;
        newIndex += loopedSlides;
        var slideChanged = swiper.slideTo(newIndex, 0, false, true);
        if (slideChanged && diff !== 0) {
          swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
      } else if (activeIndex >= slides.length - loopedSlides) {
        // Fix For Positive Oversliding
        newIndex = -slides.length + activeIndex + loopedSlides;
        newIndex += loopedSlides;
        var _slideChanged = swiper.slideTo(newIndex, 0, false, true);
        if (_slideChanged && diff !== 0) {
          swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
      }
      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;
      swiper.emit('loopFix');
    }
    function loopDestroy() {
      var swiper = this;
      var $wrapperEl = swiper.$wrapperEl,
        params = swiper.params,
        slides = swiper.slides;
      $wrapperEl.children(".".concat(params.slideClass, ".").concat(params.slideDuplicateClass, ",.").concat(params.slideClass, ".").concat(params.slideBlankClass)).remove();
      slides.removeAttr('data-swiper-slide-index');
    }
    var loop = {
      loopCreate: loopCreate,
      loopFix: loopFix,
      loopDestroy: loopDestroy
    };
    function setGrabCursor(moving) {
      var swiper = this;
      if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
      var el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
      el.style.cursor = 'move';
      el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
      el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
      el.style.cursor = moving ? 'grabbing' : 'grab';
    }
    function unsetGrabCursor() {
      var swiper = this;
      if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
        return;
      }
      swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
    }
    var grabCursor = {
      setGrabCursor: setGrabCursor,
      unsetGrabCursor: unsetGrabCursor
    };
    function closestElement(selector) {
      var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
      function __closestFrom(el) {
        if (!el || el === getDocument() || el === getWindow()) return null;
        if (el.assignedSlot) el = el.assignedSlot;
        var found = el.closest(selector);
        return found || __closestFrom(el.getRootNode().host);
      }
      return __closestFrom(base);
    }
    function onTouchStart(event) {
      var swiper = this;
      var document = getDocument();
      var window = getWindow();
      var data = swiper.touchEventsData;
      var params = swiper.params,
        touches = swiper.touches,
        enabled = swiper.enabled;
      if (!enabled) return;
      if (swiper.animating && params.preventInteractionOnTransition) {
        return;
      }
      if (!swiper.animating && params.cssMode && params.loop) {
        swiper.loopFix();
      }
      var e = event;
      if (e.originalEvent) e = e.originalEvent;
      var $targetEl = $(e.target);
      if (params.touchEventsTarget === 'wrapper') {
        if (!$targetEl.closest(swiper.wrapperEl).length) return;
      }
      data.isTouchEvent = e.type === 'touchstart';
      if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
      if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
      if (data.isTouched && data.isMoved) return; // change target el for shadow root component

      var swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';
      if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {
        $targetEl = $(event.path[0]);
      }
      var noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : ".".concat(params.noSwipingClass);
      var isTargetShadow = !!(e.target && e.target.shadowRoot); // use closestElement for shadow root element to get the actual closest for nested shadow root element

      if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, e.target) : $targetEl.closest(noSwipingSelector)[0])) {
        swiper.allowClick = true;
        return;
      }
      if (params.swipeHandler) {
        if (!$targetEl.closest(params.swipeHandler)[0]) return;
      }
      touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      var startX = touches.currentX;
      var startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

      var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
      var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
      if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
        if (edgeSwipeDetection === 'prevent') {
          event.preventDefault();
        } else {
          return;
        }
      }
      Object.assign(data, {
        isTouched: true,
        isMoved: false,
        allowTouchCallbacks: true,
        isScrolling: undefined,
        startMoving: undefined
      });
      touches.startX = startX;
      touches.startY = startY;
      data.touchStartTime = now();
      swiper.allowClick = true;
      swiper.updateSize();
      swiper.swipeDirection = undefined;
      if (params.threshold > 0) data.allowThresholdMove = false;
      if (e.type !== 'touchstart') {
        var preventDefault = true;
        if ($targetEl.is(data.focusableElements)) preventDefault = false;
        if (document.activeElement && $(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) {
          document.activeElement.blur();
        }
        var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
        if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
          e.preventDefault();
        }
      }
      swiper.emit('touchStart', e);
    }
    function onTouchMove(event) {
      var document = getDocument();
      var swiper = this;
      var data = swiper.touchEventsData;
      var params = swiper.params,
        touches = swiper.touches,
        rtl = swiper.rtlTranslate,
        enabled = swiper.enabled;
      if (!enabled) return;
      var e = event;
      if (e.originalEvent) e = e.originalEvent;
      if (!data.isTouched) {
        if (data.startMoving && data.isScrolling) {
          swiper.emit('touchMoveOpposite', e);
        }
        return;
      }
      if (data.isTouchEvent && e.type !== 'touchmove') return;
      var targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
      var pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
      var pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;
      if (e.preventedByNestedSwiper) {
        touches.startX = pageX;
        touches.startY = pageY;
        return;
      }
      if (!swiper.allowTouchMove) {
        // isMoved = true;
        swiper.allowClick = false;
        if (data.isTouched) {
          Object.assign(touches, {
            startX: pageX,
            startY: pageY,
            currentX: pageX,
            currentY: pageY
          });
          data.touchStartTime = now();
        }
        return;
      }
      if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
        if (swiper.isVertical()) {
          // Vertical
          if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
            data.isTouched = false;
            data.isMoved = false;
            return;
          }
        } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
          return;
        }
      }
      if (data.isTouchEvent && document.activeElement) {
        if (e.target === document.activeElement && $(e.target).is(data.focusableElements)) {
          data.isMoved = true;
          swiper.allowClick = false;
          return;
        }
      }
      if (data.allowTouchCallbacks) {
        swiper.emit('touchMove', e);
      }
      if (e.targetTouches && e.targetTouches.length > 1) return;
      touches.currentX = pageX;
      touches.currentY = pageY;
      var diffX = touches.currentX - touches.startX;
      var diffY = touches.currentY - touches.startY;
      if (swiper.params.threshold && Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) < swiper.params.threshold) return;
      if (typeof data.isScrolling === 'undefined') {
        var touchAngle;
        if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
          data.isScrolling = false;
        } else {
          // eslint-disable-next-line
          if (diffX * diffX + diffY * diffY >= 25) {
            touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
            data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
          }
        }
      }
      if (data.isScrolling) {
        swiper.emit('touchMoveOpposite', e);
      }
      if (typeof data.startMoving === 'undefined') {
        if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
          data.startMoving = true;
        }
      }
      if (data.isScrolling) {
        data.isTouched = false;
        return;
      }
      if (!data.startMoving) {
        return;
      }
      swiper.allowClick = false;
      if (!params.cssMode && e.cancelable) {
        e.preventDefault();
      }
      if (params.touchMoveStopPropagation && !params.nested) {
        e.stopPropagation();
      }
      if (!data.isMoved) {
        if (params.loop && !params.cssMode) {
          swiper.loopFix();
        }
        data.startTranslate = swiper.getTranslate();
        swiper.setTransition(0);
        if (swiper.animating) {
          swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
        }
        data.allowMomentumBounce = false; // Grab Cursor

        if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
          swiper.setGrabCursor(true);
        }
        swiper.emit('sliderFirstMove', e);
      }
      swiper.emit('sliderMove', e);
      data.isMoved = true;
      var diff = swiper.isHorizontal() ? diffX : diffY;
      touches.diff = diff;
      diff *= params.touchRatio;
      if (rtl) diff = -diff;
      swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
      data.currentTranslate = diff + data.startTranslate;
      var disableParentSwiper = true;
      var resistanceRatio = params.resistanceRatio;
      if (params.touchReleaseOnEdges) {
        resistanceRatio = 0;
      }
      if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + Math.pow(-swiper.minTranslate() + data.startTranslate + diff, resistanceRatio);
      } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - Math.pow(swiper.maxTranslate() - data.startTranslate - diff, resistanceRatio);
      }
      if (disableParentSwiper) {
        e.preventedByNestedSwiper = true;
      } // Directions locks

      if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
        data.currentTranslate = data.startTranslate;
      }
      if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
        data.currentTranslate = data.startTranslate;
      }
      if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
        data.currentTranslate = data.startTranslate;
      } // Threshold

      if (params.threshold > 0) {
        if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
          if (!data.allowThresholdMove) {
            data.allowThresholdMove = true;
            touches.startX = touches.currentX;
            touches.startY = touches.currentY;
            data.currentTranslate = data.startTranslate;
            touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
            return;
          }
        } else {
          data.currentTranslate = data.startTranslate;
          return;
        }
      }
      if (!params.followFinger || params.cssMode) return; // Update active index in free mode

      if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }
      if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {
        swiper.freeMode.onTouchMove();
      } // Update progress

      swiper.updateProgress(data.currentTranslate); // Update translate

      swiper.setTranslate(data.currentTranslate);
    }
    function onTouchEnd(event) {
      var swiper = this;
      var data = swiper.touchEventsData;
      var params = swiper.params,
        touches = swiper.touches,
        rtl = swiper.rtlTranslate,
        slidesGrid = swiper.slidesGrid,
        enabled = swiper.enabled;
      if (!enabled) return;
      var e = event;
      if (e.originalEvent) e = e.originalEvent;
      if (data.allowTouchCallbacks) {
        swiper.emit('touchEnd', e);
      }
      data.allowTouchCallbacks = false;
      if (!data.isTouched) {
        if (data.isMoved && params.grabCursor) {
          swiper.setGrabCursor(false);
        }
        data.isMoved = false;
        data.startMoving = false;
        return;
      } // Return Grab Cursor

      if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(false);
      } // Time diff

      var touchEndTime = now();
      var timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click

      if (swiper.allowClick) {
        var pathTree = e.path || e.composedPath && e.composedPath();
        swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);
        swiper.emit('tap click', e);
        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
          swiper.emit('doubleTap doubleClick', e);
        }
      }
      data.lastClickTime = now();
      nextTick(function () {
        if (!swiper.destroyed) swiper.allowClick = true;
      });
      if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
        data.isTouched = false;
        data.isMoved = false;
        data.startMoving = false;
        return;
      }
      data.isTouched = false;
      data.isMoved = false;
      data.startMoving = false;
      var currentPos;
      if (params.followFinger) {
        currentPos = rtl ? swiper.translate : -swiper.translate;
      } else {
        currentPos = -data.currentTranslate;
      }
      if (params.cssMode) {
        return;
      }
      if (swiper.params.freeMode && params.freeMode.enabled) {
        swiper.freeMode.onTouchEnd({
          currentPos: currentPos
        });
        return;
      } // Find current slide

      var stopIndex = 0;
      var groupSize = swiper.slidesSizesGrid[0];
      for (var i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
        var _increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
        if (typeof slidesGrid[i + _increment] !== 'undefined') {
          if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + _increment]) {
            stopIndex = i;
            groupSize = slidesGrid[i + _increment] - slidesGrid[i];
          }
        } else if (currentPos >= slidesGrid[i]) {
          stopIndex = i;
          groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
        }
      } // Find current slide size

      var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
      var increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
      if (timeDiff > params.longSwipesMs) {
        // Long touches
        if (!params.longSwipes) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }
        if (swiper.swipeDirection === 'next') {
          if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
        }
        if (swiper.swipeDirection === 'prev') {
          if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
        }
      } else {
        // Short swipes
        if (!params.shortSwipes) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }
        var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
        if (!isNavButtonTarget) {
          if (swiper.swipeDirection === 'next') {
            swiper.slideTo(stopIndex + increment);
          }
          if (swiper.swipeDirection === 'prev') {
            swiper.slideTo(stopIndex);
          }
        } else if (e.target === swiper.navigation.nextEl) {
          swiper.slideTo(stopIndex + increment);
        } else {
          swiper.slideTo(stopIndex);
        }
      }
    }
    function onResize() {
      var swiper = this;
      var params = swiper.params,
        el = swiper.el;
      if (el && el.offsetWidth === 0) return; // Breakpoints

      if (params.breakpoints) {
        swiper.setBreakpoint();
      } // Save locks

      var allowSlideNext = swiper.allowSlideNext,
        allowSlidePrev = swiper.allowSlidePrev,
        snapGrid = swiper.snapGrid; // Disable locks on resize

      swiper.allowSlideNext = true;
      swiper.allowSlidePrev = true;
      swiper.updateSize();
      swiper.updateSlides();
      swiper.updateSlidesClasses();
      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
        swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        swiper.autoplay.run();
      } // Return locks after resize

      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;
      if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
      }
    }
    function onClick(e) {
      var swiper = this;
      if (!swiper.enabled) return;
      if (!swiper.allowClick) {
        if (swiper.params.preventClicks) e.preventDefault();
        if (swiper.params.preventClicksPropagation && swiper.animating) {
          e.stopPropagation();
          e.stopImmediatePropagation();
        }
      }
    }
    function onScroll() {
      var swiper = this;
      var wrapperEl = swiper.wrapperEl,
        rtlTranslate = swiper.rtlTranslate,
        enabled = swiper.enabled;
      if (!enabled) return;
      swiper.previousTranslate = swiper.translate;
      if (swiper.isHorizontal()) {
        swiper.translate = -wrapperEl.scrollLeft;
      } else {
        swiper.translate = -wrapperEl.scrollTop;
      } // eslint-disable-next-line

      if (swiper.translate === -0) swiper.translate = 0;
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
      var newProgress;
      var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
      }
      if (newProgress !== swiper.progress) {
        swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
      }
      swiper.emit('setTranslate', swiper.translate, false);
    }
    var dummyEventAttached = false;
    function dummyEventListener() {}
    var events = function events(swiper, method) {
      var document = getDocument();
      var params = swiper.params,
        touchEvents = swiper.touchEvents,
        el = swiper.el,
        wrapperEl = swiper.wrapperEl,
        device = swiper.device,
        support = swiper.support;
      var capture = !!params.nested;
      var domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
      var swiperMethod = method; // Touch Events

      if (!support.touch) {
        el[domMethod](touchEvents.start, swiper.onTouchStart, false);
        document[domMethod](touchEvents.move, swiper.onTouchMove, capture);
        document[domMethod](touchEvents.end, swiper.onTouchEnd, false);
      } else {
        var passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {
          passive: true,
          capture: false
        } : false;
        el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);
        el[domMethod](touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
          passive: false,
          capture: capture
        } : capture);
        el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);
        if (touchEvents.cancel) {
          el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);
        }
      } // Prevent Links Clicks

      if (params.preventClicks || params.preventClicksPropagation) {
        el[domMethod]('click', swiper.onClick, true);
      }
      if (params.cssMode) {
        wrapperEl[domMethod]('scroll', swiper.onScroll);
      } // Resize handler

      if (params.updateOnWindowResize) {
        swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
      } else {
        swiper[swiperMethod]('observerUpdate', onResize, true);
      }
    };
    function attachEvents() {
      var swiper = this;
      var document = getDocument();
      var params = swiper.params,
        support = swiper.support;
      swiper.onTouchStart = onTouchStart.bind(swiper);
      swiper.onTouchMove = onTouchMove.bind(swiper);
      swiper.onTouchEnd = onTouchEnd.bind(swiper);
      if (params.cssMode) {
        swiper.onScroll = onScroll.bind(swiper);
      }
      swiper.onClick = onClick.bind(swiper);
      if (support.touch && !dummyEventAttached) {
        document.addEventListener('touchstart', dummyEventListener);
        dummyEventAttached = true;
      }
      events(swiper, 'on');
    }
    function detachEvents() {
      var swiper = this;
      events(swiper, 'off');
    }
    var events$1 = {
      attachEvents: attachEvents,
      detachEvents: detachEvents
    };
    var isGridEnabled = function isGridEnabled(swiper, params) {
      return swiper.grid && params.grid && params.grid.rows > 1;
    };
    function setBreakpoint() {
      var swiper = this;
      var activeIndex = swiper.activeIndex,
        initialized = swiper.initialized,
        _swiper$loopedSlides = swiper.loopedSlides,
        loopedSlides = _swiper$loopedSlides === void 0 ? 0 : _swiper$loopedSlides,
        params = swiper.params,
        $el = swiper.$el;
      var breakpoints = params.breakpoints;
      if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return; // Get breakpoint for window width and update parameters

      var breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
      if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
      var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
      var breakpointParams = breakpointOnlyParams || swiper.originalParams;
      var wasMultiRow = isGridEnabled(swiper, params);
      var isMultiRow = isGridEnabled(swiper, breakpointParams);
      var wasEnabled = params.enabled;
      if (wasMultiRow && !isMultiRow) {
        $el.removeClass("".concat(params.containerModifierClass, "grid ").concat(params.containerModifierClass, "grid-column"));
        swiper.emitContainerClasses();
      } else if (!wasMultiRow && isMultiRow) {
        $el.addClass("".concat(params.containerModifierClass, "grid"));
        if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
          $el.addClass("".concat(params.containerModifierClass, "grid-column"));
        }
        swiper.emitContainerClasses();
      }
      var directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
      var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
      if (directionChanged && initialized) {
        swiper.changeDirection();
      }
      extend(swiper.params, breakpointParams);
      var isEnabled = swiper.params.enabled;
      Object.assign(swiper, {
        allowTouchMove: swiper.params.allowTouchMove,
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev
      });
      if (wasEnabled && !isEnabled) {
        swiper.disable();
      } else if (!wasEnabled && isEnabled) {
        swiper.enable();
      }
      swiper.currentBreakpoint = breakpoint;
      swiper.emit('_beforeBreakpoint', breakpointParams);
      if (needsReLoop && initialized) {
        swiper.loopDestroy();
        swiper.loopCreate();
        swiper.updateSlides();
        swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
      }
      swiper.emit('breakpoint', breakpointParams);
    }
    function getBreakpoint(breakpoints) {
      var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'window';
      var containerEl = arguments.length > 2 ? arguments[2] : undefined;
      if (!breakpoints || base === 'container' && !containerEl) return undefined;
      var breakpoint = false;
      var window = getWindow();
      var currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
      var points = Object.keys(breakpoints).map(function (point) {
        if (typeof point === 'string' && point.indexOf('@') === 0) {
          var minRatio = parseFloat(point.substr(1));
          var value = currentHeight * minRatio;
          return {
            value: value,
            point: point
          };
        }
        return {
          value: point,
          point: point
        };
      });
      points.sort(function (a, b) {
        return parseInt(a.value, 10) - parseInt(b.value, 10);
      });
      for (var i = 0; i < points.length; i += 1) {
        var _points$i = points[i],
          point = _points$i.point,
          value = _points$i.value;
        if (base === 'window') {
          if (window.matchMedia("(min-width: ".concat(value, "px)")).matches) {
            breakpoint = point;
          }
        } else if (value <= containerEl.clientWidth) {
          breakpoint = point;
        }
      }
      return breakpoint || 'max';
    }
    var breakpoints = {
      setBreakpoint: setBreakpoint,
      getBreakpoint: getBreakpoint
    };
    function prepareClasses(entries, prefix) {
      var resultClasses = [];
      entries.forEach(function (item) {
        if (_typeof(item) === 'object') {
          Object.keys(item).forEach(function (classNames) {
            if (item[classNames]) {
              resultClasses.push(prefix + classNames);
            }
          });
        } else if (typeof item === 'string') {
          resultClasses.push(prefix + item);
        }
      });
      return resultClasses;
    }
    function addClasses() {
      var swiper = this;
      var classNames = swiper.classNames,
        params = swiper.params,
        rtl = swiper.rtl,
        $el = swiper.$el,
        device = swiper.device,
        support = swiper.support; // prettier-ignore

      var suffixes = prepareClasses(['initialized', params.direction, {
        'pointer-events': !support.touch
      }, {
        'free-mode': swiper.params.freeMode && params.freeMode.enabled
      }, {
        autoheight: params.autoHeight
      }, {
        rtl: rtl
      }, {
        grid: params.grid && params.grid.rows > 1
      }, {
        'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
      }, {
        android: device.android
      }, {
        ios: device.ios
      }, {
        'css-mode': params.cssMode
      }, {
        centered: params.cssMode && params.centeredSlides
      }], params.containerModifierClass);
      classNames.push.apply(classNames, _toConsumableArray(suffixes));
      $el.addClass(_toConsumableArray(classNames).join(' '));
      swiper.emitContainerClasses();
    }
    function removeClasses() {
      var swiper = this;
      var $el = swiper.$el,
        classNames = swiper.classNames;
      $el.removeClass(classNames.join(' '));
      swiper.emitContainerClasses();
    }
    var classes = {
      addClasses: addClasses,
      removeClasses: removeClasses
    };
    function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
      var window = getWindow();
      var image;
      function onReady() {
        if (callback) callback();
      }
      var isPicture = $(imageEl).parent('picture')[0];
      if (!isPicture && (!imageEl.complete || !checkForComplete)) {
        if (src) {
          image = new window.Image();
          image.onload = onReady;
          image.onerror = onReady;
          if (sizes) {
            image.sizes = sizes;
          }
          if (srcset) {
            image.srcset = srcset;
          }
          if (src) {
            image.src = src;
          }
        } else {
          onReady();
        }
      } else {
        // image already loaded...
        onReady();
      }
    }
    function preloadImages() {
      var swiper = this;
      swiper.imagesToLoad = swiper.$el.find('img');
      function onReady() {
        if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
        if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;
        if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
          if (swiper.params.updateOnImagesReady) swiper.update();
          swiper.emit('imagesReady');
        }
      }
      for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {
        var imageEl = swiper.imagesToLoad[i];
        swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
      }
    }
    var images = {
      loadImage: loadImage,
      preloadImages: preloadImages
    };
    function checkOverflow() {
      var swiper = this;
      var wasLocked = swiper.isLocked,
        params = swiper.params;
      var slidesOffsetBefore = params.slidesOffsetBefore;
      if (slidesOffsetBefore) {
        var lastSlideIndex = swiper.slides.length - 1;
        var lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
        swiper.isLocked = swiper.size > lastSlideRightEdge;
      } else {
        swiper.isLocked = swiper.snapGrid.length === 1;
      }
      if (params.allowSlideNext === true) {
        swiper.allowSlideNext = !swiper.isLocked;
      }
      if (params.allowSlidePrev === true) {
        swiper.allowSlidePrev = !swiper.isLocked;
      }
      if (wasLocked && wasLocked !== swiper.isLocked) {
        swiper.isEnd = false;
      }
      if (wasLocked !== swiper.isLocked) {
        swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
      }
    }
    var checkOverflow$1 = {
      checkOverflow: checkOverflow
    };
    var defaults = {
      init: true,
      direction: 'horizontal',
      touchEventsTarget: 'wrapper',
      initialSlide: 0,
      speed: 300,
      cssMode: false,
      updateOnWindowResize: true,
      resizeObserver: true,
      nested: false,
      createElements: false,
      enabled: true,
      focusableElements: 'input, select, option, textarea, button, video, label',
      // Overrides
      width: null,
      height: null,
      //
      preventInteractionOnTransition: false,
      // ssr
      userAgent: null,
      url: null,
      // To support iOS's swipe-to-go-back gesture (when being used in-app).
      edgeSwipeDetection: false,
      edgeSwipeThreshold: 20,
      // Autoheight
      autoHeight: false,
      // Set wrapper width
      setWrapperSize: false,
      // Virtual Translate
      virtualTranslate: false,
      // Effects
      effect: 'slide',
      // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
      // Breakpoints
      breakpoints: undefined,
      breakpointsBase: 'window',
      // Slides grid
      spaceBetween: 0,
      slidesPerView: 1,
      slidesPerGroup: 1,
      slidesPerGroupSkip: 0,
      slidesPerGroupAuto: false,
      centeredSlides: false,
      centeredSlidesBounds: false,
      slidesOffsetBefore: 0,
      // in px
      slidesOffsetAfter: 0,
      // in px
      normalizeSlideIndex: true,
      centerInsufficientSlides: false,
      // Disable swiper and hide navigation when container not overflow
      watchOverflow: true,
      // Round length
      roundLengths: false,
      // Touches
      touchRatio: 1,
      touchAngle: 45,
      simulateTouch: true,
      shortSwipes: true,
      longSwipes: true,
      longSwipesRatio: 0.5,
      longSwipesMs: 300,
      followFinger: true,
      allowTouchMove: true,
      threshold: 0,
      touchMoveStopPropagation: false,
      touchStartPreventDefault: true,
      touchStartForcePreventDefault: false,
      touchReleaseOnEdges: false,
      // Unique Navigation Elements
      uniqueNavElements: true,
      // Resistance
      resistance: true,
      resistanceRatio: 0.85,
      // Progress
      watchSlidesProgress: false,
      // Cursor
      grabCursor: false,
      // Clicks
      preventClicks: true,
      preventClicksPropagation: true,
      slideToClickedSlide: false,
      // Images
      preloadImages: true,
      updateOnImagesReady: true,
      // loop
      loop: false,
      loopAdditionalSlides: 0,
      loopedSlides: null,
      loopFillGroupWithBlank: false,
      loopPreventsSlide: true,
      // rewind
      rewind: false,
      // Swiping/no swiping
      allowSlidePrev: true,
      allowSlideNext: true,
      swipeHandler: null,
      // '.swipe-handler',
      noSwiping: true,
      noSwipingClass: 'swiper-no-swiping',
      noSwipingSelector: null,
      // Passive Listeners
      passiveListeners: true,
      // NS
      containerModifierClass: 'swiper-',
      // NEW
      slideClass: 'swiper-slide',
      slideBlankClass: 'swiper-slide-invisible-blank',
      slideActiveClass: 'swiper-slide-active',
      slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
      slideVisibleClass: 'swiper-slide-visible',
      slideDuplicateClass: 'swiper-slide-duplicate',
      slideNextClass: 'swiper-slide-next',
      slideDuplicateNextClass: 'swiper-slide-duplicate-next',
      slidePrevClass: 'swiper-slide-prev',
      slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
      wrapperClass: 'swiper-wrapper',
      // Callbacks
      runCallbacksOnInit: true,
      // Internals
      _emitClasses: false
    };
    function moduleExtendParams(params, allModulesParams) {
      return function extendParams() {
        var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var moduleParamName = Object.keys(obj)[0];
        var moduleParams = obj[moduleParamName];
        if (_typeof(moduleParams) !== 'object' || moduleParams === null) {
          extend(allModulesParams, obj);
          return;
        }
        if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
          params[moduleParamName] = {
            auto: true
          };
        }
        if (!(moduleParamName in params && 'enabled' in moduleParams)) {
          extend(allModulesParams, obj);
          return;
        }
        if (params[moduleParamName] === true) {
          params[moduleParamName] = {
            enabled: true
          };
        }
        if (_typeof(params[moduleParamName]) === 'object' && !('enabled' in params[moduleParamName])) {
          params[moduleParamName].enabled = true;
        }
        if (!params[moduleParamName]) params[moduleParamName] = {
          enabled: false
        };
        extend(allModulesParams, obj);
      };
    }

    /* eslint no-param-reassign: "off" */
    var prototypes = {
      eventsEmitter: eventsEmitter,
      update: update,
      translate: translate,
      transition: transition,
      slide: slide,
      loop: loop,
      grabCursor: grabCursor,
      events: events$1,
      breakpoints: breakpoints,
      checkOverflow: checkOverflow$1,
      classes: classes,
      images: images
    };
    var extendedDefaults = {};
    var Swiper = /*#__PURE__*/function () {
      function Swiper() {
        _classCallCheck(this, Swiper);
        var el;
        var params;
        for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
          args[_key10] = arguments[_key10];
        }
        if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
          params = args[0];
        } else {
          el = args[0];
          params = args[1];
        }
        if (!params) params = {};
        params = extend({}, params);
        if (el && !params.el) params.el = el;
        if (params.el && $(params.el).length > 1) {
          var swipers = [];
          $(params.el).each(function (containerEl) {
            var newParams = extend({}, params, {
              el: containerEl
            });
            swipers.push(new Swiper(newParams));
          });
          return swipers;
        } // Swiper Instance

        var swiper = this;
        swiper.__swiper__ = true;
        swiper.support = getSupport();
        swiper.device = getDevice({
          userAgent: params.userAgent
        });
        swiper.browser = getBrowser();
        swiper.eventsListeners = {};
        swiper.eventsAnyListeners = [];
        swiper.modules = _toConsumableArray(swiper.__modules__);
        if (params.modules && Array.isArray(params.modules)) {
          var _swiper$modules;
          (_swiper$modules = swiper.modules).push.apply(_swiper$modules, _toConsumableArray(params.modules));
        }
        var allModulesParams = {};
        swiper.modules.forEach(function (mod) {
          mod({
            swiper: swiper,
            extendParams: moduleExtendParams(params, allModulesParams),
            on: swiper.on.bind(swiper),
            once: swiper.once.bind(swiper),
            off: swiper.off.bind(swiper),
            emit: swiper.emit.bind(swiper)
          });
        }); // Extend defaults with modules params

        var swiperParams = extend({}, defaults, allModulesParams); // Extend defaults with passed params

        swiper.params = extend({}, swiperParams, extendedDefaults, params);
        swiper.originalParams = extend({}, swiper.params);
        swiper.passedParams = extend({}, params); // add event listeners

        if (swiper.params && swiper.params.on) {
          Object.keys(swiper.params.on).forEach(function (eventName) {
            swiper.on(eventName, swiper.params.on[eventName]);
          });
        }
        if (swiper.params && swiper.params.onAny) {
          swiper.onAny(swiper.params.onAny);
        } // Save Dom lib

        swiper.$ = $; // Extend Swiper

        Object.assign(swiper, {
          enabled: swiper.params.enabled,
          el: el,
          // Classes
          classNames: [],
          // Slides
          slides: $(),
          slidesGrid: [],
          snapGrid: [],
          slidesSizesGrid: [],
          // isDirection
          isHorizontal: function isHorizontal() {
            return swiper.params.direction === 'horizontal';
          },
          isVertical: function isVertical() {
            return swiper.params.direction === 'vertical';
          },
          // Indexes
          activeIndex: 0,
          realIndex: 0,
          //
          isBeginning: true,
          isEnd: false,
          // Props
          translate: 0,
          previousTranslate: 0,
          progress: 0,
          velocity: 0,
          animating: false,
          // Locks
          allowSlideNext: swiper.params.allowSlideNext,
          allowSlidePrev: swiper.params.allowSlidePrev,
          // Touch Events
          touchEvents: function touchEvents() {
            var touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
            var desktop = ['pointerdown', 'pointermove', 'pointerup'];
            swiper.touchEventsTouch = {
              start: touch[0],
              move: touch[1],
              end: touch[2],
              cancel: touch[3]
            };
            swiper.touchEventsDesktop = {
              start: desktop[0],
              move: desktop[1],
              end: desktop[2]
            };
            return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
          }(),
          touchEventsData: {
            isTouched: undefined,
            isMoved: undefined,
            allowTouchCallbacks: undefined,
            touchStartTime: undefined,
            isScrolling: undefined,
            currentTranslate: undefined,
            startTranslate: undefined,
            allowThresholdMove: undefined,
            // Form elements to match
            focusableElements: swiper.params.focusableElements,
            // Last click time
            lastClickTime: now(),
            clickTimeout: undefined,
            // Velocities
            velocities: [],
            allowMomentumBounce: undefined,
            isTouchEvent: undefined,
            startMoving: undefined
          },
          // Clicks
          allowClick: true,
          // Touches
          allowTouchMove: swiper.params.allowTouchMove,
          touches: {
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            diff: 0
          },
          // Images
          imagesToLoad: [],
          imagesLoaded: 0
        });
        swiper.emit('_swiper'); // Init

        if (swiper.params.init) {
          swiper.init();
        } // Return app instance

        return swiper;
      }
      _createClass(Swiper, [{
        key: "enable",
        value: function enable() {
          var swiper = this;
          if (swiper.enabled) return;
          swiper.enabled = true;
          if (swiper.params.grabCursor) {
            swiper.setGrabCursor();
          }
          swiper.emit('enable');
        }
      }, {
        key: "disable",
        value: function disable() {
          var swiper = this;
          if (!swiper.enabled) return;
          swiper.enabled = false;
          if (swiper.params.grabCursor) {
            swiper.unsetGrabCursor();
          }
          swiper.emit('disable');
        }
      }, {
        key: "setProgress",
        value: function setProgress(progress, speed) {
          var swiper = this;
          progress = Math.min(Math.max(progress, 0), 1);
          var min = swiper.minTranslate();
          var max = swiper.maxTranslate();
          var current = (max - min) * progress + min;
          swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        }
      }, {
        key: "emitContainerClasses",
        value: function emitContainerClasses() {
          var swiper = this;
          if (!swiper.params._emitClasses || !swiper.el) return;
          var cls = swiper.el.className.split(' ').filter(function (className) {
            return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
          });
          swiper.emit('_containerClasses', cls.join(' '));
        }
      }, {
        key: "getSlideClasses",
        value: function getSlideClasses(slideEl) {
          var swiper = this;
          return slideEl.className.split(' ').filter(function (className) {
            return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
          }).join(' ');
        }
      }, {
        key: "emitSlidesClasses",
        value: function emitSlidesClasses() {
          var swiper = this;
          if (!swiper.params._emitClasses || !swiper.el) return;
          var updates = [];
          swiper.slides.each(function (slideEl) {
            var classNames = swiper.getSlideClasses(slideEl);
            updates.push({
              slideEl: slideEl,
              classNames: classNames
            });
            swiper.emit('_slideClass', slideEl, classNames);
          });
          swiper.emit('_slideClasses', updates);
        }
      }, {
        key: "slidesPerViewDynamic",
        value: function slidesPerViewDynamic() {
          var view = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'current';
          var exact = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var swiper = this;
          var params = swiper.params,
            slides = swiper.slides,
            slidesGrid = swiper.slidesGrid,
            slidesSizesGrid = swiper.slidesSizesGrid,
            swiperSize = swiper.size,
            activeIndex = swiper.activeIndex;
          var spv = 1;
          if (params.centeredSlides) {
            var slideSize = slides[activeIndex].swiperSlideSize;
            var breakLoop;
            for (var i = activeIndex + 1; i < slides.length; i += 1) {
              if (slides[i] && !breakLoop) {
                slideSize += slides[i].swiperSlideSize;
                spv += 1;
                if (slideSize > swiperSize) breakLoop = true;
              }
            }
            for (var _i4 = activeIndex - 1; _i4 >= 0; _i4 -= 1) {
              if (slides[_i4] && !breakLoop) {
                slideSize += slides[_i4].swiperSlideSize;
                spv += 1;
                if (slideSize > swiperSize) breakLoop = true;
              }
            }
          } else {
            // eslint-disable-next-line
            if (view === 'current') {
              for (var _i5 = activeIndex + 1; _i5 < slides.length; _i5 += 1) {
                var slideInView = exact ? slidesGrid[_i5] + slidesSizesGrid[_i5] - slidesGrid[activeIndex] < swiperSize : slidesGrid[_i5] - slidesGrid[activeIndex] < swiperSize;
                if (slideInView) {
                  spv += 1;
                }
              }
            } else {
              // previous
              for (var _i6 = activeIndex - 1; _i6 >= 0; _i6 -= 1) {
                var _slideInView = slidesGrid[activeIndex] - slidesGrid[_i6] < swiperSize;
                if (_slideInView) {
                  spv += 1;
                }
              }
            }
          }
          return spv;
        }
      }, {
        key: "update",
        value: function update() {
          var swiper = this;
          if (!swiper || swiper.destroyed) return;
          var snapGrid = swiper.snapGrid,
            params = swiper.params; // Breakpoints

          if (params.breakpoints) {
            swiper.setBreakpoint();
          }
          swiper.updateSize();
          swiper.updateSlides();
          swiper.updateProgress();
          swiper.updateSlidesClasses();
          function setTranslate() {
            var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
            var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
            swiper.setTranslate(newTranslate);
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
          }
          var translated;
          if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
            setTranslate();
            if (swiper.params.autoHeight) {
              swiper.updateAutoHeight();
            }
          } else {
            if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
              translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
            } else {
              translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
            }
            if (!translated) {
              setTranslate();
            }
          }
          if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
            swiper.checkOverflow();
          }
          swiper.emit('update');
        }
      }, {
        key: "changeDirection",
        value: function changeDirection(newDirection) {
          var needUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var swiper = this;
          var currentDirection = swiper.params.direction;
          if (!newDirection) {
            // eslint-disable-next-line
            newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
          }
          if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
            return swiper;
          }
          swiper.$el.removeClass("".concat(swiper.params.containerModifierClass).concat(currentDirection)).addClass("".concat(swiper.params.containerModifierClass).concat(newDirection));
          swiper.emitContainerClasses();
          swiper.params.direction = newDirection;
          swiper.slides.each(function (slideEl) {
            if (newDirection === 'vertical') {
              slideEl.style.width = '';
            } else {
              slideEl.style.height = '';
            }
          });
          swiper.emit('changeDirection');
          if (needUpdate) swiper.update();
          return swiper;
        }
      }, {
        key: "mount",
        value: function mount(el) {
          var swiper = this;
          if (swiper.mounted) return true; // Find el

          var $el = $(el || swiper.params.el);
          el = $el[0];
          if (!el) {
            return false;
          }
          el.swiper = swiper;
          var getWrapperSelector = function getWrapperSelector() {
            return ".".concat((swiper.params.wrapperClass || '').trim().split(' ').join('.'));
          };
          var getWrapper = function getWrapper() {
            if (el && el.shadowRoot && el.shadowRoot.querySelector) {
              var res = $(el.shadowRoot.querySelector(getWrapperSelector())); // Children needs to return slot items

              res.children = function (options) {
                return $el.children(options);
              };
              return res;
            }
            return $el.children(getWrapperSelector());
          }; // Find Wrapper

          var $wrapperEl = getWrapper();
          if ($wrapperEl.length === 0 && swiper.params.createElements) {
            var _document2 = getDocument();
            var wrapper = _document2.createElement('div');
            $wrapperEl = $(wrapper);
            wrapper.className = swiper.params.wrapperClass;
            $el.append(wrapper);
            $el.children(".".concat(swiper.params.slideClass)).each(function (slideEl) {
              $wrapperEl.append(slideEl);
            });
          }
          Object.assign(swiper, {
            $el: $el,
            el: el,
            $wrapperEl: $wrapperEl,
            wrapperEl: $wrapperEl[0],
            mounted: true,
            // RTL
            rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
            rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
            wrongRTL: $wrapperEl.css('display') === '-webkit-box'
          });
          return true;
        }
      }, {
        key: "init",
        value: function init(el) {
          var swiper = this;
          if (swiper.initialized) return swiper;
          var mounted = swiper.mount(el);
          if (mounted === false) return swiper;
          swiper.emit('beforeInit'); // Set breakpoint

          if (swiper.params.breakpoints) {
            swiper.setBreakpoint();
          } // Add Classes

          swiper.addClasses(); // Create loop

          if (swiper.params.loop) {
            swiper.loopCreate();
          } // Update size

          swiper.updateSize(); // Update slides

          swiper.updateSlides();
          if (swiper.params.watchOverflow) {
            swiper.checkOverflow();
          } // Set Grab Cursor

          if (swiper.params.grabCursor && swiper.enabled) {
            swiper.setGrabCursor();
          }
          if (swiper.params.preloadImages) {
            swiper.preloadImages();
          } // Slide To Initial Slide

          if (swiper.params.loop) {
            swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
          } else {
            swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
          } // Attach events

          swiper.attachEvents(); // Init Flag

          swiper.initialized = true; // Emit

          swiper.emit('init');
          swiper.emit('afterInit');
          return swiper;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          var deleteInstance = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
          var cleanStyles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var swiper = this;
          var params = swiper.params,
            $el = swiper.$el,
            $wrapperEl = swiper.$wrapperEl,
            slides = swiper.slides;
          if (typeof swiper.params === 'undefined' || swiper.destroyed) {
            return null;
          }
          swiper.emit('beforeDestroy'); // Init Flag

          swiper.initialized = false; // Detach events

          swiper.detachEvents(); // Destroy loop

          if (params.loop) {
            swiper.loopDestroy();
          } // Cleanup styles

          if (cleanStyles) {
            swiper.removeClasses();
            $el.removeAttr('style');
            $wrapperEl.removeAttr('style');
            if (slides && slides.length) {
              slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');
            }
          }
          swiper.emit('destroy'); // Detach emitter events

          Object.keys(swiper.eventsListeners).forEach(function (eventName) {
            swiper.off(eventName);
          });
          if (deleteInstance !== false) {
            swiper.$el[0].swiper = null;
            deleteProps(swiper);
          }
          swiper.destroyed = true;
          return null;
        }
      }], [{
        key: "extendDefaults",
        value: function extendDefaults(newDefaults) {
          extend(extendedDefaults, newDefaults);
        }
      }, {
        key: "extendedDefaults",
        get: function get() {
          return extendedDefaults;
        }
      }, {
        key: "defaults",
        get: function get() {
          return defaults;
        }
      }, {
        key: "installModule",
        value: function installModule(mod) {
          if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
          var modules = Swiper.prototype.__modules__;
          if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
            modules.push(mod);
          }
        }
      }, {
        key: "use",
        value: function use(module) {
          if (Array.isArray(module)) {
            module.forEach(function (m) {
              return Swiper.installModule(m);
            });
            return Swiper;
          }
          Swiper.installModule(module);
          return Swiper;
        }
      }]);
      return Swiper;
    }();
    Object.keys(prototypes).forEach(function (prototypeGroup) {
      Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {
        Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
      });
    });
    Swiper.use([Resize, Observer]);
    function Virtual(_ref7) {
      var swiper = _ref7.swiper,
        extendParams = _ref7.extendParams,
        on = _ref7.on;
      extendParams({
        virtual: {
          enabled: false,
          slides: [],
          cache: true,
          renderSlide: null,
          renderExternal: null,
          renderExternalUpdate: true,
          addSlidesBefore: 0,
          addSlidesAfter: 0
        }
      });
      var cssModeTimeout;
      swiper.virtual = {
        cache: {},
        from: undefined,
        to: undefined,
        slides: [],
        offset: 0,
        slidesGrid: []
      };
      function renderSlide(slide, index) {
        var params = swiper.params.virtual;
        if (params.cache && swiper.virtual.cache[index]) {
          return swiper.virtual.cache[index];
        }
        var $slideEl = params.renderSlide ? $(params.renderSlide.call(swiper, slide, index)) : $("<div class=\"".concat(swiper.params.slideClass, "\" data-swiper-slide-index=\"").concat(index, "\">").concat(slide, "</div>"));
        if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);
        if (params.cache) swiper.virtual.cache[index] = $slideEl;
        return $slideEl;
      }
      function update(force) {
        var _swiper$params = swiper.params,
          slidesPerView = _swiper$params.slidesPerView,
          slidesPerGroup = _swiper$params.slidesPerGroup,
          centeredSlides = _swiper$params.centeredSlides;
        var _swiper$params$virtua = swiper.params.virtual,
          addSlidesBefore = _swiper$params$virtua.addSlidesBefore,
          addSlidesAfter = _swiper$params$virtua.addSlidesAfter;
        var _swiper$virtual = swiper.virtual,
          previousFrom = _swiper$virtual.from,
          previousTo = _swiper$virtual.to,
          slides = _swiper$virtual.slides,
          previousSlidesGrid = _swiper$virtual.slidesGrid,
          previousOffset = _swiper$virtual.offset;
        if (!swiper.params.cssMode) {
          swiper.updateActiveIndex();
        }
        var activeIndex = swiper.activeIndex || 0;
        var offsetProp;
        if (swiper.rtlTranslate) offsetProp = 'right';else offsetProp = swiper.isHorizontal() ? 'left' : 'top';
        var slidesAfter;
        var slidesBefore;
        if (centeredSlides) {
          slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
          slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
        } else {
          slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
          slidesBefore = slidesPerGroup + addSlidesBefore;
        }
        var from = Math.max((activeIndex || 0) - slidesBefore, 0);
        var to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
        var offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
        Object.assign(swiper.virtual, {
          from: from,
          to: to,
          offset: offset,
          slidesGrid: swiper.slidesGrid
        });
        function onRendered() {
          swiper.updateSlides();
          swiper.updateProgress();
          swiper.updateSlidesClasses();
          if (swiper.lazy && swiper.params.lazy.enabled) {
            swiper.lazy.load();
          }
        }
        if (previousFrom === from && previousTo === to && !force) {
          if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
            swiper.slides.css(offsetProp, "".concat(offset, "px"));
          }
          swiper.updateProgress();
          return;
        }
        if (swiper.params.virtual.renderExternal) {
          swiper.params.virtual.renderExternal.call(swiper, {
            offset: offset,
            from: from,
            to: to,
            slides: function getSlides() {
              var slidesToRender = [];
              for (var i = from; i <= to; i += 1) {
                slidesToRender.push(slides[i]);
              }
              return slidesToRender;
            }()
          });
          if (swiper.params.virtual.renderExternalUpdate) {
            onRendered();
          }
          return;
        }
        var prependIndexes = [];
        var appendIndexes = [];
        if (force) {
          swiper.$wrapperEl.find(".".concat(swiper.params.slideClass)).remove();
        } else {
          for (var i = previousFrom; i <= previousTo; i += 1) {
            if (i < from || i > to) {
              swiper.$wrapperEl.find(".".concat(swiper.params.slideClass, "[data-swiper-slide-index=\"").concat(i, "\"]")).remove();
            }
          }
        }
        for (var _i7 = 0; _i7 < slides.length; _i7 += 1) {
          if (_i7 >= from && _i7 <= to) {
            if (typeof previousTo === 'undefined' || force) {
              appendIndexes.push(_i7);
            } else {
              if (_i7 > previousTo) appendIndexes.push(_i7);
              if (_i7 < previousFrom) prependIndexes.push(_i7);
            }
          }
        }
        appendIndexes.forEach(function (index) {
          swiper.$wrapperEl.append(renderSlide(slides[index], index));
        });
        prependIndexes.sort(function (a, b) {
          return b - a;
        }).forEach(function (index) {
          swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
        });
        swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, "".concat(offset, "px"));
        onRendered();
      }
      function appendSlide(slides) {
        if (_typeof(slides) === 'object' && 'length' in slides) {
          for (var i = 0; i < slides.length; i += 1) {
            if (slides[i]) swiper.virtual.slides.push(slides[i]);
          }
        } else {
          swiper.virtual.slides.push(slides);
        }
        update(true);
      }
      function prependSlide(slides) {
        var activeIndex = swiper.activeIndex;
        var newActiveIndex = activeIndex + 1;
        var numberOfNewSlides = 1;
        if (Array.isArray(slides)) {
          for (var i = 0; i < slides.length; i += 1) {
            if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
          }
          newActiveIndex = activeIndex + slides.length;
          numberOfNewSlides = slides.length;
        } else {
          swiper.virtual.slides.unshift(slides);
        }
        if (swiper.params.virtual.cache) {
          var cache = swiper.virtual.cache;
          var newCache = {};
          Object.keys(cache).forEach(function (cachedIndex) {
            var $cachedEl = cache[cachedIndex];
            var cachedElIndex = $cachedEl.attr('data-swiper-slide-index');
            if (cachedElIndex) {
              $cachedEl.attr('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);
            }
            newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
          });
          swiper.virtual.cache = newCache;
        }
        update(true);
        swiper.slideTo(newActiveIndex, 0);
      }
      function removeSlide(slidesIndexes) {
        if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
        var activeIndex = swiper.activeIndex;
        if (Array.isArray(slidesIndexes)) {
          for (var i = slidesIndexes.length - 1; i >= 0; i -= 1) {
            swiper.virtual.slides.splice(slidesIndexes[i], 1);
            if (swiper.params.virtual.cache) {
              delete swiper.virtual.cache[slidesIndexes[i]];
            }
            if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
            activeIndex = Math.max(activeIndex, 0);
          }
        } else {
          swiper.virtual.slides.splice(slidesIndexes, 1);
          if (swiper.params.virtual.cache) {
            delete swiper.virtual.cache[slidesIndexes];
          }
          if (slidesIndexes < activeIndex) activeIndex -= 1;
          activeIndex = Math.max(activeIndex, 0);
        }
        update(true);
        swiper.slideTo(activeIndex, 0);
      }
      function removeAllSlides() {
        swiper.virtual.slides = [];
        if (swiper.params.virtual.cache) {
          swiper.virtual.cache = {};
        }
        update(true);
        swiper.slideTo(0, 0);
      }
      on('beforeInit', function () {
        if (!swiper.params.virtual.enabled) return;
        swiper.virtual.slides = swiper.params.virtual.slides;
        swiper.classNames.push("".concat(swiper.params.containerModifierClass, "virtual"));
        swiper.params.watchSlidesProgress = true;
        swiper.originalParams.watchSlidesProgress = true;
        if (!swiper.params.initialSlide) {
          update();
        }
      });
      on('setTranslate', function () {
        if (!swiper.params.virtual.enabled) return;
        if (swiper.params.cssMode && !swiper._immediateVirtual) {
          clearTimeout(cssModeTimeout);
          cssModeTimeout = setTimeout(function () {
            update();
          }, 100);
        } else {
          update();
        }
      });
      on('init update resize', function () {
        if (!swiper.params.virtual.enabled) return;
        if (swiper.params.cssMode) {
          setCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', "".concat(swiper.virtualSize, "px"));
        }
      });
      Object.assign(swiper.virtual, {
        appendSlide: appendSlide,
        prependSlide: prependSlide,
        removeSlide: removeSlide,
        removeAllSlides: removeAllSlides,
        update: update
      });
    }

    /* eslint-disable consistent-return */
    function Keyboard(_ref8) {
      var swiper = _ref8.swiper,
        extendParams = _ref8.extendParams,
        on = _ref8.on,
        emit = _ref8.emit;
      var document = getDocument();
      var window = getWindow();
      swiper.keyboard = {
        enabled: false
      };
      extendParams({
        keyboard: {
          enabled: false,
          onlyInViewport: true,
          pageUpDown: true
        }
      });
      function handle(event) {
        if (!swiper.enabled) return;
        var rtl = swiper.rtlTranslate;
        var e = event;
        if (e.originalEvent) e = e.originalEvent; // jquery fix

        var kc = e.keyCode || e.charCode;
        var pageUpDown = swiper.params.keyboard.pageUpDown;
        var isPageUp = pageUpDown && kc === 33;
        var isPageDown = pageUpDown && kc === 34;
        var isArrowLeft = kc === 37;
        var isArrowRight = kc === 39;
        var isArrowUp = kc === 38;
        var isArrowDown = kc === 40; // Directions locks

        if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
          return false;
        }
        if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
          return false;
        }
        if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
          return undefined;
        }
        if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
          return undefined;
        }
        if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
          var inView = false; // Check that swiper should be inside of visible area of window

          if (swiper.$el.parents(".".concat(swiper.params.slideClass)).length > 0 && swiper.$el.parents(".".concat(swiper.params.slideActiveClass)).length === 0) {
            return undefined;
          }
          var $el = swiper.$el;
          var swiperWidth = $el[0].clientWidth;
          var swiperHeight = $el[0].clientHeight;
          var windowWidth = window.innerWidth;
          var windowHeight = window.innerHeight;
          var swiperOffset = swiper.$el.offset();
          if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
          var swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];
          for (var i = 0; i < swiperCoord.length; i += 1) {
            var point = swiperCoord[i];
            if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
              if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line

              inView = true;
            }
          }
          if (!inView) return undefined;
        }
        if (swiper.isHorizontal()) {
          if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
            if (e.preventDefault) e.preventDefault();else e.returnValue = false;
          }
          if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();
          if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();
        } else {
          if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
            if (e.preventDefault) e.preventDefault();else e.returnValue = false;
          }
          if (isPageDown || isArrowDown) swiper.slideNext();
          if (isPageUp || isArrowUp) swiper.slidePrev();
        }
        emit('keyPress', kc);
        return undefined;
      }
      function enable() {
        if (swiper.keyboard.enabled) return;
        $(document).on('keydown', handle);
        swiper.keyboard.enabled = true;
      }
      function disable() {
        if (!swiper.keyboard.enabled) return;
        $(document).off('keydown', handle);
        swiper.keyboard.enabled = false;
      }
      on('init', function () {
        if (swiper.params.keyboard.enabled) {
          enable();
        }
      });
      on('destroy', function () {
        if (swiper.keyboard.enabled) {
          disable();
        }
      });
      Object.assign(swiper.keyboard, {
        enable: enable,
        disable: disable
      });
    }

    /* eslint-disable consistent-return */
    function Mousewheel(_ref9) {
      var swiper = _ref9.swiper,
        extendParams = _ref9.extendParams,
        on = _ref9.on,
        emit = _ref9.emit;
      var window = getWindow();
      extendParams({
        mousewheel: {
          enabled: false,
          releaseOnEdges: false,
          invert: false,
          forceToAxis: false,
          sensitivity: 1,
          eventsTarget: 'container',
          thresholdDelta: null,
          thresholdTime: null
        }
      });
      swiper.mousewheel = {
        enabled: false
      };
      var timeout;
      var lastScrollTime = now();
      var lastEventBeforeSnap;
      var recentWheelEvents = [];
      function normalize(e) {
        // Reasonable defaults
        var PIXEL_STEP = 10;
        var LINE_HEIGHT = 40;
        var PAGE_HEIGHT = 800;
        var sX = 0;
        var sY = 0; // spinX, spinY

        var pX = 0;
        var pY = 0; // pixelX, pixelY
        // Legacy

        if ('detail' in e) {
          sY = e.detail;
        }
        if ('wheelDelta' in e) {
          sY = -e.wheelDelta / 120;
        }
        if ('wheelDeltaY' in e) {
          sY = -e.wheelDeltaY / 120;
        }
        if ('wheelDeltaX' in e) {
          sX = -e.wheelDeltaX / 120;
        } // side scrolling on FF with DOMMouseScroll

        if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
          sX = sY;
          sY = 0;
        }
        pX = sX * PIXEL_STEP;
        pY = sY * PIXEL_STEP;
        if ('deltaY' in e) {
          pY = e.deltaY;
        }
        if ('deltaX' in e) {
          pX = e.deltaX;
        }
        if (e.shiftKey && !pX) {
          // if user scrolls with shift he wants horizontal scroll
          pX = pY;
          pY = 0;
        }
        if ((pX || pY) && e.deltaMode) {
          if (e.deltaMode === 1) {
            // delta in LINE units
            pX *= LINE_HEIGHT;
            pY *= LINE_HEIGHT;
          } else {
            // delta in PAGE units
            pX *= PAGE_HEIGHT;
            pY *= PAGE_HEIGHT;
          }
        } // Fall-back if spin cannot be determined

        if (pX && !sX) {
          sX = pX < 1 ? -1 : 1;
        }
        if (pY && !sY) {
          sY = pY < 1 ? -1 : 1;
        }
        return {
          spinX: sX,
          spinY: sY,
          pixelX: pX,
          pixelY: pY
        };
      }
      function handleMouseEnter() {
        if (!swiper.enabled) return;
        swiper.mouseEntered = true;
      }
      function handleMouseLeave() {
        if (!swiper.enabled) return;
        swiper.mouseEntered = false;
      }
      function animateSlider(newEvent) {
        if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {
          // Prevent if delta of wheel scroll delta is below configured threshold
          return false;
        }
        if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {
          // Prevent if time between scrolls is below configured threshold
          return false;
        } // If the movement is NOT big enough and
        // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
        //   Don't go any further (avoid insignificant scroll movement).

        if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {
          // Return false as a default
          return true;
        } // If user is scrolling towards the end:
        //   If the slider hasn't hit the latest slide or
        //   if the slider is a loop and
        //   if the slider isn't moving right now:
        //     Go to next slide and
        //     emit a scroll event.
        // Else (the user is scrolling towards the beginning) and
        // if the slider hasn't hit the first slide or
        // if the slider is a loop and
        // if the slider isn't moving right now:
        //   Go to prev slide and
        //   emit a scroll event.

        if (newEvent.direction < 0) {
          if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
            swiper.slideNext();
            emit('scroll', newEvent.raw);
          }
        } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
          swiper.slidePrev();
          emit('scroll', newEvent.raw);
        } // If you got here is because an animation has been triggered so store the current time

        lastScrollTime = new window.Date().getTime(); // Return false as a default

        return false;
      }
      function releaseScroll(newEvent) {
        var params = swiper.params.mousewheel;
        if (newEvent.direction < 0) {
          if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
            // Return true to animate scroll on edges
            return true;
          }
        } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
          // Return true to animate scroll on edges
          return true;
        }
        return false;
      }
      function handle(event) {
        var e = event;
        var disableParentSwiper = true;
        if (!swiper.enabled) return;
        var params = swiper.params.mousewheel;
        if (swiper.params.cssMode) {
          e.preventDefault();
        }
        var target = swiper.$el;
        if (swiper.params.mousewheel.eventsTarget !== 'container') {
          target = $(swiper.params.mousewheel.eventsTarget);
        }
        if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;
        if (e.originalEvent) e = e.originalEvent; // jquery fix

        var delta = 0;
        var rtlFactor = swiper.rtlTranslate ? -1 : 1;
        var data = normalize(e);
        if (params.forceToAxis) {
          if (swiper.isHorizontal()) {
            if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;
          } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;
        } else {
          delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
        }
        if (delta === 0) return true;
        if (params.invert) delta = -delta; // Get the scroll positions

        var positions = swiper.getTranslate() + delta * params.sensitivity;
        if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
        if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate(); // When loop is true:
        //     the disableParentSwiper will be true.
        // When loop is false:
        //     if the scroll positions is not on edge,
        //     then the disableParentSwiper will be true.
        //     if the scroll on edge positions,
        //     then the disableParentSwiper will be false.

        disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
        if (disableParentSwiper && swiper.params.nested) e.stopPropagation();
        if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
          // Register the new event in a variable which stores the relevant data
          var newEvent = {
            time: now(),
            delta: Math.abs(delta),
            direction: Math.sign(delta),
            raw: event
          }; // Keep the most recent events

          if (recentWheelEvents.length >= 2) {
            recentWheelEvents.shift(); // only store the last N events
          }

          var prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
          recentWheelEvents.push(newEvent); // If there is at least one previous recorded event:
          //   If direction has changed or
          //   if the scroll is quicker than the previous one:
          //     Animate the slider.
          // Else (this is the first time the wheel is moved):
          //     Animate the slider.

          if (prevEvent) {
            if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
              animateSlider(newEvent);
            }
          } else {
            animateSlider(newEvent);
          } // If it's time to release the scroll:
          //   Return now so you don't hit the preventDefault.

          if (releaseScroll(newEvent)) {
            return true;
          }
        } else {
          // Freemode or scrollContainer:
          // If we recently snapped after a momentum scroll, then ignore wheel events
          // to give time for the deceleration to finish. Stop ignoring after 500 msecs
          // or if it's a new scroll (larger delta or inverse sign as last event before
          // an end-of-momentum snap).
          var _newEvent = {
            time: now(),
            delta: Math.abs(delta),
            direction: Math.sign(delta)
          };
          var ignoreWheelEvents = lastEventBeforeSnap && _newEvent.time < lastEventBeforeSnap.time + 500 && _newEvent.delta <= lastEventBeforeSnap.delta && _newEvent.direction === lastEventBeforeSnap.direction;
          if (!ignoreWheelEvents) {
            lastEventBeforeSnap = undefined;
            if (swiper.params.loop) {
              swiper.loopFix();
            }
            var position = swiper.getTranslate() + delta * params.sensitivity;
            var wasBeginning = swiper.isBeginning;
            var wasEnd = swiper.isEnd;
            if (position >= swiper.minTranslate()) position = swiper.minTranslate();
            if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
            swiper.setTransition(0);
            swiper.setTranslate(position);
            swiper.updateProgress();
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
            if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
              swiper.updateSlidesClasses();
            }
            if (swiper.params.freeMode.sticky) {
              // When wheel scrolling starts with sticky (aka snap) enabled, then detect
              // the end of a momentum scroll by storing recent (N=15?) wheel events.
              // 1. do all N events have decreasing or same (absolute value) delta?
              // 2. did all N events arrive in the last M (M=500?) msecs?
              // 3. does the earliest event have an (absolute value) delta that's
              //    at least P (P=1?) larger than the most recent event's delta?
              // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
              // If 1-4 are "yes" then we're near the end of a momentum scroll deceleration.
              // Snap immediately and ignore remaining wheel events in this scroll.
              // See comment above for "remaining wheel events in this scroll" determination.
              // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
              clearTimeout(timeout);
              timeout = undefined;
              if (recentWheelEvents.length >= 15) {
                recentWheelEvents.shift(); // only store the last N events
              }

              var _prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
              var firstEvent = recentWheelEvents[0];
              recentWheelEvents.push(_newEvent);
              if (_prevEvent && (_newEvent.delta > _prevEvent.delta || _newEvent.direction !== _prevEvent.direction)) {
                // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
                recentWheelEvents.splice(0);
              } else if (recentWheelEvents.length >= 15 && _newEvent.time - firstEvent.time < 500 && firstEvent.delta - _newEvent.delta >= 1 && _newEvent.delta <= 6) {
                // We're at the end of the deceleration of a momentum scroll, so there's no need
                // to wait for more events. Snap ASAP on the next tick.
                // Also, because there's some remaining momentum we'll bias the snap in the
                // direction of the ongoing scroll because it's better UX for the scroll to snap
                // in the same direction as the scroll instead of reversing to snap.  Therefore,
                // if it's already scrolled more than 20% in the current direction, keep going.
                var snapToThreshold = delta > 0 ? 0.8 : 0.2;
                lastEventBeforeSnap = _newEvent;
                recentWheelEvents.splice(0);
                timeout = nextTick(function () {
                  swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
                }, 0); // no delay; move on next tick
              }

              if (!timeout) {
                // if we get here, then we haven't detected the end of a momentum scroll, so
                // we'll consider a scroll "complete" when there haven't been any wheel events
                // for 500ms.
                timeout = nextTick(function () {
                  var snapToThreshold = 0.5;
                  lastEventBeforeSnap = _newEvent;
                  recentWheelEvents.splice(0);
                  swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
                }, 500);
              }
            } // Emit event

            if (!ignoreWheelEvents) emit('scroll', e); // Stop autoplay

            if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop(); // Return page scroll on edge positions

            if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
          }
        }
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
        return false;
      }
      function events(method) {
        var target = swiper.$el;
        if (swiper.params.mousewheel.eventsTarget !== 'container') {
          target = $(swiper.params.mousewheel.eventsTarget);
        }
        target[method]('mouseenter', handleMouseEnter);
        target[method]('mouseleave', handleMouseLeave);
        target[method]('wheel', handle);
      }
      function enable() {
        if (swiper.params.cssMode) {
          swiper.wrapperEl.removeEventListener('wheel', handle);
          return true;
        }
        if (swiper.mousewheel.enabled) return false;
        events('on');
        swiper.mousewheel.enabled = true;
        return true;
      }
      function disable() {
        if (swiper.params.cssMode) {
          swiper.wrapperEl.addEventListener(event, handle);
          return true;
        }
        if (!swiper.mousewheel.enabled) return false;
        events('off');
        swiper.mousewheel.enabled = false;
        return true;
      }
      on('init', function () {
        if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
          disable();
        }
        if (swiper.params.mousewheel.enabled) enable();
      });
      on('destroy', function () {
        if (swiper.params.cssMode) {
          enable();
        }
        if (swiper.mousewheel.enabled) disable();
      });
      Object.assign(swiper.mousewheel, {
        enable: enable,
        disable: disable
      });
    }
    function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
      var document = getDocument();
      if (swiper.params.createElements) {
        Object.keys(checkProps).forEach(function (key) {
          if (!params[key] && params.auto === true) {
            var element = swiper.$el.children(".".concat(checkProps[key]))[0];
            if (!element) {
              element = document.createElement('div');
              element.className = checkProps[key];
              swiper.$el.append(element);
            }
            params[key] = element;
            originalParams[key] = element;
          }
        });
      }
      return params;
    }
    function Navigation(_ref10) {
      var swiper = _ref10.swiper,
        extendParams = _ref10.extendParams,
        on = _ref10.on,
        emit = _ref10.emit;
      extendParams({
        navigation: {
          nextEl: null,
          prevEl: null,
          hideOnClick: false,
          disabledClass: 'swiper-button-disabled',
          hiddenClass: 'swiper-button-hidden',
          lockClass: 'swiper-button-lock'
        }
      });
      swiper.navigation = {
        nextEl: null,
        $nextEl: null,
        prevEl: null,
        $prevEl: null
      };
      function getEl(el) {
        var $el;
        if (el) {
          $el = $(el);
          if (swiper.params.uniqueNavElements && typeof el === 'string' && $el.length > 1 && swiper.$el.find(el).length === 1) {
            $el = swiper.$el.find(el);
          }
        }
        return $el;
      }
      function toggleEl($el, disabled) {
        var params = swiper.params.navigation;
        if ($el && $el.length > 0) {
          $el[disabled ? 'addClass' : 'removeClass'](params.disabledClass);
          if ($el[0] && $el[0].tagName === 'BUTTON') $el[0].disabled = disabled;
          if (swiper.params.watchOverflow && swiper.enabled) {
            $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
          }
        }
      }
      function update() {
        // Update Navigation Buttons
        if (swiper.params.loop) return;
        var _swiper$navigation = swiper.navigation,
          $nextEl = _swiper$navigation.$nextEl,
          $prevEl = _swiper$navigation.$prevEl;
        toggleEl($prevEl, swiper.isBeginning && !swiper.params.rewind);
        toggleEl($nextEl, swiper.isEnd && !swiper.params.rewind);
      }
      function onPrevClick(e) {
        e.preventDefault();
        if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
        swiper.slidePrev();
      }
      function onNextClick(e) {
        e.preventDefault();
        if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
        swiper.slideNext();
      }
      function init() {
        var params = swiper.params.navigation;
        swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
          nextEl: 'swiper-button-next',
          prevEl: 'swiper-button-prev'
        });
        if (!(params.nextEl || params.prevEl)) return;
        var $nextEl = getEl(params.nextEl);
        var $prevEl = getEl(params.prevEl);
        if ($nextEl && $nextEl.length > 0) {
          $nextEl.on('click', onNextClick);
        }
        if ($prevEl && $prevEl.length > 0) {
          $prevEl.on('click', onPrevClick);
        }
        Object.assign(swiper.navigation, {
          $nextEl: $nextEl,
          nextEl: $nextEl && $nextEl[0],
          $prevEl: $prevEl,
          prevEl: $prevEl && $prevEl[0]
        });
        if (!swiper.enabled) {
          if ($nextEl) $nextEl.addClass(params.lockClass);
          if ($prevEl) $prevEl.addClass(params.lockClass);
        }
      }
      function destroy() {
        var _swiper$navigation2 = swiper.navigation,
          $nextEl = _swiper$navigation2.$nextEl,
          $prevEl = _swiper$navigation2.$prevEl;
        if ($nextEl && $nextEl.length) {
          $nextEl.off('click', onNextClick);
          $nextEl.removeClass(swiper.params.navigation.disabledClass);
        }
        if ($prevEl && $prevEl.length) {
          $prevEl.off('click', onPrevClick);
          $prevEl.removeClass(swiper.params.navigation.disabledClass);
        }
      }
      on('init', function () {
        init();
        update();
      });
      on('toEdge fromEdge lock unlock', function () {
        update();
      });
      on('destroy', function () {
        destroy();
      });
      on('enable disable', function () {
        var _swiper$navigation3 = swiper.navigation,
          $nextEl = _swiper$navigation3.$nextEl,
          $prevEl = _swiper$navigation3.$prevEl;
        if ($nextEl) {
          $nextEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
        }
        if ($prevEl) {
          $prevEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
        }
      });
      on('click', function (_s, e) {
        var _swiper$navigation4 = swiper.navigation,
          $nextEl = _swiper$navigation4.$nextEl,
          $prevEl = _swiper$navigation4.$prevEl;
        var targetEl = e.target;
        if (swiper.params.navigation.hideOnClick && !$(targetEl).is($prevEl) && !$(targetEl).is($nextEl)) {
          if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
          var isHidden;
          if ($nextEl) {
            isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
          } else if ($prevEl) {
            isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
          }
          if (isHidden === true) {
            emit('navigationShow');
          } else {
            emit('navigationHide');
          }
          if ($nextEl) {
            $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
          }
          if ($prevEl) {
            $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
          }
        }
      });
      Object.assign(swiper.navigation, {
        update: update,
        init: init,
        destroy: destroy
      });
    }
    function classesToSelector() {
      var classes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      return ".".concat(classes.trim().replace(/([\.:!\/])/g, '\\$1') // eslint-disable-line
      .replace(/ /g, '.'));
    }
    function Pagination(_ref11) {
      var swiper = _ref11.swiper,
        extendParams = _ref11.extendParams,
        on = _ref11.on,
        emit = _ref11.emit;
      var pfx = 'swiper-pagination';
      extendParams({
        pagination: {
          el: null,
          bulletElement: 'span',
          clickable: false,
          hideOnClick: false,
          renderBullet: null,
          renderProgressbar: null,
          renderFraction: null,
          renderCustom: null,
          progressbarOpposite: false,
          type: 'bullets',
          // 'bullets' or 'progressbar' or 'fraction' or 'custom'
          dynamicBullets: false,
          dynamicMainBullets: 1,
          formatFractionCurrent: function formatFractionCurrent(number) {
            return number;
          },
          formatFractionTotal: function formatFractionTotal(number) {
            return number;
          },
          bulletClass: "".concat(pfx, "-bullet"),
          bulletActiveClass: "".concat(pfx, "-bullet-active"),
          modifierClass: "".concat(pfx, "-"),
          currentClass: "".concat(pfx, "-current"),
          totalClass: "".concat(pfx, "-total"),
          hiddenClass: "".concat(pfx, "-hidden"),
          progressbarFillClass: "".concat(pfx, "-progressbar-fill"),
          progressbarOppositeClass: "".concat(pfx, "-progressbar-opposite"),
          clickableClass: "".concat(pfx, "-clickable"),
          lockClass: "".concat(pfx, "-lock"),
          horizontalClass: "".concat(pfx, "-horizontal"),
          verticalClass: "".concat(pfx, "-vertical")
        }
      });
      swiper.pagination = {
        el: null,
        $el: null,
        bullets: []
      };
      var bulletSize;
      var dynamicBulletIndex = 0;
      function isPaginationDisabled() {
        return !swiper.params.pagination.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0;
      }
      function setSideBullets($bulletEl, position) {
        var bulletActiveClass = swiper.params.pagination.bulletActiveClass;
        $bulletEl[position]().addClass("".concat(bulletActiveClass, "-").concat(position))[position]().addClass("".concat(bulletActiveClass, "-").concat(position, "-").concat(position));
      }
      function update() {
        // Render || Update Pagination bullets/items
        var rtl = swiper.rtl;
        var params = swiper.params.pagination;
        if (isPaginationDisabled()) return;
        var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
        var $el = swiper.pagination.$el; // Current/Total

        var current;
        var total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
        if (swiper.params.loop) {
          current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
          if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
            current -= slidesLength - swiper.loopedSlides * 2;
          }
          if (current > total - 1) current -= total;
          if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
        } else if (typeof swiper.snapIndex !== 'undefined') {
          current = swiper.snapIndex;
        } else {
          current = swiper.activeIndex || 0;
        } // Types

        if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
          var bullets = swiper.pagination.bullets;
          var firstIndex;
          var lastIndex;
          var midIndex;
          if (params.dynamicBullets) {
            bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
            $el.css(swiper.isHorizontal() ? 'width' : 'height', "".concat(bulletSize * (params.dynamicMainBullets + 4), "px"));
            if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
              dynamicBulletIndex += current - (swiper.previousIndex - swiper.loopedSlides || 0);
              if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
                dynamicBulletIndex = params.dynamicMainBullets - 1;
              } else if (dynamicBulletIndex < 0) {
                dynamicBulletIndex = 0;
              }
            }
            firstIndex = Math.max(current - dynamicBulletIndex, 0);
            lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
            midIndex = (lastIndex + firstIndex) / 2;
          }
          bullets.removeClass(['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(function (suffix) {
            return "".concat(params.bulletActiveClass).concat(suffix);
          }).join(' '));
          if ($el.length > 1) {
            bullets.each(function (bullet) {
              var $bullet = $(bullet);
              var bulletIndex = $bullet.index();
              if (bulletIndex === current) {
                $bullet.addClass(params.bulletActiveClass);
              }
              if (params.dynamicBullets) {
                if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                  $bullet.addClass("".concat(params.bulletActiveClass, "-main"));
                }
                if (bulletIndex === firstIndex) {
                  setSideBullets($bullet, 'prev');
                }
                if (bulletIndex === lastIndex) {
                  setSideBullets($bullet, 'next');
                }
              }
            });
          } else {
            var $bullet = bullets.eq(current);
            var bulletIndex = $bullet.index();
            $bullet.addClass(params.bulletActiveClass);
            if (params.dynamicBullets) {
              var $firstDisplayedBullet = bullets.eq(firstIndex);
              var $lastDisplayedBullet = bullets.eq(lastIndex);
              for (var i = firstIndex; i <= lastIndex; i += 1) {
                bullets.eq(i).addClass("".concat(params.bulletActiveClass, "-main"));
              }
              if (swiper.params.loop) {
                if (bulletIndex >= bullets.length) {
                  for (var _i8 = params.dynamicMainBullets; _i8 >= 0; _i8 -= 1) {
                    bullets.eq(bullets.length - _i8).addClass("".concat(params.bulletActiveClass, "-main"));
                  }
                  bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass("".concat(params.bulletActiveClass, "-prev"));
                } else {
                  setSideBullets($firstDisplayedBullet, 'prev');
                  setSideBullets($lastDisplayedBullet, 'next');
                }
              } else {
                setSideBullets($firstDisplayedBullet, 'prev');
                setSideBullets($lastDisplayedBullet, 'next');
              }
            }
          }
          if (params.dynamicBullets) {
            var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
            var bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
            var offsetProp = rtl ? 'right' : 'left';
            bullets.css(swiper.isHorizontal() ? offsetProp : 'top', "".concat(bulletsOffset, "px"));
          }
        }
        if (params.type === 'fraction') {
          $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
          $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
        }
        if (params.type === 'progressbar') {
          var progressbarDirection;
          if (params.progressbarOpposite) {
            progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
          } else {
            progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
          }
          var scale = (current + 1) / total;
          var scaleX = 1;
          var scaleY = 1;
          if (progressbarDirection === 'horizontal') {
            scaleX = scale;
          } else {
            scaleY = scale;
          }
          $el.find(classesToSelector(params.progressbarFillClass)).transform("translate3d(0,0,0) scaleX(".concat(scaleX, ") scaleY(").concat(scaleY, ")")).transition(swiper.params.speed);
        }
        if (params.type === 'custom' && params.renderCustom) {
          $el.html(params.renderCustom(swiper, current + 1, total));
          emit('paginationRender', $el[0]);
        } else {
          emit('paginationUpdate', $el[0]);
        }
        if (swiper.params.watchOverflow && swiper.enabled) {
          $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
        }
      }
      function render() {
        // Render Container
        var params = swiper.params.pagination;
        if (isPaginationDisabled()) return;
        var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
        var $el = swiper.pagination.$el;
        var paginationHTML = '';
        if (params.type === 'bullets') {
          var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
          if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.loop && numberOfBullets > slidesLength) {
            numberOfBullets = slidesLength;
          }
          for (var i = 0; i < numberOfBullets; i += 1) {
            if (params.renderBullet) {
              paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
            } else {
              paginationHTML += "<".concat(params.bulletElement, " class=\"").concat(params.bulletClass, "\"></").concat(params.bulletElement, ">");
            }
          }
          $el.html(paginationHTML);
          swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
        }
        if (params.type === 'fraction') {
          if (params.renderFraction) {
            paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
          } else {
            paginationHTML = "<span class=\"".concat(params.currentClass, "\"></span>") + ' / ' + "<span class=\"".concat(params.totalClass, "\"></span>");
          }
          $el.html(paginationHTML);
        }
        if (params.type === 'progressbar') {
          if (params.renderProgressbar) {
            paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
          } else {
            paginationHTML = "<span class=\"".concat(params.progressbarFillClass, "\"></span>");
          }
          $el.html(paginationHTML);
        }
        if (params.type !== 'custom') {
          emit('paginationRender', swiper.pagination.$el[0]);
        }
      }
      function init() {
        swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
          el: 'swiper-pagination'
        });
        var params = swiper.params.pagination;
        if (!params.el) return;
        var $el = $(params.el);
        if ($el.length === 0) return;
        if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {
          $el = swiper.$el.find(params.el); // check if it belongs to another nested Swiper

          if ($el.length > 1) {
            $el = $el.filter(function (el) {
              if ($(el).parents('.swiper')[0] !== swiper.el) return false;
              return true;
            });
          }
        }
        if (params.type === 'bullets' && params.clickable) {
          $el.addClass(params.clickableClass);
        }
        $el.addClass(params.modifierClass + params.type);
        $el.addClass(params.modifierClass + swiper.params.direction);
        if (params.type === 'bullets' && params.dynamicBullets) {
          $el.addClass("".concat(params.modifierClass).concat(params.type, "-dynamic"));
          dynamicBulletIndex = 0;
          if (params.dynamicMainBullets < 1) {
            params.dynamicMainBullets = 1;
          }
        }
        if (params.type === 'progressbar' && params.progressbarOpposite) {
          $el.addClass(params.progressbarOppositeClass);
        }
        if (params.clickable) {
          $el.on('click', classesToSelector(params.bulletClass), function onClick(e) {
            e.preventDefault();
            var index = $(this).index() * swiper.params.slidesPerGroup;
            if (swiper.params.loop) index += swiper.loopedSlides;
            swiper.slideTo(index);
          });
        }
        Object.assign(swiper.pagination, {
          $el: $el,
          el: $el[0]
        });
        if (!swiper.enabled) {
          $el.addClass(params.lockClass);
        }
      }
      function destroy() {
        var params = swiper.params.pagination;
        if (isPaginationDisabled()) return;
        var $el = swiper.pagination.$el;
        $el.removeClass(params.hiddenClass);
        $el.removeClass(params.modifierClass + params.type);
        $el.removeClass(params.modifierClass + swiper.params.direction);
        if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass) swiper.pagination.bullets.removeClass(params.bulletActiveClass);
        if (params.clickable) {
          $el.off('click', classesToSelector(params.bulletClass));
        }
      }
      on('init', function () {
        init();
        render();
        update();
      });
      on('activeIndexChange', function () {
        if (swiper.params.loop) {
          update();
        } else if (typeof swiper.snapIndex === 'undefined') {
          update();
        }
      });
      on('snapIndexChange', function () {
        if (!swiper.params.loop) {
          update();
        }
      });
      on('slidesLengthChange', function () {
        if (swiper.params.loop) {
          render();
          update();
        }
      });
      on('snapGridLengthChange', function () {
        if (!swiper.params.loop) {
          render();
          update();
        }
      });
      on('destroy', function () {
        destroy();
      });
      on('enable disable', function () {
        var $el = swiper.pagination.$el;
        if ($el) {
          $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);
        }
      });
      on('lock unlock', function () {
        update();
      });
      on('click', function (_s, e) {
        var targetEl = e.target;
        var $el = swiper.pagination.$el;
        if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && $el.length > 0 && !$(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
          if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
          var isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);
          if (isHidden === true) {
            emit('paginationShow');
          } else {
            emit('paginationHide');
          }
          $el.toggleClass(swiper.params.pagination.hiddenClass);
        }
      });
      Object.assign(swiper.pagination, {
        render: render,
        update: update,
        init: init,
        destroy: destroy
      });
    }
    function Scrollbar(_ref12) {
      var swiper = _ref12.swiper,
        extendParams = _ref12.extendParams,
        on = _ref12.on,
        emit = _ref12.emit;
      var document = getDocument();
      var isTouched = false;
      var timeout = null;
      var dragTimeout = null;
      var dragStartPos;
      var dragSize;
      var trackSize;
      var divider;
      extendParams({
        scrollbar: {
          el: null,
          dragSize: 'auto',
          hide: false,
          draggable: false,
          snapOnRelease: true,
          lockClass: 'swiper-scrollbar-lock',
          dragClass: 'swiper-scrollbar-drag'
        }
      });
      swiper.scrollbar = {
        el: null,
        dragEl: null,
        $el: null,
        $dragEl: null
      };
      function setTranslate() {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        var scrollbar = swiper.scrollbar,
          rtl = swiper.rtlTranslate,
          progress = swiper.progress;
        var $dragEl = scrollbar.$dragEl,
          $el = scrollbar.$el;
        var params = swiper.params.scrollbar;
        var newSize = dragSize;
        var newPos = (trackSize - dragSize) * progress;
        if (rtl) {
          newPos = -newPos;
          if (newPos > 0) {
            newSize = dragSize - newPos;
            newPos = 0;
          } else if (-newPos + dragSize > trackSize) {
            newSize = trackSize + newPos;
          }
        } else if (newPos < 0) {
          newSize = dragSize + newPos;
          newPos = 0;
        } else if (newPos + dragSize > trackSize) {
          newSize = trackSize - newPos;
        }
        if (swiper.isHorizontal()) {
          $dragEl.transform("translate3d(".concat(newPos, "px, 0, 0)"));
          $dragEl[0].style.width = "".concat(newSize, "px");
        } else {
          $dragEl.transform("translate3d(0px, ".concat(newPos, "px, 0)"));
          $dragEl[0].style.height = "".concat(newSize, "px");
        }
        if (params.hide) {
          clearTimeout(timeout);
          $el[0].style.opacity = 1;
          timeout = setTimeout(function () {
            $el[0].style.opacity = 0;
            $el.transition(400);
          }, 1000);
        }
      }
      function setTransition(duration) {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        swiper.scrollbar.$dragEl.transition(duration);
      }
      function updateSize() {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        var scrollbar = swiper.scrollbar;
        var $dragEl = scrollbar.$dragEl,
          $el = scrollbar.$el;
        $dragEl[0].style.width = '';
        $dragEl[0].style.height = '';
        trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
        divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));
        if (swiper.params.scrollbar.dragSize === 'auto') {
          dragSize = trackSize * divider;
        } else {
          dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
        }
        if (swiper.isHorizontal()) {
          $dragEl[0].style.width = "".concat(dragSize, "px");
        } else {
          $dragEl[0].style.height = "".concat(dragSize, "px");
        }
        if (divider >= 1) {
          $el[0].style.display = 'none';
        } else {
          $el[0].style.display = '';
        }
        if (swiper.params.scrollbar.hide) {
          $el[0].style.opacity = 0;
        }
        if (swiper.params.watchOverflow && swiper.enabled) {
          scrollbar.$el[swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
        }
      }
      function getPointerPosition(e) {
        if (swiper.isHorizontal()) {
          return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX;
        }
        return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY;
      }
      function setDragPosition(e) {
        var scrollbar = swiper.scrollbar,
          rtl = swiper.rtlTranslate;
        var $el = scrollbar.$el;
        var positionRatio;
        positionRatio = (getPointerPosition(e) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
        positionRatio = Math.max(Math.min(positionRatio, 1), 0);
        if (rtl) {
          positionRatio = 1 - positionRatio;
        }
        var position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
        swiper.updateProgress(position);
        swiper.setTranslate(position);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }
      function onDragStart(e) {
        var params = swiper.params.scrollbar;
        var scrollbar = swiper.scrollbar,
          $wrapperEl = swiper.$wrapperEl;
        var $el = scrollbar.$el,
          $dragEl = scrollbar.$dragEl;
        isTouched = true;
        dragStartPos = e.target === $dragEl[0] || e.target === $dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
        e.preventDefault();
        e.stopPropagation();
        $wrapperEl.transition(100);
        $dragEl.transition(100);
        setDragPosition(e);
        clearTimeout(dragTimeout);
        $el.transition(0);
        if (params.hide) {
          $el.css('opacity', 1);
        }
        if (swiper.params.cssMode) {
          swiper.$wrapperEl.css('scroll-snap-type', 'none');
        }
        emit('scrollbarDragStart', e);
      }
      function onDragMove(e) {
        var scrollbar = swiper.scrollbar,
          $wrapperEl = swiper.$wrapperEl;
        var $el = scrollbar.$el,
          $dragEl = scrollbar.$dragEl;
        if (!isTouched) return;
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
        setDragPosition(e);
        $wrapperEl.transition(0);
        $el.transition(0);
        $dragEl.transition(0);
        emit('scrollbarDragMove', e);
      }
      function onDragEnd(e) {
        var params = swiper.params.scrollbar;
        var scrollbar = swiper.scrollbar,
          $wrapperEl = swiper.$wrapperEl;
        var $el = scrollbar.$el;
        if (!isTouched) return;
        isTouched = false;
        if (swiper.params.cssMode) {
          swiper.$wrapperEl.css('scroll-snap-type', '');
          $wrapperEl.transition('');
        }
        if (params.hide) {
          clearTimeout(dragTimeout);
          dragTimeout = nextTick(function () {
            $el.css('opacity', 0);
            $el.transition(400);
          }, 1000);
        }
        emit('scrollbarDragEnd', e);
        if (params.snapOnRelease) {
          swiper.slideToClosest();
        }
      }
      function events(method) {
        var scrollbar = swiper.scrollbar,
          touchEventsTouch = swiper.touchEventsTouch,
          touchEventsDesktop = swiper.touchEventsDesktop,
          params = swiper.params,
          support = swiper.support;
        var $el = scrollbar.$el;
        var target = $el[0];
        var activeListener = support.passiveListener && params.passiveListeners ? {
          passive: false,
          capture: false
        } : false;
        var passiveListener = support.passiveListener && params.passiveListeners ? {
          passive: true,
          capture: false
        } : false;
        if (!target) return;
        var eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
        if (!support.touch) {
          target[eventMethod](touchEventsDesktop.start, onDragStart, activeListener);
          document[eventMethod](touchEventsDesktop.move, onDragMove, activeListener);
          document[eventMethod](touchEventsDesktop.end, onDragEnd, passiveListener);
        } else {
          target[eventMethod](touchEventsTouch.start, onDragStart, activeListener);
          target[eventMethod](touchEventsTouch.move, onDragMove, activeListener);
          target[eventMethod](touchEventsTouch.end, onDragEnd, passiveListener);
        }
      }
      function enableDraggable() {
        if (!swiper.params.scrollbar.el) return;
        events('on');
      }
      function disableDraggable() {
        if (!swiper.params.scrollbar.el) return;
        events('off');
      }
      function init() {
        var scrollbar = swiper.scrollbar,
          $swiperEl = swiper.$el;
        swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
          el: 'swiper-scrollbar'
        });
        var params = swiper.params.scrollbar;
        if (!params.el) return;
        var $el = $(params.el);
        if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
          $el = $swiperEl.find(params.el);
        }
        var $dragEl = $el.find(".".concat(swiper.params.scrollbar.dragClass));
        if ($dragEl.length === 0) {
          $dragEl = $("<div class=\"".concat(swiper.params.scrollbar.dragClass, "\"></div>"));
          $el.append($dragEl);
        }
        Object.assign(scrollbar, {
          $el: $el,
          el: $el[0],
          $dragEl: $dragEl,
          dragEl: $dragEl[0]
        });
        if (params.draggable) {
          enableDraggable();
        }
        if ($el) {
          $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
        }
      }
      function destroy() {
        disableDraggable();
      }
      on('init', function () {
        init();
        updateSize();
        setTranslate();
      });
      on('update resize observerUpdate lock unlock', function () {
        updateSize();
      });
      on('setTranslate', function () {
        setTranslate();
      });
      on('setTransition', function (_s, duration) {
        setTransition(duration);
      });
      on('enable disable', function () {
        var $el = swiper.scrollbar.$el;
        if ($el) {
          $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
        }
      });
      on('destroy', function () {
        destroy();
      });
      Object.assign(swiper.scrollbar, {
        updateSize: updateSize,
        setTranslate: setTranslate,
        init: init,
        destroy: destroy
      });
    }
    function Parallax(_ref13) {
      var swiper = _ref13.swiper,
        extendParams = _ref13.extendParams,
        on = _ref13.on;
      extendParams({
        parallax: {
          enabled: false
        }
      });
      var setTransform = function setTransform(el, progress) {
        var rtl = swiper.rtl;
        var $el = $(el);
        var rtlFactor = rtl ? -1 : 1;
        var p = $el.attr('data-swiper-parallax') || '0';
        var x = $el.attr('data-swiper-parallax-x');
        var y = $el.attr('data-swiper-parallax-y');
        var scale = $el.attr('data-swiper-parallax-scale');
        var opacity = $el.attr('data-swiper-parallax-opacity');
        if (x || y) {
          x = x || '0';
          y = y || '0';
        } else if (swiper.isHorizontal()) {
          x = p;
          y = '0';
        } else {
          y = p;
          x = '0';
        }
        if (x.indexOf('%') >= 0) {
          x = "".concat(parseInt(x, 10) * progress * rtlFactor, "%");
        } else {
          x = "".concat(x * progress * rtlFactor, "px");
        }
        if (y.indexOf('%') >= 0) {
          y = "".concat(parseInt(y, 10) * progress, "%");
        } else {
          y = "".concat(y * progress, "px");
        }
        if (typeof opacity !== 'undefined' && opacity !== null) {
          var currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
          $el[0].style.opacity = currentOpacity;
        }
        if (typeof scale === 'undefined' || scale === null) {
          $el.transform("translate3d(".concat(x, ", ").concat(y, ", 0px)"));
        } else {
          var currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
          $el.transform("translate3d(".concat(x, ", ").concat(y, ", 0px) scale(").concat(currentScale, ")"));
        }
      };
      var setTranslate = function setTranslate() {
        var $el = swiper.$el,
          slides = swiper.slides,
          progress = swiper.progress,
          snapGrid = swiper.snapGrid;
        $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(function (el) {
          setTransform(el, progress);
        });
        slides.each(function (slideEl, slideIndex) {
          var slideProgress = slideEl.progress;
          if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
            slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
          }
          slideProgress = Math.min(Math.max(slideProgress, -1), 1);
          $(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(function (el) {
            setTransform(el, slideProgress);
          });
        });
      };
      var setTransition = function setTransition() {
        var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : swiper.params.speed;
        var $el = swiper.$el;
        $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(function (parallaxEl) {
          var $parallaxEl = $(parallaxEl);
          var parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
          if (duration === 0) parallaxDuration = 0;
          $parallaxEl.transition(parallaxDuration);
        });
      };
      on('beforeInit', function () {
        if (!swiper.params.parallax.enabled) return;
        swiper.params.watchSlidesProgress = true;
        swiper.originalParams.watchSlidesProgress = true;
      });
      on('init', function () {
        if (!swiper.params.parallax.enabled) return;
        setTranslate();
      });
      on('setTranslate', function () {
        if (!swiper.params.parallax.enabled) return;
        setTranslate();
      });
      on('setTransition', function (_swiper, duration) {
        if (!swiper.params.parallax.enabled) return;
        setTransition(duration);
      });
    }
    function Zoom(_ref14) {
      var swiper = _ref14.swiper,
        extendParams = _ref14.extendParams,
        on = _ref14.on,
        emit = _ref14.emit;
      var window = getWindow();
      extendParams({
        zoom: {
          enabled: false,
          maxRatio: 3,
          minRatio: 1,
          toggle: true,
          containerClass: 'swiper-zoom-container',
          zoomedSlideClass: 'swiper-slide-zoomed'
        }
      });
      swiper.zoom = {
        enabled: false
      };
      var currentScale = 1;
      var isScaling = false;
      var gesturesEnabled;
      var fakeGestureTouched;
      var fakeGestureMoved;
      var gesture = {
        $slideEl: undefined,
        slideWidth: undefined,
        slideHeight: undefined,
        $imageEl: undefined,
        $imageWrapEl: undefined,
        maxRatio: 3
      };
      var image = {
        isTouched: undefined,
        isMoved: undefined,
        currentX: undefined,
        currentY: undefined,
        minX: undefined,
        minY: undefined,
        maxX: undefined,
        maxY: undefined,
        width: undefined,
        height: undefined,
        startX: undefined,
        startY: undefined,
        touchesStart: {},
        touchesCurrent: {}
      };
      var velocity = {
        x: undefined,
        y: undefined,
        prevPositionX: undefined,
        prevPositionY: undefined,
        prevTime: undefined
      };
      var scale = 1;
      Object.defineProperty(swiper.zoom, 'scale', {
        get: function get() {
          return scale;
        },
        set: function set(value) {
          if (scale !== value) {
            var imageEl = gesture.$imageEl ? gesture.$imageEl[0] : undefined;
            var slideEl = gesture.$slideEl ? gesture.$slideEl[0] : undefined;
            emit('zoomChange', value, imageEl, slideEl);
          }
          scale = value;
        }
      });
      function getDistanceBetweenTouches(e) {
        if (e.targetTouches.length < 2) return 1;
        var x1 = e.targetTouches[0].pageX;
        var y1 = e.targetTouches[0].pageY;
        var x2 = e.targetTouches[1].pageX;
        var y2 = e.targetTouches[1].pageY;
        var distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        return distance;
      } // Events

      function onGestureStart(e) {
        var support = swiper.support;
        var params = swiper.params.zoom;
        fakeGestureTouched = false;
        fakeGestureMoved = false;
        if (!support.gestures) {
          if (e.type !== 'touchstart' || e.type === 'touchstart' && e.targetTouches.length < 2) {
            return;
          }
          fakeGestureTouched = true;
          gesture.scaleStart = getDistanceBetweenTouches(e);
        }
        if (!gesture.$slideEl || !gesture.$slideEl.length) {
          gesture.$slideEl = $(e.target).closest(".".concat(swiper.params.slideClass));
          if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
          gesture.$imageEl = gesture.$slideEl.find(".".concat(params.containerClass)).eq(0).find('picture, img, svg, canvas, .swiper-zoom-target').eq(0);
          gesture.$imageWrapEl = gesture.$imageEl.parent(".".concat(params.containerClass));
          gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
          if (gesture.$imageWrapEl.length === 0) {
            gesture.$imageEl = undefined;
            return;
          }
        }
        if (gesture.$imageEl) {
          gesture.$imageEl.transition(0);
        }
        isScaling = true;
      }
      function onGestureChange(e) {
        var support = swiper.support;
        var params = swiper.params.zoom;
        var zoom = swiper.zoom;
        if (!support.gestures) {
          if (e.type !== 'touchmove' || e.type === 'touchmove' && e.targetTouches.length < 2) {
            return;
          }
          fakeGestureMoved = true;
          gesture.scaleMove = getDistanceBetweenTouches(e);
        }
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
          if (e.type === 'gesturechange') onGestureStart(e);
          return;
        }
        if (support.gestures) {
          zoom.scale = e.scale * currentScale;
        } else {
          zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;
        }
        if (zoom.scale > gesture.maxRatio) {
          zoom.scale = gesture.maxRatio - 1 + Math.pow(zoom.scale - gesture.maxRatio + 1, 0.5);
        }
        if (zoom.scale < params.minRatio) {
          zoom.scale = params.minRatio + 1 - Math.pow(params.minRatio - zoom.scale + 1, 0.5);
        }
        gesture.$imageEl.transform("translate3d(0,0,0) scale(".concat(zoom.scale, ")"));
      }
      function onGestureEnd(e) {
        var device = swiper.device;
        var support = swiper.support;
        var params = swiper.params.zoom;
        var zoom = swiper.zoom;
        if (!support.gestures) {
          if (!fakeGestureTouched || !fakeGestureMoved) {
            return;
          }
          if (e.type !== 'touchend' || e.type === 'touchend' && e.changedTouches.length < 2 && !device.android) {
            return;
          }
          fakeGestureTouched = false;
          fakeGestureMoved = false;
        }
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
        zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
        gesture.$imageEl.transition(swiper.params.speed).transform("translate3d(0,0,0) scale(".concat(zoom.scale, ")"));
        currentScale = zoom.scale;
        isScaling = false;
        if (zoom.scale === 1) gesture.$slideEl = undefined;
      }
      function onTouchStart(e) {
        var device = swiper.device;
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
        if (image.isTouched) return;
        if (device.android && e.cancelable) e.preventDefault();
        image.isTouched = true;
        image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      }
      function onTouchMove(e) {
        var zoom = swiper.zoom;
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
        swiper.allowClick = false;
        if (!image.isTouched || !gesture.$slideEl) return;
        if (!image.isMoved) {
          image.width = gesture.$imageEl[0].offsetWidth;
          image.height = gesture.$imageEl[0].offsetHeight;
          image.startX = getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
          image.startY = getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
          gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
          gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
          gesture.$imageWrapEl.transition(0);
        } // Define if we need image drag

        var scaledWidth = image.width * zoom.scale;
        var scaledHeight = image.height * zoom.scale;
        if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;
        image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
        image.maxX = -image.minX;
        image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
        image.maxY = -image.minY;
        image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
        image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
        if (!image.isMoved && !isScaling) {
          if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
            image.isTouched = false;
            return;
          }
          if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
            image.isTouched = false;
            return;
          }
        }
        if (e.cancelable) {
          e.preventDefault();
        }
        e.stopPropagation();
        image.isMoved = true;
        image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;
        image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;
        if (image.currentX < image.minX) {
          image.currentX = image.minX + 1 - Math.pow(image.minX - image.currentX + 1, 0.8);
        }
        if (image.currentX > image.maxX) {
          image.currentX = image.maxX - 1 + Math.pow(image.currentX - image.maxX + 1, 0.8);
        }
        if (image.currentY < image.minY) {
          image.currentY = image.minY + 1 - Math.pow(image.minY - image.currentY + 1, 0.8);
        }
        if (image.currentY > image.maxY) {
          image.currentY = image.maxY - 1 + Math.pow(image.currentY - image.maxY + 1, 0.8);
        } // Velocity

        if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
        if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
        if (!velocity.prevTime) velocity.prevTime = Date.now();
        velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
        velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
        if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
        if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
        velocity.prevPositionX = image.touchesCurrent.x;
        velocity.prevPositionY = image.touchesCurrent.y;
        velocity.prevTime = Date.now();
        gesture.$imageWrapEl.transform("translate3d(".concat(image.currentX, "px, ").concat(image.currentY, "px,0)"));
      }
      function onTouchEnd() {
        var zoom = swiper.zoom;
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
        if (!image.isTouched || !image.isMoved) {
          image.isTouched = false;
          image.isMoved = false;
          return;
        }
        image.isTouched = false;
        image.isMoved = false;
        var momentumDurationX = 300;
        var momentumDurationY = 300;
        var momentumDistanceX = velocity.x * momentumDurationX;
        var newPositionX = image.currentX + momentumDistanceX;
        var momentumDistanceY = velocity.y * momentumDurationY;
        var newPositionY = image.currentY + momentumDistanceY; // Fix duration

        if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
        if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
        var momentumDuration = Math.max(momentumDurationX, momentumDurationY);
        image.currentX = newPositionX;
        image.currentY = newPositionY; // Define if we need image drag

        var scaledWidth = image.width * zoom.scale;
        var scaledHeight = image.height * zoom.scale;
        image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
        image.maxX = -image.minX;
        image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
        image.maxY = -image.minY;
        image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
        image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
        gesture.$imageWrapEl.transition(momentumDuration).transform("translate3d(".concat(image.currentX, "px, ").concat(image.currentY, "px,0)"));
      }
      function onTransitionEnd() {
        var zoom = swiper.zoom;
        if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
          if (gesture.$imageEl) {
            gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
          }
          if (gesture.$imageWrapEl) {
            gesture.$imageWrapEl.transform('translate3d(0,0,0)');
          }
          zoom.scale = 1;
          currentScale = 1;
          gesture.$slideEl = undefined;
          gesture.$imageEl = undefined;
          gesture.$imageWrapEl = undefined;
        }
      }
      function zoomIn(e) {
        var zoom = swiper.zoom;
        var params = swiper.params.zoom;
        if (!gesture.$slideEl) {
          if (e && e.target) {
            gesture.$slideEl = $(e.target).closest(".".concat(swiper.params.slideClass));
          }
          if (!gesture.$slideEl) {
            if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
              gesture.$slideEl = swiper.$wrapperEl.children(".".concat(swiper.params.slideActiveClass));
            } else {
              gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
            }
          }
          gesture.$imageEl = gesture.$slideEl.find(".".concat(params.containerClass)).eq(0).find('picture, img, svg, canvas, .swiper-zoom-target').eq(0);
          gesture.$imageWrapEl = gesture.$imageEl.parent(".".concat(params.containerClass));
        }
        if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) return;
        if (swiper.params.cssMode) {
          swiper.wrapperEl.style.overflow = 'hidden';
          swiper.wrapperEl.style.touchAction = 'none';
        }
        gesture.$slideEl.addClass("".concat(params.zoomedSlideClass));
        var touchX;
        var touchY;
        var offsetX;
        var offsetY;
        var diffX;
        var diffY;
        var translateX;
        var translateY;
        var imageWidth;
        var imageHeight;
        var scaledWidth;
        var scaledHeight;
        var translateMinX;
        var translateMinY;
        var translateMaxX;
        var translateMaxY;
        var slideWidth;
        var slideHeight;
        if (typeof image.touchesStart.x === 'undefined' && e) {
          touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
          touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
        } else {
          touchX = image.touchesStart.x;
          touchY = image.touchesStart.y;
        }
        zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
        currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
        if (e) {
          slideWidth = gesture.$slideEl[0].offsetWidth;
          slideHeight = gesture.$slideEl[0].offsetHeight;
          offsetX = gesture.$slideEl.offset().left + window.scrollX;
          offsetY = gesture.$slideEl.offset().top + window.scrollY;
          diffX = offsetX + slideWidth / 2 - touchX;
          diffY = offsetY + slideHeight / 2 - touchY;
          imageWidth = gesture.$imageEl[0].offsetWidth;
          imageHeight = gesture.$imageEl[0].offsetHeight;
          scaledWidth = imageWidth * zoom.scale;
          scaledHeight = imageHeight * zoom.scale;
          translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
          translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
          translateMaxX = -translateMinX;
          translateMaxY = -translateMinY;
          translateX = diffX * zoom.scale;
          translateY = diffY * zoom.scale;
          if (translateX < translateMinX) {
            translateX = translateMinX;
          }
          if (translateX > translateMaxX) {
            translateX = translateMaxX;
          }
          if (translateY < translateMinY) {
            translateY = translateMinY;
          }
          if (translateY > translateMaxY) {
            translateY = translateMaxY;
          }
        } else {
          translateX = 0;
          translateY = 0;
        }
        gesture.$imageWrapEl.transition(300).transform("translate3d(".concat(translateX, "px, ").concat(translateY, "px,0)"));
        gesture.$imageEl.transition(300).transform("translate3d(0,0,0) scale(".concat(zoom.scale, ")"));
      }
      function zoomOut() {
        var zoom = swiper.zoom;
        var params = swiper.params.zoom;
        if (!gesture.$slideEl) {
          if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
            gesture.$slideEl = swiper.$wrapperEl.children(".".concat(swiper.params.slideActiveClass));
          } else {
            gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
          }
          gesture.$imageEl = gesture.$slideEl.find(".".concat(params.containerClass)).eq(0).find('picture, img, svg, canvas, .swiper-zoom-target').eq(0);
          gesture.$imageWrapEl = gesture.$imageEl.parent(".".concat(params.containerClass));
        }
        if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) return;
        if (swiper.params.cssMode) {
          swiper.wrapperEl.style.overflow = '';
          swiper.wrapperEl.style.touchAction = '';
        }
        zoom.scale = 1;
        currentScale = 1;
        gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
        gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
        gesture.$slideEl.removeClass("".concat(params.zoomedSlideClass));
        gesture.$slideEl = undefined;
      } // Toggle Zoom

      function zoomToggle(e) {
        var zoom = swiper.zoom;
        if (zoom.scale && zoom.scale !== 1) {
          // Zoom Out
          zoomOut();
        } else {
          // Zoom In
          zoomIn(e);
        }
      }
      function getListeners() {
        var support = swiper.support;
        var passiveListener = swiper.touchEvents.start === 'touchstart' && support.passiveListener && swiper.params.passiveListeners ? {
          passive: true,
          capture: false
        } : false;
        var activeListenerWithCapture = support.passiveListener ? {
          passive: false,
          capture: true
        } : true;
        return {
          passiveListener: passiveListener,
          activeListenerWithCapture: activeListenerWithCapture
        };
      }
      function getSlideSelector() {
        return ".".concat(swiper.params.slideClass);
      }
      function toggleGestures(method) {
        var _getListeners = getListeners(),
          passiveListener = _getListeners.passiveListener;
        var slideSelector = getSlideSelector();
        swiper.$wrapperEl[method]('gesturestart', slideSelector, onGestureStart, passiveListener);
        swiper.$wrapperEl[method]('gesturechange', slideSelector, onGestureChange, passiveListener);
        swiper.$wrapperEl[method]('gestureend', slideSelector, onGestureEnd, passiveListener);
      }
      function enableGestures() {
        if (gesturesEnabled) return;
        gesturesEnabled = true;
        toggleGestures('on');
      }
      function disableGestures() {
        if (!gesturesEnabled) return;
        gesturesEnabled = false;
        toggleGestures('off');
      } // Attach/Detach Events

      function enable() {
        var zoom = swiper.zoom;
        if (zoom.enabled) return;
        zoom.enabled = true;
        var support = swiper.support;
        var _getListeners2 = getListeners(),
          passiveListener = _getListeners2.passiveListener,
          activeListenerWithCapture = _getListeners2.activeListenerWithCapture;
        var slideSelector = getSlideSelector(); // Scale image

        if (support.gestures) {
          swiper.$wrapperEl.on(swiper.touchEvents.start, enableGestures, passiveListener);
          swiper.$wrapperEl.on(swiper.touchEvents.end, disableGestures, passiveListener);
        } else if (swiper.touchEvents.start === 'touchstart') {
          swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);
          swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);
          swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);
          if (swiper.touchEvents.cancel) {
            swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);
          }
        } // Move image

        swiper.$wrapperEl.on(swiper.touchEvents.move, ".".concat(swiper.params.zoom.containerClass), onTouchMove, activeListenerWithCapture);
      }
      function disable() {
        var zoom = swiper.zoom;
        if (!zoom.enabled) return;
        var support = swiper.support;
        zoom.enabled = false;
        var _getListeners3 = getListeners(),
          passiveListener = _getListeners3.passiveListener,
          activeListenerWithCapture = _getListeners3.activeListenerWithCapture;
        var slideSelector = getSlideSelector(); // Scale image

        if (support.gestures) {
          swiper.$wrapperEl.off(swiper.touchEvents.start, enableGestures, passiveListener);
          swiper.$wrapperEl.off(swiper.touchEvents.end, disableGestures, passiveListener);
        } else if (swiper.touchEvents.start === 'touchstart') {
          swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);
          swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);
          swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);
          if (swiper.touchEvents.cancel) {
            swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);
          }
        } // Move image

        swiper.$wrapperEl.off(swiper.touchEvents.move, ".".concat(swiper.params.zoom.containerClass), onTouchMove, activeListenerWithCapture);
      }
      on('init', function () {
        if (swiper.params.zoom.enabled) {
          enable();
        }
      });
      on('destroy', function () {
        disable();
      });
      on('touchStart', function (_s, e) {
        if (!swiper.zoom.enabled) return;
        onTouchStart(e);
      });
      on('touchEnd', function (_s, e) {
        if (!swiper.zoom.enabled) return;
        onTouchEnd();
      });
      on('doubleTap', function (_s, e) {
        if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
          zoomToggle(e);
        }
      });
      on('transitionEnd', function () {
        if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
          onTransitionEnd();
        }
      });
      on('slideChange', function () {
        if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
          onTransitionEnd();
        }
      });
      Object.assign(swiper.zoom, {
        enable: enable,
        disable: disable,
        in: zoomIn,
        out: zoomOut,
        toggle: zoomToggle
      });
    }
    function Lazy(_ref15) {
      var swiper = _ref15.swiper,
        extendParams = _ref15.extendParams,
        on = _ref15.on,
        emit = _ref15.emit;
      extendParams({
        lazy: {
          checkInView: false,
          enabled: false,
          loadPrevNext: false,
          loadPrevNextAmount: 1,
          loadOnTransitionStart: false,
          scrollingElement: '',
          elementClass: 'swiper-lazy',
          loadingClass: 'swiper-lazy-loading',
          loadedClass: 'swiper-lazy-loaded',
          preloaderClass: 'swiper-lazy-preloader'
        }
      });
      swiper.lazy = {};
      var scrollHandlerAttached = false;
      var initialImageLoaded = false;
      function loadInSlide(index) {
        var loadInDuplicate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var params = swiper.params.lazy;
        if (typeof index === 'undefined') return;
        if (swiper.slides.length === 0) return;
        var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
        var $slideEl = isVirtual ? swiper.$wrapperEl.children(".".concat(swiper.params.slideClass, "[data-swiper-slide-index=\"").concat(index, "\"]")) : swiper.slides.eq(index);
        var $images = $slideEl.find(".".concat(params.elementClass, ":not(.").concat(params.loadedClass, "):not(.").concat(params.loadingClass, ")"));
        if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
          $images.push($slideEl[0]);
        }
        if ($images.length === 0) return;
        $images.each(function (imageEl) {
          var $imageEl = $(imageEl);
          $imageEl.addClass(params.loadingClass);
          var background = $imageEl.attr('data-background');
          var src = $imageEl.attr('data-src');
          var srcset = $imageEl.attr('data-srcset');
          var sizes = $imageEl.attr('data-sizes');
          var $pictureEl = $imageEl.parent('picture');
          swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, function () {
            if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper && !swiper.params || swiper.destroyed) return;
            if (background) {
              $imageEl.css('background-image', "url(\"".concat(background, "\")"));
              $imageEl.removeAttr('data-background');
            } else {
              if (srcset) {
                $imageEl.attr('srcset', srcset);
                $imageEl.removeAttr('data-srcset');
              }
              if (sizes) {
                $imageEl.attr('sizes', sizes);
                $imageEl.removeAttr('data-sizes');
              }
              if ($pictureEl.length) {
                $pictureEl.children('source').each(function (sourceEl) {
                  var $source = $(sourceEl);
                  if ($source.attr('data-srcset')) {
                    $source.attr('srcset', $source.attr('data-srcset'));
                    $source.removeAttr('data-srcset');
                  }
                });
              }
              if (src) {
                $imageEl.attr('src', src);
                $imageEl.removeAttr('data-src');
              }
            }
            $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
            $slideEl.find(".".concat(params.preloaderClass)).remove();
            if (swiper.params.loop && loadInDuplicate) {
              var slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');
              if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
                var originalSlide = swiper.$wrapperEl.children("[data-swiper-slide-index=\"".concat(slideOriginalIndex, "\"]:not(.").concat(swiper.params.slideDuplicateClass, ")"));
                loadInSlide(originalSlide.index(), false);
              } else {
                var duplicatedSlide = swiper.$wrapperEl.children(".".concat(swiper.params.slideDuplicateClass, "[data-swiper-slide-index=\"").concat(slideOriginalIndex, "\"]"));
                loadInSlide(duplicatedSlide.index(), false);
              }
            }
            emit('lazyImageReady', $slideEl[0], $imageEl[0]);
            if (swiper.params.autoHeight) {
              swiper.updateAutoHeight();
            }
          });
          emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
        });
      }
      function load() {
        var $wrapperEl = swiper.$wrapperEl,
          swiperParams = swiper.params,
          slides = swiper.slides,
          activeIndex = swiper.activeIndex;
        var isVirtual = swiper.virtual && swiperParams.virtual.enabled;
        var params = swiperParams.lazy;
        var slidesPerView = swiperParams.slidesPerView;
        if (slidesPerView === 'auto') {
          slidesPerView = 0;
        }
        function slideExist(index) {
          if (isVirtual) {
            if ($wrapperEl.children(".".concat(swiperParams.slideClass, "[data-swiper-slide-index=\"").concat(index, "\"]")).length) {
              return true;
            }
          } else if (slides[index]) return true;
          return false;
        }
        function slideIndex(slideEl) {
          if (isVirtual) {
            return $(slideEl).attr('data-swiper-slide-index');
          }
          return $(slideEl).index();
        }
        if (!initialImageLoaded) initialImageLoaded = true;
        if (swiper.params.watchSlidesProgress) {
          $wrapperEl.children(".".concat(swiperParams.slideVisibleClass)).each(function (slideEl) {
            var index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();
            loadInSlide(index);
          });
        } else if (slidesPerView > 1) {
          for (var i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
            if (slideExist(i)) loadInSlide(i);
          }
        } else {
          loadInSlide(activeIndex);
        }
        if (params.loadPrevNext) {
          if (slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1) {
            var amount = params.loadPrevNextAmount;
            var spv = slidesPerView;
            var maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
            var minIndex = Math.max(activeIndex - Math.max(spv, amount), 0); // Next Slides

            for (var _i9 = activeIndex + slidesPerView; _i9 < maxIndex; _i9 += 1) {
              if (slideExist(_i9)) loadInSlide(_i9);
            } // Prev Slides

            for (var _i10 = minIndex; _i10 < activeIndex; _i10 += 1) {
              if (slideExist(_i10)) loadInSlide(_i10);
            }
          } else {
            var nextSlide = $wrapperEl.children(".".concat(swiperParams.slideNextClass));
            if (nextSlide.length > 0) loadInSlide(slideIndex(nextSlide));
            var prevSlide = $wrapperEl.children(".".concat(swiperParams.slidePrevClass));
            if (prevSlide.length > 0) loadInSlide(slideIndex(prevSlide));
          }
        }
      }
      function checkInViewOnLoad() {
        var window = getWindow();
        if (!swiper || swiper.destroyed) return;
        var $scrollElement = swiper.params.lazy.scrollingElement ? $(swiper.params.lazy.scrollingElement) : $(window);
        var isWindow = $scrollElement[0] === window;
        var scrollElementWidth = isWindow ? window.innerWidth : $scrollElement[0].offsetWidth;
        var scrollElementHeight = isWindow ? window.innerHeight : $scrollElement[0].offsetHeight;
        var swiperOffset = swiper.$el.offset();
        var rtl = swiper.rtlTranslate;
        var inView = false;
        if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
        var swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiper.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiper.height], [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height]];
        for (var i = 0; i < swiperCoord.length; i += 1) {
          var point = swiperCoord[i];
          if (point[0] >= 0 && point[0] <= scrollElementWidth && point[1] >= 0 && point[1] <= scrollElementHeight) {
            if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line

            inView = true;
          }
        }
        var passiveListener = swiper.touchEvents.start === 'touchstart' && swiper.support.passiveListener && swiper.params.passiveListeners ? {
          passive: true,
          capture: false
        } : false;
        if (inView) {
          load();
          $scrollElement.off('scroll', checkInViewOnLoad, passiveListener);
        } else if (!scrollHandlerAttached) {
          scrollHandlerAttached = true;
          $scrollElement.on('scroll', checkInViewOnLoad, passiveListener);
        }
      }
      on('beforeInit', function () {
        if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
          swiper.params.preloadImages = false;
        }
      });
      on('init', function () {
        if (swiper.params.lazy.enabled) {
          if (swiper.params.lazy.checkInView) {
            checkInViewOnLoad();
          } else {
            load();
          }
        }
      });
      on('scroll', function () {
        if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.freeMode.sticky) {
          load();
        }
      });
      on('scrollbarDragMove resize _freeModeNoMomentumRelease', function () {
        if (swiper.params.lazy.enabled) {
          if (swiper.params.lazy.checkInView) {
            checkInViewOnLoad();
          } else {
            load();
          }
        }
      });
      on('transitionStart', function () {
        if (swiper.params.lazy.enabled) {
          if (swiper.params.lazy.loadOnTransitionStart || !swiper.params.lazy.loadOnTransitionStart && !initialImageLoaded) {
            if (swiper.params.lazy.checkInView) {
              checkInViewOnLoad();
            } else {
              load();
            }
          }
        }
      });
      on('transitionEnd', function () {
        if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
          if (swiper.params.lazy.checkInView) {
            checkInViewOnLoad();
          } else {
            load();
          }
        }
      });
      on('slideChange', function () {
        var _swiper$params2 = swiper.params,
          lazy = _swiper$params2.lazy,
          cssMode = _swiper$params2.cssMode,
          watchSlidesProgress = _swiper$params2.watchSlidesProgress,
          touchReleaseOnEdges = _swiper$params2.touchReleaseOnEdges,
          resistanceRatio = _swiper$params2.resistanceRatio;
        if (lazy.enabled && (cssMode || watchSlidesProgress && (touchReleaseOnEdges || resistanceRatio === 0))) {
          load();
        }
      });
      Object.assign(swiper.lazy, {
        load: load,
        loadInSlide: loadInSlide
      });
    }

    /* eslint no-bitwise: ["error", { "allow": [">>"] }] */
    function Controller(_ref16) {
      var swiper = _ref16.swiper,
        extendParams = _ref16.extendParams,
        on = _ref16.on;
      extendParams({
        controller: {
          control: undefined,
          inverse: false,
          by: 'slide' // or 'container'
        }
      });

      swiper.controller = {
        control: undefined
      };
      function LinearSpline(x, y) {
        var binarySearch = function search() {
          var maxIndex;
          var minIndex;
          var guess;
          return function (array, val) {
            minIndex = -1;
            maxIndex = array.length;
            while (maxIndex - minIndex > 1) {
              guess = maxIndex + minIndex >> 1;
              if (array[guess] <= val) {
                minIndex = guess;
              } else {
                maxIndex = guess;
              }
            }
            return maxIndex;
          };
        }();
        this.x = x;
        this.y = y;
        this.lastIndex = x.length - 1; // Given an x value (x2), return the expected y2 value:
        // (x1,y1) is the known point before given value,
        // (x3,y3) is the known point after given value.

        var i1;
        var i3;
        this.interpolate = function interpolate(x2) {
          if (!x2) return 0; // Get the indexes of x1 and x3 (the array indexes before and after given x2):

          i3 = binarySearch(this.x, x2);
          i1 = i3 - 1; // We have our indexes i1 & i3, so we can calculate already:
          // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1

          return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
        };
        return this;
      } // xxx: for now i will just save one spline function to to

      function getInterpolateFunction(c) {
        if (!swiper.controller.spline) {
          swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);
        }
      }
      function setTranslate(_t, byController) {
        var controlled = swiper.controller.control;
        var multiplier;
        var controlledTranslate;
        var Swiper = swiper.constructor;
        function setControlledTranslate(c) {
          // this will create an Interpolate function based on the snapGrids
          // x is the Grid of the scrolled scroller and y will be the controlled scroller
          // it makes sense to create this only once and recall it for the interpolation
          // the function does a lot of value caching for performance
          var translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
          if (swiper.params.controller.by === 'slide') {
            getInterpolateFunction(c); // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
            // but it did not work out

            controlledTranslate = -swiper.controller.spline.interpolate(-translate);
          }
          if (!controlledTranslate || swiper.params.controller.by === 'container') {
            multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
            controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
          }
          if (swiper.params.controller.inverse) {
            controlledTranslate = c.maxTranslate() - controlledTranslate;
          }
          c.updateProgress(controlledTranslate);
          c.setTranslate(controlledTranslate, swiper);
          c.updateActiveIndex();
          c.updateSlidesClasses();
        }
        if (Array.isArray(controlled)) {
          for (var i = 0; i < controlled.length; i += 1) {
            if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
              setControlledTranslate(controlled[i]);
            }
          }
        } else if (controlled instanceof Swiper && byController !== controlled) {
          setControlledTranslate(controlled);
        }
      }
      function setTransition(duration, byController) {
        var Swiper = swiper.constructor;
        var controlled = swiper.controller.control;
        var i;
        function setControlledTransition(c) {
          c.setTransition(duration, swiper);
          if (duration !== 0) {
            c.transitionStart();
            if (c.params.autoHeight) {
              nextTick(function () {
                c.updateAutoHeight();
              });
            }
            c.$wrapperEl.transitionEnd(function () {
              if (!controlled) return;
              if (c.params.loop && swiper.params.controller.by === 'slide') {
                c.loopFix();
              }
              c.transitionEnd();
            });
          }
        }
        if (Array.isArray(controlled)) {
          for (i = 0; i < controlled.length; i += 1) {
            if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
              setControlledTransition(controlled[i]);
            }
          }
        } else if (controlled instanceof Swiper && byController !== controlled) {
          setControlledTransition(controlled);
        }
      }
      function removeSpline() {
        if (!swiper.controller.control) return;
        if (swiper.controller.spline) {
          swiper.controller.spline = undefined;
          delete swiper.controller.spline;
        }
      }
      on('beforeInit', function () {
        swiper.controller.control = swiper.params.controller.control;
      });
      on('update', function () {
        removeSpline();
      });
      on('resize', function () {
        removeSpline();
      });
      on('observerUpdate', function () {
        removeSpline();
      });
      on('setTranslate', function (_s, translate, byController) {
        if (!swiper.controller.control) return;
        swiper.controller.setTranslate(translate, byController);
      });
      on('setTransition', function (_s, duration, byController) {
        if (!swiper.controller.control) return;
        swiper.controller.setTransition(duration, byController);
      });
      Object.assign(swiper.controller, {
        setTranslate: setTranslate,
        setTransition: setTransition
      });
    }
    function A11y(_ref17) {
      var swiper = _ref17.swiper,
        extendParams = _ref17.extendParams,
        on = _ref17.on;
      extendParams({
        a11y: {
          enabled: true,
          notificationClass: 'swiper-notification',
          prevSlideMessage: 'Previous slide',
          nextSlideMessage: 'Next slide',
          firstSlideMessage: 'This is the first slide',
          lastSlideMessage: 'This is the last slide',
          paginationBulletMessage: 'Go to slide {{index}}',
          slideLabelMessage: '{{index}} / {{slidesLength}}',
          containerMessage: null,
          containerRoleDescriptionMessage: null,
          itemRoleDescriptionMessage: null,
          slideRole: 'group'
        }
      });
      var liveRegion = null;
      function notify(message) {
        var notification = liveRegion;
        if (notification.length === 0) return;
        notification.html('');
        notification.html(message);
      }
      function getRandomNumber() {
        var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;
        var randomChar = function randomChar() {
          return Math.round(16 * Math.random()).toString(16);
        };
        return 'x'.repeat(size).replace(/x/g, randomChar);
      }
      function makeElFocusable($el) {
        $el.attr('tabIndex', '0');
      }
      function makeElNotFocusable($el) {
        $el.attr('tabIndex', '-1');
      }
      function addElRole($el, role) {
        $el.attr('role', role);
      }
      function addElRoleDescription($el, description) {
        $el.attr('aria-roledescription', description);
      }
      function addElControls($el, controls) {
        $el.attr('aria-controls', controls);
      }
      function addElLabel($el, label) {
        $el.attr('aria-label', label);
      }
      function addElId($el, id) {
        $el.attr('id', id);
      }
      function addElLive($el, live) {
        $el.attr('aria-live', live);
      }
      function disableEl($el) {
        $el.attr('aria-disabled', true);
      }
      function enableEl($el) {
        $el.attr('aria-disabled', false);
      }
      function onEnterOrSpaceKey(e) {
        if (e.keyCode !== 13 && e.keyCode !== 32) return;
        var params = swiper.params.a11y;
        var $targetEl = $(e.target);
        if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
          if (!(swiper.isEnd && !swiper.params.loop)) {
            swiper.slideNext();
          }
          if (swiper.isEnd) {
            notify(params.lastSlideMessage);
          } else {
            notify(params.nextSlideMessage);
          }
        }
        if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
          if (!(swiper.isBeginning && !swiper.params.loop)) {
            swiper.slidePrev();
          }
          if (swiper.isBeginning) {
            notify(params.firstSlideMessage);
          } else {
            notify(params.prevSlideMessage);
          }
        }
        if (swiper.pagination && $targetEl.is(classesToSelector(swiper.params.pagination.bulletClass))) {
          $targetEl[0].click();
        }
      }
      function updateNavigation() {
        if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;
        var _swiper$navigation5 = swiper.navigation,
          $nextEl = _swiper$navigation5.$nextEl,
          $prevEl = _swiper$navigation5.$prevEl;
        if ($prevEl && $prevEl.length > 0) {
          if (swiper.isBeginning) {
            disableEl($prevEl);
            makeElNotFocusable($prevEl);
          } else {
            enableEl($prevEl);
            makeElFocusable($prevEl);
          }
        }
        if ($nextEl && $nextEl.length > 0) {
          if (swiper.isEnd) {
            disableEl($nextEl);
            makeElNotFocusable($nextEl);
          } else {
            enableEl($nextEl);
            makeElFocusable($nextEl);
          }
        }
      }
      function hasPagination() {
        return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;
      }
      function hasClickablePagination() {
        return hasPagination() && swiper.params.pagination.clickable;
      }
      function updatePagination() {
        var params = swiper.params.a11y;
        if (!hasPagination()) return;
        swiper.pagination.bullets.each(function (bulletEl) {
          var $bulletEl = $(bulletEl);
          if (swiper.params.pagination.clickable) {
            makeElFocusable($bulletEl);
            if (!swiper.params.pagination.renderBullet) {
              addElRole($bulletEl, 'button');
              addElLabel($bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, $bulletEl.index() + 1));
            }
          }
          if ($bulletEl.is(".".concat(swiper.params.pagination.bulletActiveClass))) {
            $bulletEl.attr('aria-current', 'true');
          } else {
            $bulletEl.removeAttr('aria-current');
          }
        });
      }
      var initNavEl = function initNavEl($el, wrapperId, message) {
        makeElFocusable($el);
        if ($el[0].tagName !== 'BUTTON') {
          addElRole($el, 'button');
          $el.on('keydown', onEnterOrSpaceKey);
        }
        addElLabel($el, message);
        addElControls($el, wrapperId);
      };
      function init() {
        var params = swiper.params.a11y;
        swiper.$el.append(liveRegion); // Container

        var $containerEl = swiper.$el;
        if (params.containerRoleDescriptionMessage) {
          addElRoleDescription($containerEl, params.containerRoleDescriptionMessage);
        }
        if (params.containerMessage) {
          addElLabel($containerEl, params.containerMessage);
        } // Wrapper

        var $wrapperEl = swiper.$wrapperEl;
        var wrapperId = $wrapperEl.attr('id') || "swiper-wrapper-".concat(getRandomNumber(16));
        var live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';
        addElId($wrapperEl, wrapperId);
        addElLive($wrapperEl, live); // Slide

        if (params.itemRoleDescriptionMessage) {
          addElRoleDescription($(swiper.slides), params.itemRoleDescriptionMessage);
        }
        addElRole($(swiper.slides), params.slideRole);
        var slidesLength = swiper.params.loop ? swiper.slides.filter(function (el) {
          return !el.classList.contains(swiper.params.slideDuplicateClass);
        }).length : swiper.slides.length;
        swiper.slides.each(function (slideEl, index) {
          var $slideEl = $(slideEl);
          var slideIndex = swiper.params.loop ? parseInt($slideEl.attr('data-swiper-slide-index'), 10) : index;
          var ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
          addElLabel($slideEl, ariaLabelMessage);
        }); // Navigation

        var $nextEl;
        var $prevEl;
        if (swiper.navigation && swiper.navigation.$nextEl) {
          $nextEl = swiper.navigation.$nextEl;
        }
        if (swiper.navigation && swiper.navigation.$prevEl) {
          $prevEl = swiper.navigation.$prevEl;
        }
        if ($nextEl && $nextEl.length) {
          initNavEl($nextEl, wrapperId, params.nextSlideMessage);
        }
        if ($prevEl && $prevEl.length) {
          initNavEl($prevEl, wrapperId, params.prevSlideMessage);
        } // Pagination

        if (hasClickablePagination()) {
          swiper.pagination.$el.on('keydown', classesToSelector(swiper.params.pagination.bulletClass), onEnterOrSpaceKey);
        }
      }
      function destroy() {
        if (liveRegion && liveRegion.length > 0) liveRegion.remove();
        var $nextEl;
        var $prevEl;
        if (swiper.navigation && swiper.navigation.$nextEl) {
          $nextEl = swiper.navigation.$nextEl;
        }
        if (swiper.navigation && swiper.navigation.$prevEl) {
          $prevEl = swiper.navigation.$prevEl;
        }
        if ($nextEl) {
          $nextEl.off('keydown', onEnterOrSpaceKey);
        }
        if ($prevEl) {
          $prevEl.off('keydown', onEnterOrSpaceKey);
        } // Pagination

        if (hasClickablePagination()) {
          swiper.pagination.$el.off('keydown', classesToSelector(swiper.params.pagination.bulletClass), onEnterOrSpaceKey);
        }
      }
      on('beforeInit', function () {
        liveRegion = $("<span class=\"".concat(swiper.params.a11y.notificationClass, "\" aria-live=\"assertive\" aria-atomic=\"true\"></span>"));
      });
      on('afterInit', function () {
        if (!swiper.params.a11y.enabled) return;
        init();
        updateNavigation();
      });
      on('toEdge', function () {
        if (!swiper.params.a11y.enabled) return;
        updateNavigation();
      });
      on('fromEdge', function () {
        if (!swiper.params.a11y.enabled) return;
        updateNavigation();
      });
      on('paginationUpdate', function () {
        if (!swiper.params.a11y.enabled) return;
        updatePagination();
      });
      on('destroy', function () {
        if (!swiper.params.a11y.enabled) return;
        destroy();
      });
    }
    function History(_ref18) {
      var swiper = _ref18.swiper,
        extendParams = _ref18.extendParams,
        on = _ref18.on;
      extendParams({
        history: {
          enabled: false,
          root: '',
          replaceState: false,
          key: 'slides'
        }
      });
      var initialized = false;
      var paths = {};
      var slugify = function slugify(text) {
        return text.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
      };
      var getPathValues = function getPathValues(urlOverride) {
        var window = getWindow();
        var location;
        if (urlOverride) {
          location = new URL(urlOverride);
        } else {
          location = window.location;
        }
        var pathArray = location.pathname.slice(1).split('/').filter(function (part) {
          return part !== '';
        });
        var total = pathArray.length;
        var key = pathArray[total - 2];
        var value = pathArray[total - 1];
        return {
          key: key,
          value: value
        };
      };
      var setHistory = function setHistory(key, index) {
        var window = getWindow();
        if (!initialized || !swiper.params.history.enabled) return;
        var location;
        if (swiper.params.url) {
          location = new URL(swiper.params.url);
        } else {
          location = window.location;
        }
        var slide = swiper.slides.eq(index);
        var value = slugify(slide.attr('data-history'));
        if (swiper.params.history.root.length > 0) {
          var root = swiper.params.history.root;
          if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);
          value = "".concat(root, "/").concat(key, "/").concat(value);
        } else if (!location.pathname.includes(key)) {
          value = "".concat(key, "/").concat(value);
        }
        var currentState = window.history.state;
        if (currentState && currentState.value === value) {
          return;
        }
        if (swiper.params.history.replaceState) {
          window.history.replaceState({
            value: value
          }, null, value);
        } else {
          window.history.pushState({
            value: value
          }, null, value);
        }
      };
      var scrollToSlide = function scrollToSlide(speed, value, runCallbacks) {
        if (value) {
          for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
            var _slide3 = swiper.slides.eq(i);
            var slideHistory = slugify(_slide3.attr('data-history'));
            if (slideHistory === value && !_slide3.hasClass(swiper.params.slideDuplicateClass)) {
              var _index2 = _slide3.index();
              swiper.slideTo(_index2, speed, runCallbacks);
            }
          }
        } else {
          swiper.slideTo(0, speed, runCallbacks);
        }
      };
      var setHistoryPopState = function setHistoryPopState() {
        paths = getPathValues(swiper.params.url);
        scrollToSlide(swiper.params.speed, swiper.paths.value, false);
      };
      var init = function init() {
        var window = getWindow();
        if (!swiper.params.history) return;
        if (!window.history || !window.history.pushState) {
          swiper.params.history.enabled = false;
          swiper.params.hashNavigation.enabled = true;
          return;
        }
        initialized = true;
        paths = getPathValues(swiper.params.url);
        if (!paths.key && !paths.value) return;
        scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);
        if (!swiper.params.history.replaceState) {
          window.addEventListener('popstate', setHistoryPopState);
        }
      };
      var destroy = function destroy() {
        var window = getWindow();
        if (!swiper.params.history.replaceState) {
          window.removeEventListener('popstate', setHistoryPopState);
        }
      };
      on('init', function () {
        if (swiper.params.history.enabled) {
          init();
        }
      });
      on('destroy', function () {
        if (swiper.params.history.enabled) {
          destroy();
        }
      });
      on('transitionEnd _freeModeNoMomentumRelease', function () {
        if (initialized) {
          setHistory(swiper.params.history.key, swiper.activeIndex);
        }
      });
      on('slideChange', function () {
        if (initialized && swiper.params.cssMode) {
          setHistory(swiper.params.history.key, swiper.activeIndex);
        }
      });
    }
    function HashNavigation(_ref19) {
      var swiper = _ref19.swiper,
        extendParams = _ref19.extendParams,
        emit = _ref19.emit,
        on = _ref19.on;
      var initialized = false;
      var document = getDocument();
      var window = getWindow();
      extendParams({
        hashNavigation: {
          enabled: false,
          replaceState: false,
          watchState: false
        }
      });
      var onHashChange = function onHashChange() {
        emit('hashChange');
        var newHash = document.location.hash.replace('#', '');
        var activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');
        if (newHash !== activeSlideHash) {
          var newIndex = swiper.$wrapperEl.children(".".concat(swiper.params.slideClass, "[data-hash=\"").concat(newHash, "\"]")).index();
          if (typeof newIndex === 'undefined') return;
          swiper.slideTo(newIndex);
        }
      };
      var setHash = function setHash() {
        if (!initialized || !swiper.params.hashNavigation.enabled) return;
        if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {
          window.history.replaceState(null, null, "#".concat(swiper.slides.eq(swiper.activeIndex).attr('data-hash')) || '');
          emit('hashSet');
        } else {
          var _slide4 = swiper.slides.eq(swiper.activeIndex);
          var hash = _slide4.attr('data-hash') || _slide4.attr('data-history');
          document.location.hash = hash || '';
          emit('hashSet');
        }
      };
      var init = function init() {
        if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;
        initialized = true;
        var hash = document.location.hash.replace('#', '');
        if (hash) {
          var speed = 0;
          for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
            var _slide5 = swiper.slides.eq(i);
            var slideHash = _slide5.attr('data-hash') || _slide5.attr('data-history');
            if (slideHash === hash && !_slide5.hasClass(swiper.params.slideDuplicateClass)) {
              var _index3 = _slide5.index();
              swiper.slideTo(_index3, speed, swiper.params.runCallbacksOnInit, true);
            }
          }
        }
        if (swiper.params.hashNavigation.watchState) {
          $(window).on('hashchange', onHashChange);
        }
      };
      var destroy = function destroy() {
        if (swiper.params.hashNavigation.watchState) {
          $(window).off('hashchange', onHashChange);
        }
      };
      on('init', function () {
        if (swiper.params.hashNavigation.enabled) {
          init();
        }
      });
      on('destroy', function () {
        if (swiper.params.hashNavigation.enabled) {
          destroy();
        }
      });
      on('transitionEnd _freeModeNoMomentumRelease', function () {
        if (initialized) {
          setHash();
        }
      });
      on('slideChange', function () {
        if (initialized && swiper.params.cssMode) {
          setHash();
        }
      });
    }

    /* eslint no-underscore-dangle: "off" */
    function Autoplay(_ref20) {
      var swiper = _ref20.swiper,
        extendParams = _ref20.extendParams,
        on = _ref20.on,
        emit = _ref20.emit;
      var timeout;
      swiper.autoplay = {
        running: false,
        paused: false
      };
      extendParams({
        autoplay: {
          enabled: false,
          delay: 3000,
          waitForTransition: true,
          disableOnInteraction: true,
          stopOnLastSlide: false,
          reverseDirection: false,
          pauseOnMouseEnter: false
        }
      });
      function run() {
        var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
        var delay = swiper.params.autoplay.delay;
        if ($activeSlideEl.attr('data-swiper-autoplay')) {
          delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
        }
        clearTimeout(timeout);
        timeout = nextTick(function () {
          var autoplayResult;
          if (swiper.params.autoplay.reverseDirection) {
            if (swiper.params.loop) {
              swiper.loopFix();
              autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
              emit('autoplay');
            } else if (!swiper.isBeginning) {
              autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
              emit('autoplay');
            } else if (!swiper.params.autoplay.stopOnLastSlide) {
              autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
              emit('autoplay');
            } else {
              stop();
            }
          } else if (swiper.params.loop) {
            swiper.loopFix();
            autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
            emit('autoplay');
          } else if (!swiper.isEnd) {
            autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
            emit('autoplay');
          } else if (!swiper.params.autoplay.stopOnLastSlide) {
            autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);
            emit('autoplay');
          } else {
            stop();
          }
          if (swiper.params.cssMode && swiper.autoplay.running) run();else if (autoplayResult === false) {
            run();
          }
        }, delay);
      }
      function start() {
        if (typeof timeout !== 'undefined') return false;
        if (swiper.autoplay.running) return false;
        swiper.autoplay.running = true;
        emit('autoplayStart');
        run();
        return true;
      }
      function stop() {
        if (!swiper.autoplay.running) return false;
        if (typeof timeout === 'undefined') return false;
        if (timeout) {
          clearTimeout(timeout);
          timeout = undefined;
        }
        swiper.autoplay.running = false;
        emit('autoplayStop');
        return true;
      }
      function pause(speed) {
        if (!swiper.autoplay.running) return;
        if (swiper.autoplay.paused) return;
        if (timeout) clearTimeout(timeout);
        swiper.autoplay.paused = true;
        if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
          swiper.autoplay.paused = false;
          run();
        } else {
          ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
            swiper.$wrapperEl[0].addEventListener(event, onTransitionEnd);
          });
        }
      }
      function onVisibilityChange() {
        var document = getDocument();
        if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
          pause();
        }
        if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
          run();
          swiper.autoplay.paused = false;
        }
      }
      function onTransitionEnd(e) {
        if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
        if (e.target !== swiper.$wrapperEl[0]) return;
        ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
          swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
        });
        swiper.autoplay.paused = false;
        if (!swiper.autoplay.running) {
          stop();
        } else {
          run();
        }
      }
      function onMouseEnter() {
        if (swiper.params.autoplay.disableOnInteraction) {
          stop();
        } else {
          pause();
        }
        ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
          swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
        });
      }
      function onMouseLeave() {
        if (swiper.params.autoplay.disableOnInteraction) {
          return;
        }
        swiper.autoplay.paused = false;
        run();
      }
      function attachMouseEvents() {
        if (swiper.params.autoplay.pauseOnMouseEnter) {
          swiper.$el.on('mouseenter', onMouseEnter);
          swiper.$el.on('mouseleave', onMouseLeave);
        }
      }
      function detachMouseEvents() {
        swiper.$el.off('mouseenter', onMouseEnter);
        swiper.$el.off('mouseleave', onMouseLeave);
      }
      on('init', function () {
        if (swiper.params.autoplay.enabled) {
          start();
          var _document3 = getDocument();
          _document3.addEventListener('visibilitychange', onVisibilityChange);
          attachMouseEvents();
        }
      });
      on('beforeTransitionStart', function (_s, speed, internal) {
        if (swiper.autoplay.running) {
          if (internal || !swiper.params.autoplay.disableOnInteraction) {
            swiper.autoplay.pause(speed);
          } else {
            stop();
          }
        }
      });
      on('sliderFirstMove', function () {
        if (swiper.autoplay.running) {
          if (swiper.params.autoplay.disableOnInteraction) {
            stop();
          } else {
            pause();
          }
        }
      });
      on('touchEnd', function () {
        if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
          run();
        }
      });
      on('destroy', function () {
        detachMouseEvents();
        if (swiper.autoplay.running) {
          stop();
        }
        var document = getDocument();
        document.removeEventListener('visibilitychange', onVisibilityChange);
      });
      Object.assign(swiper.autoplay, {
        pause: pause,
        run: run,
        start: start,
        stop: stop
      });
    }
    function Thumb(_ref21) {
      var swiper = _ref21.swiper,
        extendParams = _ref21.extendParams,
        on = _ref21.on;
      extendParams({
        thumbs: {
          swiper: null,
          multipleActiveThumbs: true,
          autoScrollOffset: 0,
          slideThumbActiveClass: 'swiper-slide-thumb-active',
          thumbsContainerClass: 'swiper-thumbs'
        }
      });
      var initialized = false;
      var swiperCreated = false;
      swiper.thumbs = {
        swiper: null
      };
      function onThumbClick() {
        var thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper) return;
        var clickedIndex = thumbsSwiper.clickedIndex;
        var clickedSlide = thumbsSwiper.clickedSlide;
        if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;
        if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
        var slideToIndex;
        if (thumbsSwiper.params.loop) {
          slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
        } else {
          slideToIndex = clickedIndex;
        }
        if (swiper.params.loop) {
          var currentIndex = swiper.activeIndex;
          if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
            swiper.loopFix(); // eslint-disable-next-line

            swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
            currentIndex = swiper.activeIndex;
          }
          var prevIndex = swiper.slides.eq(currentIndex).prevAll("[data-swiper-slide-index=\"".concat(slideToIndex, "\"]")).eq(0).index();
          var nextIndex = swiper.slides.eq(currentIndex).nextAll("[data-swiper-slide-index=\"".concat(slideToIndex, "\"]")).eq(0).index();
          if (typeof prevIndex === 'undefined') slideToIndex = nextIndex;else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex;else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;else slideToIndex = prevIndex;
        }
        swiper.slideTo(slideToIndex);
      }
      function init() {
        var thumbsParams = swiper.params.thumbs;
        if (initialized) return false;
        initialized = true;
        var SwiperClass = swiper.constructor;
        if (thumbsParams.swiper instanceof SwiperClass) {
          swiper.thumbs.swiper = thumbsParams.swiper;
          Object.assign(swiper.thumbs.swiper.originalParams, {
            watchSlidesProgress: true,
            slideToClickedSlide: false
          });
          Object.assign(swiper.thumbs.swiper.params, {
            watchSlidesProgress: true,
            slideToClickedSlide: false
          });
        } else if (isObject(thumbsParams.swiper)) {
          var thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
          Object.assign(thumbsSwiperParams, {
            watchSlidesProgress: true,
            slideToClickedSlide: false
          });
          swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
          swiperCreated = true;
        }
        swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
        swiper.thumbs.swiper.on('tap', onThumbClick);
        return true;
      }
      function update(initial) {
        var thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper) return;
        var slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
        var autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
        var useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
        if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
          var currentThumbsIndex = thumbsSwiper.activeIndex;
          var newThumbsIndex;
          var direction;
          if (thumbsSwiper.params.loop) {
            if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
              thumbsSwiper.loopFix(); // eslint-disable-next-line

              thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
              currentThumbsIndex = thumbsSwiper.activeIndex;
            } // Find actual thumbs index to slide to

            var prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll("[data-swiper-slide-index=\"".concat(swiper.realIndex, "\"]")).eq(0).index();
            var nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll("[data-swiper-slide-index=\"".concat(swiper.realIndex, "\"]")).eq(0).index();
            if (typeof prevThumbsIndex === 'undefined') {
              newThumbsIndex = nextThumbsIndex;
            } else if (typeof nextThumbsIndex === 'undefined') {
              newThumbsIndex = prevThumbsIndex;
            } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {
              newThumbsIndex = thumbsSwiper.params.slidesPerGroup > 1 ? nextThumbsIndex : currentThumbsIndex;
            } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {
              newThumbsIndex = nextThumbsIndex;
            } else {
              newThumbsIndex = prevThumbsIndex;
            }
            direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';
          } else {
            newThumbsIndex = swiper.realIndex;
            direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';
          }
          if (useOffset) {
            newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;
          }
          if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
            if (thumbsSwiper.params.centeredSlides) {
              if (newThumbsIndex > currentThumbsIndex) {
                newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
              } else {
                newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
              }
            } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) ;
            thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
          }
        } // Activate thumbs

        var thumbsToActivate = 1;
        var thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
        if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
          thumbsToActivate = swiper.params.slidesPerView;
        }
        if (!swiper.params.thumbs.multipleActiveThumbs) {
          thumbsToActivate = 1;
        }
        thumbsToActivate = Math.floor(thumbsToActivate);
        thumbsSwiper.slides.removeClass(thumbActiveClass);
        if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
          for (var i = 0; i < thumbsToActivate; i += 1) {
            thumbsSwiper.$wrapperEl.children("[data-swiper-slide-index=\"".concat(swiper.realIndex + i, "\"]")).addClass(thumbActiveClass);
          }
        } else {
          for (var _i11 = 0; _i11 < thumbsToActivate; _i11 += 1) {
            thumbsSwiper.slides.eq(swiper.realIndex + _i11).addClass(thumbActiveClass);
          }
        }
      }
      on('beforeInit', function () {
        var thumbs = swiper.params.thumbs;
        if (!thumbs || !thumbs.swiper) return;
        init();
        update(true);
      });
      on('slideChange update resize observerUpdate', function () {
        if (!swiper.thumbs.swiper) return;
        update();
      });
      on('setTransition', function (_s, duration) {
        var thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper) return;
        thumbsSwiper.setTransition(duration);
      });
      on('beforeDestroy', function () {
        var thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper) return;
        if (swiperCreated && thumbsSwiper) {
          thumbsSwiper.destroy();
        }
      });
      Object.assign(swiper.thumbs, {
        init: init,
        update: update
      });
    }
    function freeMode(_ref22) {
      var swiper = _ref22.swiper,
        extendParams = _ref22.extendParams,
        emit = _ref22.emit,
        once = _ref22.once;
      extendParams({
        freeMode: {
          enabled: false,
          momentum: true,
          momentumRatio: 1,
          momentumBounce: true,
          momentumBounceRatio: 1,
          momentumVelocityRatio: 1,
          sticky: false,
          minimumVelocity: 0.02
        }
      });
      function onTouchMove() {
        var data = swiper.touchEventsData,
          touches = swiper.touches; // Velocity

        if (data.velocities.length === 0) {
          data.velocities.push({
            position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
            time: data.touchStartTime
          });
        }
        data.velocities.push({
          position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
          time: now()
        });
      }
      function onTouchEnd(_ref23) {
        var currentPos = _ref23.currentPos;
        var params = swiper.params,
          $wrapperEl = swiper.$wrapperEl,
          rtl = swiper.rtlTranslate,
          snapGrid = swiper.snapGrid,
          data = swiper.touchEventsData; // Time diff

        var touchEndTime = now();
        var timeDiff = touchEndTime - data.touchStartTime;
        if (currentPos < -swiper.minTranslate()) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }
        if (currentPos > -swiper.maxTranslate()) {
          if (swiper.slides.length < snapGrid.length) {
            swiper.slideTo(snapGrid.length - 1);
          } else {
            swiper.slideTo(swiper.slides.length - 1);
          }
          return;
        }
        if (params.freeMode.momentum) {
          if (data.velocities.length > 1) {
            var lastMoveEvent = data.velocities.pop();
            var velocityEvent = data.velocities.pop();
            var distance = lastMoveEvent.position - velocityEvent.position;
            var time = lastMoveEvent.time - velocityEvent.time;
            swiper.velocity = distance / time;
            swiper.velocity /= 2;
            if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {
              swiper.velocity = 0;
            } // this implies that the user stopped moving a finger then released.
            // There would be no events with distance zero, so the last event is stale.

            if (time > 150 || now() - lastMoveEvent.time > 300) {
              swiper.velocity = 0;
            }
          } else {
            swiper.velocity = 0;
          }
          swiper.velocity *= params.freeMode.momentumVelocityRatio;
          data.velocities.length = 0;
          var momentumDuration = 1000 * params.freeMode.momentumRatio;
          var momentumDistance = swiper.velocity * momentumDuration;
          var newPosition = swiper.translate + momentumDistance;
          if (rtl) newPosition = -newPosition;
          var doBounce = false;
          var afterBouncePosition;
          var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
          var needsLoopFix;
          if (newPosition < swiper.maxTranslate()) {
            if (params.freeMode.momentumBounce) {
              if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                newPosition = swiper.maxTranslate() - bounceAmount;
              }
              afterBouncePosition = swiper.maxTranslate();
              doBounce = true;
              data.allowMomentumBounce = true;
            } else {
              newPosition = swiper.maxTranslate();
            }
            if (params.loop && params.centeredSlides) needsLoopFix = true;
          } else if (newPosition > swiper.minTranslate()) {
            if (params.freeMode.momentumBounce) {
              if (newPosition - swiper.minTranslate() > bounceAmount) {
                newPosition = swiper.minTranslate() + bounceAmount;
              }
              afterBouncePosition = swiper.minTranslate();
              doBounce = true;
              data.allowMomentumBounce = true;
            } else {
              newPosition = swiper.minTranslate();
            }
            if (params.loop && params.centeredSlides) needsLoopFix = true;
          } else if (params.freeMode.sticky) {
            var nextSlide;
            for (var j = 0; j < snapGrid.length; j += 1) {
              if (snapGrid[j] > -newPosition) {
                nextSlide = j;
                break;
              }
            }
            if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
              newPosition = snapGrid[nextSlide];
            } else {
              newPosition = snapGrid[nextSlide - 1];
            }
            newPosition = -newPosition;
          }
          if (needsLoopFix) {
            once('transitionEnd', function () {
              swiper.loopFix();
            });
          } // Fix duration

          if (swiper.velocity !== 0) {
            if (rtl) {
              momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
            } else {
              momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
            }
            if (params.freeMode.sticky) {
              // If freeMode.sticky is active and the user ends a swipe with a slow-velocity
              // event, then durations can be 20+ seconds to slide one (or zero!) slides.
              // It's easy to see this when simulating touch with mouse events. To fix this,
              // limit single-slide swipes to the default slide duration. This also has the
              // nice side effect of matching slide speed if the user stopped moving before
              // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
              // For faster swipes, also apply limits (albeit higher ones).
              var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
              var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
              if (moveDistance < currentSlideSize) {
                momentumDuration = params.speed;
              } else if (moveDistance < 2 * currentSlideSize) {
                momentumDuration = params.speed * 1.5;
              } else {
                momentumDuration = params.speed * 2.5;
              }
            }
          } else if (params.freeMode.sticky) {
            swiper.slideToClosest();
            return;
          }
          if (params.freeMode.momentumBounce && doBounce) {
            swiper.updateProgress(afterBouncePosition);
            swiper.setTransition(momentumDuration);
            swiper.setTranslate(newPosition);
            swiper.transitionStart(true, swiper.swipeDirection);
            swiper.animating = true;
            $wrapperEl.transitionEnd(function () {
              if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
              emit('momentumBounce');
              swiper.setTransition(params.speed);
              setTimeout(function () {
                swiper.setTranslate(afterBouncePosition);
                $wrapperEl.transitionEnd(function () {
                  if (!swiper || swiper.destroyed) return;
                  swiper.transitionEnd();
                });
              }, 0);
            });
          } else if (swiper.velocity) {
            emit('_freeModeNoMomentumRelease');
            swiper.updateProgress(newPosition);
            swiper.setTransition(momentumDuration);
            swiper.setTranslate(newPosition);
            swiper.transitionStart(true, swiper.swipeDirection);
            if (!swiper.animating) {
              swiper.animating = true;
              $wrapperEl.transitionEnd(function () {
                if (!swiper || swiper.destroyed) return;
                swiper.transitionEnd();
              });
            }
          } else {
            swiper.updateProgress(newPosition);
          }
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        } else if (params.freeMode.sticky) {
          swiper.slideToClosest();
          return;
        } else if (params.freeMode) {
          emit('_freeModeNoMomentumRelease');
        }
        if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
          swiper.updateProgress();
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        }
      }
      Object.assign(swiper, {
        freeMode: {
          onTouchMove: onTouchMove,
          onTouchEnd: onTouchEnd
        }
      });
    }
    function Grid(_ref24) {
      var swiper = _ref24.swiper,
        extendParams = _ref24.extendParams;
      extendParams({
        grid: {
          rows: 1,
          fill: 'column'
        }
      });
      var slidesNumberEvenToRows;
      var slidesPerRow;
      var numFullColumns;
      var initSlides = function initSlides(slidesLength) {
        var slidesPerView = swiper.params.slidesPerView;
        var _swiper$params$grid = swiper.params.grid,
          rows = _swiper$params$grid.rows,
          fill = _swiper$params$grid.fill;
        slidesPerRow = slidesNumberEvenToRows / rows;
        numFullColumns = Math.floor(slidesLength / rows);
        if (Math.floor(slidesLength / rows) === slidesLength / rows) {
          slidesNumberEvenToRows = slidesLength;
        } else {
          slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;
        }
        if (slidesPerView !== 'auto' && fill === 'row') {
          slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);
        }
      };
      var updateSlide = function updateSlide(i, slide, slidesLength, getDirectionLabel) {
        var _swiper$params3 = swiper.params,
          slidesPerGroup = _swiper$params3.slidesPerGroup,
          spaceBetween = _swiper$params3.spaceBetween;
        var _swiper$params$grid2 = swiper.params.grid,
          rows = _swiper$params$grid2.rows,
          fill = _swiper$params$grid2.fill; // Set slides order

        var newSlideOrderIndex;
        var column;
        var row;
        if (fill === 'row' && slidesPerGroup > 1) {
          var groupIndex = Math.floor(i / (slidesPerGroup * rows));
          var slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;
          var columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);
          row = Math.floor(slideIndexInGroup / columnsInGroup);
          column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;
          newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;
          slide.css({
            '-webkit-order': newSlideOrderIndex,
            order: newSlideOrderIndex
          });
        } else if (fill === 'column') {
          column = Math.floor(i / rows);
          row = i - column * rows;
          if (column > numFullColumns || column === numFullColumns && row === rows - 1) {
            row += 1;
            if (row >= rows) {
              row = 0;
              column += 1;
            }
          }
        } else {
          row = Math.floor(i / slidesPerRow);
          column = i - row * slidesPerRow;
        }
        slide.css(getDirectionLabel('margin-top'), row !== 0 ? spaceBetween && "".concat(spaceBetween, "px") : '');
      };
      var updateWrapperSize = function updateWrapperSize(slideSize, snapGrid, getDirectionLabel) {
        var _swiper$params4 = swiper.params,
          spaceBetween = _swiper$params4.spaceBetween,
          centeredSlides = _swiper$params4.centeredSlides,
          roundLengths = _swiper$params4.roundLengths;
        var rows = swiper.params.grid.rows;
        swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;
        swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;
        swiper.$wrapperEl.css(_defineProperty({}, getDirectionLabel('width'), "".concat(swiper.virtualSize + spaceBetween, "px")));
        if (centeredSlides) {
          snapGrid.splice(0, snapGrid.length);
          var newSlidesGrid = [];
          for (var i = 0; i < snapGrid.length; i += 1) {
            var slidesGridItem = snapGrid[i];
            if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);
            if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
          }
          snapGrid.push.apply(snapGrid, newSlidesGrid);
        }
      };
      swiper.grid = {
        initSlides: initSlides,
        updateSlide: updateSlide,
        updateWrapperSize: updateWrapperSize
      };
    }
    function appendSlide(slides) {
      var swiper = this;
      var $wrapperEl = swiper.$wrapperEl,
        params = swiper.params;
      if (params.loop) {
        swiper.loopDestroy();
      }
      if (_typeof(slides) === 'object' && 'length' in slides) {
        for (var i = 0; i < slides.length; i += 1) {
          if (slides[i]) $wrapperEl.append(slides[i]);
        }
      } else {
        $wrapperEl.append(slides);
      }
      if (params.loop) {
        swiper.loopCreate();
      }
      if (!params.observer) {
        swiper.update();
      }
    }
    function prependSlide(slides) {
      var swiper = this;
      var params = swiper.params,
        $wrapperEl = swiper.$wrapperEl,
        activeIndex = swiper.activeIndex;
      if (params.loop) {
        swiper.loopDestroy();
      }
      var newActiveIndex = activeIndex + 1;
      if (_typeof(slides) === 'object' && 'length' in slides) {
        for (var i = 0; i < slides.length; i += 1) {
          if (slides[i]) $wrapperEl.prepend(slides[i]);
        }
        newActiveIndex = activeIndex + slides.length;
      } else {
        $wrapperEl.prepend(slides);
      }
      if (params.loop) {
        swiper.loopCreate();
      }
      if (!params.observer) {
        swiper.update();
      }
      swiper.slideTo(newActiveIndex, 0, false);
    }
    function addSlide(index, slides) {
      var swiper = this;
      var $wrapperEl = swiper.$wrapperEl,
        params = swiper.params,
        activeIndex = swiper.activeIndex;
      var activeIndexBuffer = activeIndex;
      if (params.loop) {
        activeIndexBuffer -= swiper.loopedSlides;
        swiper.loopDestroy();
        swiper.slides = $wrapperEl.children(".".concat(params.slideClass));
      }
      var baseLength = swiper.slides.length;
      if (index <= 0) {
        swiper.prependSlide(slides);
        return;
      }
      if (index >= baseLength) {
        swiper.appendSlide(slides);
        return;
      }
      var newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
      var slidesBuffer = [];
      for (var i = baseLength - 1; i >= index; i -= 1) {
        var currentSlide = swiper.slides.eq(i);
        currentSlide.remove();
        slidesBuffer.unshift(currentSlide);
      }
      if (_typeof(slides) === 'object' && 'length' in slides) {
        for (var _i12 = 0; _i12 < slides.length; _i12 += 1) {
          if (slides[_i12]) $wrapperEl.append(slides[_i12]);
        }
        newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
      } else {
        $wrapperEl.append(slides);
      }
      for (var _i13 = 0; _i13 < slidesBuffer.length; _i13 += 1) {
        $wrapperEl.append(slidesBuffer[_i13]);
      }
      if (params.loop) {
        swiper.loopCreate();
      }
      if (!params.observer) {
        swiper.update();
      }
      if (params.loop) {
        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
      } else {
        swiper.slideTo(newActiveIndex, 0, false);
      }
    }
    function removeSlide(slidesIndexes) {
      var swiper = this;
      var params = swiper.params,
        $wrapperEl = swiper.$wrapperEl,
        activeIndex = swiper.activeIndex;
      var activeIndexBuffer = activeIndex;
      if (params.loop) {
        activeIndexBuffer -= swiper.loopedSlides;
        swiper.loopDestroy();
        swiper.slides = $wrapperEl.children(".".concat(params.slideClass));
      }
      var newActiveIndex = activeIndexBuffer;
      var indexToRemove;
      if (_typeof(slidesIndexes) === 'object' && 'length' in slidesIndexes) {
        for (var i = 0; i < slidesIndexes.length; i += 1) {
          indexToRemove = slidesIndexes[i];
          if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
          if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
        }
        newActiveIndex = Math.max(newActiveIndex, 0);
      } else {
        indexToRemove = slidesIndexes;
        if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
        if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
        newActiveIndex = Math.max(newActiveIndex, 0);
      }
      if (params.loop) {
        swiper.loopCreate();
      }
      if (!params.observer) {
        swiper.update();
      }
      if (params.loop) {
        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
      } else {
        swiper.slideTo(newActiveIndex, 0, false);
      }
    }
    function removeAllSlides() {
      var swiper = this;
      var slidesIndexes = [];
      for (var i = 0; i < swiper.slides.length; i += 1) {
        slidesIndexes.push(i);
      }
      swiper.removeSlide(slidesIndexes);
    }
    function Manipulation(_ref25) {
      var swiper = _ref25.swiper;
      Object.assign(swiper, {
        appendSlide: appendSlide.bind(swiper),
        prependSlide: prependSlide.bind(swiper),
        addSlide: addSlide.bind(swiper),
        removeSlide: removeSlide.bind(swiper),
        removeAllSlides: removeAllSlides.bind(swiper)
      });
    }
    function effectInit(params) {
      var effect = params.effect,
        swiper = params.swiper,
        on = params.on,
        setTranslate = params.setTranslate,
        setTransition = params.setTransition,
        overwriteParams = params.overwriteParams,
        perspective = params.perspective;
      on('beforeInit', function () {
        if (swiper.params.effect !== effect) return;
        swiper.classNames.push("".concat(swiper.params.containerModifierClass).concat(effect));
        if (perspective && perspective()) {
          swiper.classNames.push("".concat(swiper.params.containerModifierClass, "3d"));
        }
        var overwriteParamsResult = overwriteParams ? overwriteParams() : {};
        Object.assign(swiper.params, overwriteParamsResult);
        Object.assign(swiper.originalParams, overwriteParamsResult);
      });
      on('setTranslate', function () {
        if (swiper.params.effect !== effect) return;
        setTranslate();
      });
      on('setTransition', function (_s, duration) {
        if (swiper.params.effect !== effect) return;
        setTransition(duration);
      });
    }
    function effectTarget(effectParams, $slideEl) {
      if (effectParams.transformEl) {
        return $slideEl.find(effectParams.transformEl).css({
          'backface-visibility': 'hidden',
          '-webkit-backface-visibility': 'hidden'
        });
      }
      return $slideEl;
    }
    function effectVirtualTransitionEnd(_ref26) {
      var swiper = _ref26.swiper,
        duration = _ref26.duration,
        transformEl = _ref26.transformEl,
        allSlides = _ref26.allSlides;
      var slides = swiper.slides,
        activeIndex = swiper.activeIndex,
        $wrapperEl = swiper.$wrapperEl;
      if (swiper.params.virtualTranslate && duration !== 0) {
        var eventTriggered = false;
        var $transitionEndTarget;
        if (allSlides) {
          $transitionEndTarget = transformEl ? slides.find(transformEl) : slides;
        } else {
          $transitionEndTarget = transformEl ? slides.eq(activeIndex).find(transformEl) : slides.eq(activeIndex);
        }
        $transitionEndTarget.transitionEnd(function () {
          if (eventTriggered) return;
          if (!swiper || swiper.destroyed) return;
          eventTriggered = true;
          swiper.animating = false;
          var triggerEvents = ['webkitTransitionEnd', 'transitionend'];
          for (var i = 0; i < triggerEvents.length; i += 1) {
            $wrapperEl.trigger(triggerEvents[i]);
          }
        });
      }
    }
    function EffectFade(_ref27) {
      var swiper = _ref27.swiper,
        extendParams = _ref27.extendParams,
        on = _ref27.on;
      extendParams({
        fadeEffect: {
          crossFade: false,
          transformEl: null
        }
      });
      var setTranslate = function setTranslate() {
        var slides = swiper.slides;
        var params = swiper.params.fadeEffect;
        for (var i = 0; i < slides.length; i += 1) {
          var $slideEl = swiper.slides.eq(i);
          var _offset = $slideEl[0].swiperSlideOffset;
          var tx = -_offset;
          if (!swiper.params.virtualTranslate) tx -= swiper.translate;
          var ty = 0;
          if (!swiper.isHorizontal()) {
            ty = tx;
            tx = 0;
          }
          var slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
          var $targetEl = effectTarget(params, $slideEl);
          $targetEl.css({
            opacity: slideOpacity
          }).transform("translate3d(".concat(tx, "px, ").concat(ty, "px, 0px)"));
        }
      };
      var setTransition = function setTransition(duration) {
        var transformEl = swiper.params.fadeEffect.transformEl;
        var $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
        $transitionElements.transition(duration);
        effectVirtualTransitionEnd({
          swiper: swiper,
          duration: duration,
          transformEl: transformEl,
          allSlides: true
        });
      };
      effectInit({
        effect: 'fade',
        swiper: swiper,
        on: on,
        setTranslate: setTranslate,
        setTransition: setTransition,
        overwriteParams: function overwriteParams() {
          return {
            slidesPerView: 1,
            slidesPerGroup: 1,
            watchSlidesProgress: true,
            spaceBetween: 0,
            virtualTranslate: !swiper.params.cssMode
          };
        }
      });
    }
    function EffectCube(_ref28) {
      var swiper = _ref28.swiper,
        extendParams = _ref28.extendParams,
        on = _ref28.on;
      extendParams({
        cubeEffect: {
          slideShadows: true,
          shadow: true,
          shadowOffset: 20,
          shadowScale: 0.94
        }
      });
      var setTranslate = function setTranslate() {
        var $el = swiper.$el,
          $wrapperEl = swiper.$wrapperEl,
          slides = swiper.slides,
          swiperWidth = swiper.width,
          swiperHeight = swiper.height,
          rtl = swiper.rtlTranslate,
          swiperSize = swiper.size,
          browser = swiper.browser;
        var params = swiper.params.cubeEffect;
        var isHorizontal = swiper.isHorizontal();
        var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
        var wrapperRotate = 0;
        var $cubeShadowEl;
        if (params.shadow) {
          if (isHorizontal) {
            $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');
            if ($cubeShadowEl.length === 0) {
              $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
              $wrapperEl.append($cubeShadowEl);
            }
            $cubeShadowEl.css({
              height: "".concat(swiperWidth, "px")
            });
          } else {
            $cubeShadowEl = $el.find('.swiper-cube-shadow');
            if ($cubeShadowEl.length === 0) {
              $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
              $el.append($cubeShadowEl);
            }
          }
        }
        for (var i = 0; i < slides.length; i += 1) {
          var $slideEl = slides.eq(i);
          var slideIndex = i;
          if (isVirtual) {
            slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
          }
          var slideAngle = slideIndex * 90;
          var round = Math.floor(slideAngle / 360);
          if (rtl) {
            slideAngle = -slideAngle;
            round = Math.floor(-slideAngle / 360);
          }
          var progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
          var tx = 0;
          var ty = 0;
          var tz = 0;
          if (slideIndex % 4 === 0) {
            tx = -round * 4 * swiperSize;
            tz = 0;
          } else if ((slideIndex - 1) % 4 === 0) {
            tx = 0;
            tz = -round * 4 * swiperSize;
          } else if ((slideIndex - 2) % 4 === 0) {
            tx = swiperSize + round * 4 * swiperSize;
            tz = swiperSize;
          } else if ((slideIndex - 3) % 4 === 0) {
            tx = -swiperSize;
            tz = 3 * swiperSize + swiperSize * 4 * round;
          }
          if (rtl) {
            tx = -tx;
          }
          if (!isHorizontal) {
            ty = tx;
            tx = 0;
          }
          var _transform = "rotateX(".concat(isHorizontal ? 0 : -slideAngle, "deg) rotateY(").concat(isHorizontal ? slideAngle : 0, "deg) translate3d(").concat(tx, "px, ").concat(ty, "px, ").concat(tz, "px)");
          if (progress <= 1 && progress > -1) {
            wrapperRotate = slideIndex * 90 + progress * 90;
            if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
          }
          $slideEl.transform(_transform);
          if (params.slideShadows) {
            // Set shadows
            var shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
            var shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
            if (shadowBefore.length === 0) {
              shadowBefore = $("<div class=\"swiper-slide-shadow-".concat(isHorizontal ? 'left' : 'top', "\"></div>"));
              $slideEl.append(shadowBefore);
            }
            if (shadowAfter.length === 0) {
              shadowAfter = $("<div class=\"swiper-slide-shadow-".concat(isHorizontal ? 'right' : 'bottom', "\"></div>"));
              $slideEl.append(shadowAfter);
            }
            if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
            if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
          }
        }
        $wrapperEl.css({
          '-webkit-transform-origin': "50% 50% -".concat(swiperSize / 2, "px"),
          'transform-origin': "50% 50% -".concat(swiperSize / 2, "px")
        });
        if (params.shadow) {
          if (isHorizontal) {
            $cubeShadowEl.transform("translate3d(0px, ".concat(swiperWidth / 2 + params.shadowOffset, "px, ").concat(-swiperWidth / 2, "px) rotateX(90deg) rotateZ(0deg) scale(").concat(params.shadowScale, ")"));
          } else {
            var shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
            var multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
            var scale1 = params.shadowScale;
            var scale2 = params.shadowScale / multiplier;
            var _offset2 = params.shadowOffset;
            $cubeShadowEl.transform("scale3d(".concat(scale1, ", 1, ").concat(scale2, ") translate3d(0px, ").concat(swiperHeight / 2 + _offset2, "px, ").concat(-swiperHeight / 2 / scale2, "px) rotateX(-90deg)"));
          }
        }
        var zFactor = browser.isSafari || browser.isWebView ? -swiperSize / 2 : 0;
        $wrapperEl.transform("translate3d(0px,0,".concat(zFactor, "px) rotateX(").concat(swiper.isHorizontal() ? 0 : wrapperRotate, "deg) rotateY(").concat(swiper.isHorizontal() ? -wrapperRotate : 0, "deg)"));
      };
      var setTransition = function setTransition(duration) {
        var $el = swiper.$el,
          slides = swiper.slides;
        slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
        if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
          $el.find('.swiper-cube-shadow').transition(duration);
        }
      };
      effectInit({
        effect: 'cube',
        swiper: swiper,
        on: on,
        setTranslate: setTranslate,
        setTransition: setTransition,
        perspective: function perspective() {
          return true;
        },
        overwriteParams: function overwriteParams() {
          return {
            slidesPerView: 1,
            slidesPerGroup: 1,
            watchSlidesProgress: true,
            resistanceRatio: 0,
            spaceBetween: 0,
            centeredSlides: false,
            virtualTranslate: true
          };
        }
      });
    }
    function createShadow(params, $slideEl, side) {
      var shadowClass = "swiper-slide-shadow".concat(side ? "-".concat(side) : '');
      var $shadowContainer = params.transformEl ? $slideEl.find(params.transformEl) : $slideEl;
      var $shadowEl = $shadowContainer.children(".".concat(shadowClass));
      if (!$shadowEl.length) {
        $shadowEl = $("<div class=\"swiper-slide-shadow".concat(side ? "-".concat(side) : '', "\"></div>"));
        $shadowContainer.append($shadowEl);
      }
      return $shadowEl;
    }
    function EffectFlip(_ref29) {
      var swiper = _ref29.swiper,
        extendParams = _ref29.extendParams,
        on = _ref29.on;
      extendParams({
        flipEffect: {
          slideShadows: true,
          limitRotation: true,
          transformEl: null
        }
      });
      var setTranslate = function setTranslate() {
        var slides = swiper.slides,
          rtl = swiper.rtlTranslate;
        var params = swiper.params.flipEffect;
        for (var i = 0; i < slides.length; i += 1) {
          var $slideEl = slides.eq(i);
          var progress = $slideEl[0].progress;
          if (swiper.params.flipEffect.limitRotation) {
            progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
          }
          var _offset3 = $slideEl[0].swiperSlideOffset;
          var rotate = -180 * progress;
          var rotateY = rotate;
          var rotateX = 0;
          var tx = swiper.params.cssMode ? -_offset3 - swiper.translate : -_offset3;
          var ty = 0;
          if (!swiper.isHorizontal()) {
            ty = tx;
            tx = 0;
            rotateX = -rotateY;
            rotateY = 0;
          } else if (rtl) {
            rotateY = -rotateY;
          }
          $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;
          if (params.slideShadows) {
            // Set shadows
            var shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
            var shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
            if (shadowBefore.length === 0) {
              shadowBefore = createShadow(params, $slideEl, swiper.isHorizontal() ? 'left' : 'top');
            }
            if (shadowAfter.length === 0) {
              shadowAfter = createShadow(params, $slideEl, swiper.isHorizontal() ? 'right' : 'bottom');
            }
            if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
            if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
          }
          var _transform2 = "translate3d(".concat(tx, "px, ").concat(ty, "px, 0px) rotateX(").concat(rotateX, "deg) rotateY(").concat(rotateY, "deg)");
          var $targetEl = effectTarget(params, $slideEl);
          $targetEl.transform(_transform2);
        }
      };
      var setTransition = function setTransition(duration) {
        var transformEl = swiper.params.flipEffect.transformEl;
        var $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
        $transitionElements.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
        effectVirtualTransitionEnd({
          swiper: swiper,
          duration: duration,
          transformEl: transformEl
        });
      };
      effectInit({
        effect: 'flip',
        swiper: swiper,
        on: on,
        setTranslate: setTranslate,
        setTransition: setTransition,
        perspective: function perspective() {
          return true;
        },
        overwriteParams: function overwriteParams() {
          return {
            slidesPerView: 1,
            slidesPerGroup: 1,
            watchSlidesProgress: true,
            spaceBetween: 0,
            virtualTranslate: !swiper.params.cssMode
          };
        }
      });
    }
    function EffectCoverflow(_ref30) {
      var swiper = _ref30.swiper,
        extendParams = _ref30.extendParams,
        on = _ref30.on;
      extendParams({
        coverflowEffect: {
          rotate: 50,
          stretch: 0,
          depth: 100,
          scale: 1,
          modifier: 1,
          slideShadows: true,
          transformEl: null
        }
      });
      var setTranslate = function setTranslate() {
        var swiperWidth = swiper.width,
          swiperHeight = swiper.height,
          slides = swiper.slides,
          slidesSizesGrid = swiper.slidesSizesGrid;
        var params = swiper.params.coverflowEffect;
        var isHorizontal = swiper.isHorizontal();
        var transform = swiper.translate;
        var center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
        var rotate = isHorizontal ? params.rotate : -params.rotate;
        var translate = params.depth; // Each slide offset from center

        for (var i = 0, length = slides.length; i < length; i += 1) {
          var $slideEl = slides.eq(i);
          var slideSize = slidesSizesGrid[i];
          var slideOffset = $slideEl[0].swiperSlideOffset;
          var offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * params.modifier;
          var rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
          var rotateX = isHorizontal ? 0 : rotate * offsetMultiplier; // var rotateZ = 0

          var translateZ = -translate * Math.abs(offsetMultiplier);
          var stretch = params.stretch; // Allow percentage to make a relative stretch for responsive sliders

          if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
            stretch = parseFloat(params.stretch) / 100 * slideSize;
          }
          var translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
          var translateX = isHorizontal ? stretch * offsetMultiplier : 0;
          var scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier); // Fix for ultra small values

          if (Math.abs(translateX) < 0.001) translateX = 0;
          if (Math.abs(translateY) < 0.001) translateY = 0;
          if (Math.abs(translateZ) < 0.001) translateZ = 0;
          if (Math.abs(rotateY) < 0.001) rotateY = 0;
          if (Math.abs(rotateX) < 0.001) rotateX = 0;
          if (Math.abs(scale) < 0.001) scale = 0;
          var slideTransform = "translate3d(".concat(translateX, "px,").concat(translateY, "px,").concat(translateZ, "px)  rotateX(").concat(rotateX, "deg) rotateY(").concat(rotateY, "deg) scale(").concat(scale, ")");
          var $targetEl = effectTarget(params, $slideEl);
          $targetEl.transform(slideTransform);
          $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
          if (params.slideShadows) {
            // Set shadows
            var $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
            var $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
            if ($shadowBeforeEl.length === 0) {
              $shadowBeforeEl = createShadow(params, $slideEl, isHorizontal ? 'left' : 'top');
            }
            if ($shadowAfterEl.length === 0) {
              $shadowAfterEl = createShadow(params, $slideEl, isHorizontal ? 'right' : 'bottom');
            }
            if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
            if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
          }
        }
      };
      var setTransition = function setTransition(duration) {
        var transformEl = swiper.params.coverflowEffect.transformEl;
        var $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
        $transitionElements.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
      };
      effectInit({
        effect: 'coverflow',
        swiper: swiper,
        on: on,
        setTranslate: setTranslate,
        setTransition: setTransition,
        perspective: function perspective() {
          return true;
        },
        overwriteParams: function overwriteParams() {
          return {
            watchSlidesProgress: true
          };
        }
      });
    }
    function EffectCreative(_ref31) {
      var swiper = _ref31.swiper,
        extendParams = _ref31.extendParams,
        on = _ref31.on;
      extendParams({
        creativeEffect: {
          transformEl: null,
          limitProgress: 1,
          shadowPerProgress: false,
          progressMultiplier: 1,
          perspective: true,
          prev: {
            translate: [0, 0, 0],
            rotate: [0, 0, 0],
            opacity: 1,
            scale: 1
          },
          next: {
            translate: [0, 0, 0],
            rotate: [0, 0, 0],
            opacity: 1,
            scale: 1
          }
        }
      });
      var getTranslateValue = function getTranslateValue(value) {
        if (typeof value === 'string') return value;
        return "".concat(value, "px");
      };
      var setTranslate = function setTranslate() {
        var slides = swiper.slides,
          $wrapperEl = swiper.$wrapperEl,
          slidesSizesGrid = swiper.slidesSizesGrid;
        var params = swiper.params.creativeEffect;
        var multiplier = params.progressMultiplier;
        var isCenteredSlides = swiper.params.centeredSlides;
        if (isCenteredSlides) {
          var margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;
          $wrapperEl.transform("translateX(calc(50% - ".concat(margin, "px))"));
        }
        var _loop = function _loop() {
          var $slideEl = slides.eq(i);
          var slideProgress = $slideEl[0].progress;
          var progress = Math.min(Math.max($slideEl[0].progress, -params.limitProgress), params.limitProgress);
          var originalProgress = progress;
          if (!isCenteredSlides) {
            originalProgress = Math.min(Math.max($slideEl[0].originalProgress, -params.limitProgress), params.limitProgress);
          }
          var offset = $slideEl[0].swiperSlideOffset;
          var t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];
          var r = [0, 0, 0];
          var custom = false;
          if (!swiper.isHorizontal()) {
            t[1] = t[0];
            t[0] = 0;
          }
          var data = {
            translate: [0, 0, 0],
            rotate: [0, 0, 0],
            scale: 1,
            opacity: 1
          };
          if (progress < 0) {
            data = params.next;
            custom = true;
          } else if (progress > 0) {
            data = params.prev;
            custom = true;
          } // set translate

          t.forEach(function (value, index) {
            t[index] = "calc(".concat(value, "px + (").concat(getTranslateValue(data.translate[index]), " * ").concat(Math.abs(progress * multiplier), "))");
          }); // set rotates

          r.forEach(function (value, index) {
            r[index] = data.rotate[index] * Math.abs(progress * multiplier);
          });
          $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
          var translateString = t.join(', ');
          var rotateString = "rotateX(".concat(r[0], "deg) rotateY(").concat(r[1], "deg) rotateZ(").concat(r[2], "deg)");
          var scaleString = originalProgress < 0 ? "scale(".concat(1 + (1 - data.scale) * originalProgress * multiplier, ")") : "scale(".concat(1 - (1 - data.scale) * originalProgress * multiplier, ")");
          var opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;
          var transform = "translate3d(".concat(translateString, ") ").concat(rotateString, " ").concat(scaleString); // Set shadows

          if (custom && data.shadow || !custom) {
            var $shadowEl = $slideEl.children('.swiper-slide-shadow');
            if ($shadowEl.length === 0 && data.shadow) {
              $shadowEl = createShadow(params, $slideEl);
            }
            if ($shadowEl.length) {
              var shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;
              $shadowEl[0].style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);
            }
          }
          var $targetEl = effectTarget(params, $slideEl);
          $targetEl.transform(transform).css({
            opacity: opacityString
          });
          if (data.origin) {
            $targetEl.css('transform-origin', data.origin);
          }
        };
        for (var i = 0; i < slides.length; i += 1) {
          _loop();
        }
      };
      var setTransition = function setTransition(duration) {
        var transformEl = swiper.params.creativeEffect.transformEl;
        var $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
        $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);
        effectVirtualTransitionEnd({
          swiper: swiper,
          duration: duration,
          transformEl: transformEl,
          allSlides: true
        });
      };
      effectInit({
        effect: 'creative',
        swiper: swiper,
        on: on,
        setTranslate: setTranslate,
        setTransition: setTransition,
        perspective: function perspective() {
          return swiper.params.creativeEffect.perspective;
        },
        overwriteParams: function overwriteParams() {
          return {
            watchSlidesProgress: true,
            virtualTranslate: !swiper.params.cssMode
          };
        }
      });
    }
    function EffectCards(_ref32) {
      var swiper = _ref32.swiper,
        extendParams = _ref32.extendParams,
        on = _ref32.on;
      extendParams({
        cardsEffect: {
          slideShadows: true,
          transformEl: null
        }
      });
      var setTranslate = function setTranslate() {
        var slides = swiper.slides,
          activeIndex = swiper.activeIndex;
        var params = swiper.params.cardsEffect;
        var _swiper$touchEventsDa = swiper.touchEventsData,
          startTranslate = _swiper$touchEventsDa.startTranslate,
          isTouched = _swiper$touchEventsDa.isTouched;
        var currentTranslate = swiper.translate;
        for (var i = 0; i < slides.length; i += 1) {
          var $slideEl = slides.eq(i);
          var slideProgress = $slideEl[0].progress;
          var progress = Math.min(Math.max(slideProgress, -4), 4);
          var _offset4 = $slideEl[0].swiperSlideOffset;
          if (swiper.params.centeredSlides && !swiper.params.cssMode) {
            swiper.$wrapperEl.transform("translateX(".concat(swiper.minTranslate(), "px)"));
          }
          if (swiper.params.centeredSlides && swiper.params.cssMode) {
            _offset4 -= slides[0].swiperSlideOffset;
          }
          var tX = swiper.params.cssMode ? -_offset4 - swiper.translate : -_offset4;
          var tY = 0;
          var tZ = -100 * Math.abs(progress);
          var scale = 1;
          var rotate = -2 * progress;
          var tXAdd = 8 - Math.abs(progress) * 0.75;
          var isSwipeToNext = (i === activeIndex || i === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;
          var isSwipeToPrev = (i === activeIndex || i === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;
          if (isSwipeToNext || isSwipeToPrev) {
            var subProgress = Math.pow(1 - Math.abs((Math.abs(progress) - 0.5) / 0.5), 0.5);
            rotate += -28 * progress * subProgress;
            scale += -0.5 * subProgress;
            tXAdd += 96 * subProgress;
            tY = "".concat(-25 * subProgress * Math.abs(progress), "%");
          }
          if (progress < 0) {
            // next
            tX = "calc(".concat(tX, "px + (").concat(tXAdd * Math.abs(progress), "%))");
          } else if (progress > 0) {
            // prev
            tX = "calc(".concat(tX, "px + (-").concat(tXAdd * Math.abs(progress), "%))");
          } else {
            tX = "".concat(tX, "px");
          }
          if (!swiper.isHorizontal()) {
            var prevY = tY;
            tY = tX;
            tX = prevY;
          }
          var scaleString = progress < 0 ? "".concat(1 + (1 - scale) * progress) : "".concat(1 - (1 - scale) * progress);
          var _transform3 = "\n      translate3d(".concat(tX, ", ").concat(tY, ", ").concat(tZ, "px)\n      rotateZ(").concat(rotate, "deg)\n      scale(").concat(scaleString, ")\n    ");
          if (params.slideShadows) {
            // Set shadows
            var $shadowEl = $slideEl.find('.swiper-slide-shadow');
            if ($shadowEl.length === 0) {
              $shadowEl = createShadow(params, $slideEl);
            }
            if ($shadowEl.length) $shadowEl[0].style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);
          }
          $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
          var $targetEl = effectTarget(params, $slideEl);
          $targetEl.transform(_transform3);
        }
      };
      var setTransition = function setTransition(duration) {
        var transformEl = swiper.params.cardsEffect.transformEl;
        var $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
        $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);
        effectVirtualTransitionEnd({
          swiper: swiper,
          duration: duration,
          transformEl: transformEl
        });
      };
      effectInit({
        effect: 'cards',
        swiper: swiper,
        on: on,
        setTranslate: setTranslate,
        setTransition: setTransition,
        perspective: function perspective() {
          return true;
        },
        overwriteParams: function overwriteParams() {
          return {
            watchSlidesProgress: true,
            virtualTranslate: !swiper.params.cssMode
          };
        }
      });
    }

    // Swiper Class
    var modules = [Virtual, Keyboard, Mousewheel, Navigation, Pagination, Scrollbar, Parallax, Zoom, Lazy, Controller, A11y, History, HashNavigation, Autoplay, Thumb, freeMode, Grid, Manipulation, EffectFade, EffectCube, EffectFlip, EffectCoverflow, EffectCreative, EffectCards];
    Swiper.use(modules);
    global.Swiper = Swiper;
    return Swiper;
  });
};
var _default = swiper();
exports.default = _default;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])


//# sourceMappingURL=main.min.js.map
